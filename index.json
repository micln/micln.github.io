[{"authors":["admin"],"categories":null,"content":"最爱拼积木，买不起后就玩 Flash 和 3D Max 过眼瘾。动画太弱智，就开始学编程\n高中开始接触 Pascal/Cpp，用 Visual Basic 给家里写了个进销货的小软件，赶过用开源程序折腾网站的小尾巴。\n大学先修电子，焊过板子烧过灯泡，业余开始接触 web 开发，用 JavaScript 移植过编程小游戏和一些其它的小玩意，用 Php/Go 改造过学校的 Online Judge。\n工作后先以全栈工程师加入创业公司，见识了各种好玩的业务形态。目前逐步专注于后端架构，同时开始试水项目管理。\n一句话，从兴趣驱动逐步沦为职业小码农\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":-62135596800,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"author","summary":"最爱拼积木，买不起后就玩 Flash 和 3D Max 过眼瘾。动画太弱智，就开始学编程 高中开始接触 Pascal/Cpp，用 Visual Basic 给家里写了个进销货的小软件，赶过用开","tags":null,"title":"huiren","type":"author"},{"authors":null,"categories":[],"content":"组内分享，大纲见 https://mubu.com/doc/5rXXQikGmPT\n","date":1587615784,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1587615784,"objectID":"b0719cb3179e71f1c3547c646ec59e54","permalink":"/post/ast_in_go/","publishdate":"2020-04-23T12:23:04+08:00","relpermalink":"/post/ast_in_go/","section":"post","summary":"组内分享，大纲见 https://mubu.com/doc/5rXXQikGmPT","tags":["Go"],"title":"Ast in Golang","type":"post"},{"authors":null,"categories":[],"content":"[TOC]\n从哪学  官方教程，有中文，提供给交互式练习，注意网络环境 https://kubernetes.io/zh/docs/tutorials/  概念  Pod：一个抽象的应用实例，含义上约等于 docker 里 container 的一层 wrapper，但是因为有了这一层，可以把多个 container 包在一起，共享网络和 Volume 等资源。 Service：也就是我们一般所理解的应用服务，通过 label 把一组 Pod 组织起来。 Devlopment：（没有找到什么特别清晰的定义）简单理解为一个应用的控制器，一般情况下通过它来间接管理 Pod  kubectl 常用命令 应用管理 create -f app.yaml 发布应用\nkubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1  scale 扩容\nkubectl scale deployments/kubernetes-bootcamp --replicas=4  set image 更新命令\nkubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2  rollout 等待更新完成\nkubectl rollout status deployments/kubernetes-bootcamp  本地安装过程的坑  网络必须ok，不然各种没反应，因为不知道依赖了哪些站点，直接用全局模式 图形界面（Dashboard）  介绍 https://kubernetes.io/zh/docs/tasks/access-application-cluster/web-ui-dashboard/ 安装时需要配个帐号（原链接失效，我看的这里）：https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md    ","date":1583986054,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1583986054,"objectID":"d6e3214119bcd12b8e70cb5725e37a20","permalink":"/post/k8s_starter/","publishdate":"2020-03-12T12:07:34+08:00","relpermalink":"/post/k8s_starter/","section":"post","summary":"[TOC] 从哪学 官方教程，有中文，提供给交互式练习，注意网络环境 https://kubernetes.io/zh/docs/tutorials/ 概念 Pod：一个抽象的应用实例，含义上约等于 docker 里 container 的一层 wrapper，但是因为有","tags":["k8s","快速上手"],"title":"k8s 上手笔记","type":"post"},{"authors":null,"categories":[],"content":"放在幕布里了，有需要再解释：https://mubu.com/doc/2neaB-ofTo\n","date":1577968442,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1577968442,"objectID":"8da746d3f467e7695f396323396c8522","permalink":"/post/tools/","publishdate":"2020-01-02T20:34:02+08:00","relpermalink":"/post/tools/","section":"post","summary":"放在幕布里了，有需要再解释：https://mubu.com/doc/2neaB-ofTo","tags":[],"title":"码农的神兵利器","type":"post"},{"authors":null,"categories":["项目管理"],"content":" 大概从小开始就没有时间观念，毕竟穷人的时间不值钱。上学时经常通宵敲代码，除了兴趣外，也有时间管不好的原因：大不了拖到晚上搞。最后就一直成了习惯\n 工作后，这个坏习惯就成了大毛病了：我做的项目经常延期。即便是一些没延期的，也不乏快结束时加班突击才搞完的，前期的时间管理依然做的很差。\n在两家公司做过开发，都多多少少有这个问题。即便是小项目，有时反而会想着，反正不是啥大问题，那就多设计，写的漂亮一些，七搞八搞还是延。\n一直到今年一次以项目负责人的角色去推动一次技术改造。先要说明，这种技术改造项目比较特殊，它本身更侧重长期价值。所以业务方和公司层面没有给出明确的要求和时间点，对应的，管理层会优先保证能带来直接收益的项目，对这些项目也只提供有限的支持。\n如往常一样，当目前出现重大意外时，我就去找领导说明情况了。以前很多领导对都我比较照顾，兴许就宽限两天了，最多说我两句也就过去了。但不巧这次碰上个不好惹的领导，他了解情况后告诉我：你是项目负责人，你要自己去想办法，别出了问题让别人来给你擦屁股，实在不行你就延到下个版本吧。再好好总结总结，为什么提前没有管理好风险。\n被骂回来一脸无助，不知道接下来该怎么办，想想实在不行就延吧。在我准备给20+个开发同步这个信息时，我就犹豫了：我司一个版本固定为15天，即便项目只需延2天，最终还是得跟15天后的版本发布。我完全不知道该如何告知大家这个悲惨的事实。\n我说你们干吧，干完别上线，等我通知？还是说你们先干别的吧，十天后再回来跟我继续搞？十天后要是又有突发情况怎么办，继续延？简直是搞笑。而且这个项目本身周期就很长了，再拖下去，我自己都疲惫了。\n那天晚上想了很久（印象中很多人都走了，我还发呆到很晚），想了各种方案和可能、好的不好的结果，最后终于认识到了一件事：无论如何，我都必须按时交付。\n跟三位小组长沟通了我的想法后，得到了结论：\n 必须按时交付 整理手上的资源，按照剩余时间重新排期 按优先级排期，排不上的东西就坚决砍掉 排上的东西，按优先级、任务量，先做重要的，万一后面再有意外，不重要的也砍掉  其实这四点里，只有第一点是目标，按照项目管理金三角，自然会得到后面的手段。惭愧的是，在我以前经历的那么多项目里，从来没有把时间当做一个目标点来对待。\n这中间还做了很多具体的事情，比如最紧张的阶段，我们一天早晚两次例会，早上确定今天要做的事、相关的资源准备是否到位；下午“检查”今天的任务是否如期完成。出现任何问题，第一时间处理。确保跟计划没有偏差（这个地方还有个话题：你以为没有偏差真的就没有偏差嘛）。\n后来，在很多人都不相信的情况下（包括我自己），我们居然如期上线了。因为项目的特殊性，中间出现了好几次意外，每次都觉得自己扛不住了，发项目日报时用词都是“坚守XX号提测”，但幸运的是，最终还是在所有人的帮助下挺了过来。\n最后，综合项目的难度、复杂度和不确定性，整个项目得到的评价也很高。\n总结一下，最大的认识就是，把时间当做一个目标点来对待。以前提目标时只说“完成XXX”，之后必须要写 “XX前完成XXX”。\n只有真正把时间放在心里，才会有抵消延期的行动。\n","date":1571497867,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1571497867,"objectID":"6ed0bbd87da9fe1f41f065275067e2f8","permalink":"/post/overcome_procrastination/","publishdate":"2019-10-19T23:11:07+08:00","relpermalink":"/post/overcome_procrastination/","section":"post","summary":"大概从小开始就没有时间观念，毕竟穷人的时间不值钱。上学时经常通宵敲代码，除了兴趣外，也有时间管不好的原因：大不了拖到晚上搞。最后就一直成了习","tags":[],"title":"拯救拖延症","type":"post"},{"authors":null,"categories":[],"content":"之前遇到了很多 timeout，但是仔细看错误提示好像不完全一样，于是就做了个简单的试验：\nClient 上看到的错误 找不到服务器（no such host）的几种情况：\n# 域名不存在，瞄了下代码，应该是 dns 包返回的 Get http://a.b/abc: dial tcp: lookup a.b: no such host # ip 不合法不会直接检查，也会返回同样错误 Get http://127.0.0.1888:8080/abc: dial tcp: lookup 127.0.0.1888: no such host # 端口瞎填会直接报错，都不会发请求 Get http://127.0.0.1:65536/abc: dial tcp: address 65536: invalid port 拒绝连接，对方端口未监听、进程挂掉等等\nGet http://127.0.0.1:8080/abc: dial tcp 127.0.0.1:8080: connect: connection refused 建立连接超时\nGet http://127.0.0:8080/abc: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) 等待返回 header， 一般是接口还在处理逻辑，没有返回任何数据；或者对方只是个普通的 tcp 服务，但不是 http\nGet http://127.0.0.1:8080/abc: net/http: request canceled (Client.Timeout exceeded while awaiting headers) 客户端读取超时：已建立好连接，已经开始返回数据，但是body 太大太慢：\nwait_test.go:48: net/http: request canceled (Client.Timeout exceeded while reading body) Server 上看到的错误 客户端主动断开连接，服务器端在调用 Write(p []byte) (n int, err error) 时会返回：\nwait_test.go:21: write tcp 127.0.0.1:8080-\u0026gt;127.0.0.1:49290: write: broken pipe 客户端主动断开连接，通常会直接使用 ctx.Done() 检测到，这个时候 ctx.Err() 里会拿到这个信息：\ncontext canceled 参考链接：\n https://colobu.com/2016/07/01/the-complete-guide-to-golang-net-http-timeouts/  ","date":1570176674,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1570176674,"objectID":"fee99d74e8b9d46c30d69930c7c19942","permalink":"/post/go_net_errors/","publishdate":"2019-10-04T16:11:14+08:00","relpermalink":"/post/go_net_errors/","section":"post","summary":"之前遇到了很多 timeout，但是仔细看错误提示好像不完全一样，于是就做了个简单的试验： Client 上看到的错误 找不到服务器（no such host）的几种情","tags":["Go"],"title":"Go 网络处理中的几种错误","type":"post"},{"authors":null,"categories":["项目管理"],"content":"先说下标题，所谓独立推项目跟之前的推项目（最多只能叫跟项目）区别在哪里。\n    跟项目 推项目     项目来源 主版本的大项目，分了一小块给我来跟 由我向上面发起   需求定义 PM 说啥就干啥，PM 说砍啥就砍啥 共同协商，我拍板   风险处理 报给大版本负责人 自己消化，消化不了就背延期的锅   资源排期 整体安排，各别协调 啥啥没有，自己想办法    最明显的区别是，凡事没有退路。心(pi)态(gu)变换导致很多做事方法完全不一样\n注：后面每个大标题都表示一块项目管理的工作内容，不分先后，重点写自己做的不好的，可以挑自己感兴趣的看。\n为了便于后面描述，这里简单介绍下这个项目，简单说，我们做的就是统一实体的唯一标识。\n比如用户的唯一标识是什么，至少我见过几种方式：user_id、id_card、phone、email等等。 不同系统存一个用户用的标识不一样，通信的时候非常麻烦，来回转换。\n然而，我们系统内的情况更复杂：\n 我们有10+种主要实体（课程、电子书、音视频等等） 每个实体要对接8+种通用服务（收藏、进度等等） 超过一半的实体都用了两种以上的标识（数字 ID、别名 alias、甚至还有人用课程关联的视频 ID 作为课程的 ID）  在我的理解里，N种实体，M 种抽象服务，如果抽象得当，那么对接成本应该是 N+M。但在这种实际情况下，对接成本可能到了 NM2.5。\n除了开发成本，带来的问题更加可怕。\n 用户反馈收藏的课程不见了，一查发现，收藏接口传的音频 ID，取收藏数据传的视频 ID，其实应该传课程 ID。 某节课程的所有用户留言都不见了，一查发现，留言系统用的“课程所关联的音频ID”作为课程ID ，然而这批课程换了一批音频，音频 ID 全变了。数据也自然都对不上了。你说赶紧洗数据吧，可是都不知道哪些音频改过  后来我实在受不了这些祖传屎山了，就找老板讨个规范。老板一听很高兴，把我跟几个端的 leader拉了个小群，提了一下这个问题，说统一业务模型很重要、隔离系统边界很重要。xxx 来负责，先把接口搞干净。\n于是就稀里糊涂地接了这个活，坦白说，这个事情技术难度只能算中等偏上，也就是一点点抽象能力。但它极大考验协调和项目管理能力。具体说，需要配合的人非常多，因为各个端都得改一通，在我司极少有项目需要牵扯这么多人和端。而且，我的职级也不高，要让这么多人因为我一句负面的吐槽就听我号令，实在是痴人说梦。\n光我说难不算，我也问过几个leader意见。客户端某端负责人说，你们这么折腾，就相当于把 App 重写一遍。一位架构师告诉我说，去年就想搞了，但是端上的阻力太大，就不了了之了。\n最后给我的感觉就是：大概率不成，全当一次历练吧。\n万幸中的万幸，经过一个多月的鏖战，总算是上线交付，得到的评价还不错。\n后面就来说说一些过程中遇到的问题\n最耗精力的工作内容：划清项目范围边界。 一般随版本走的的产品需求，在开工前80%的需求都是确定的，时间点也是固定的，资源也比较足，按部就班地做一般不会出问题。\n但是技术改造就很麻烦，名义上是一个独立项目，可以做完后单独发版，没有明确deadline。但实际上，每个人都会先做火烧眉毛的事情，没有 deadline说明还能放一放。而且老板那里肯定会有个心理预期的，不能一直拖。于是大家一起简单梳理了接口范围，定了个“一个月”。\n技术改造还有个问题，准确的成本要看到代码才知晓。我们也是真正开工的时候才发现，这个技术改造跟其他6个技术改造项目有关联，比如迁移新接口、迁移新路由、 服务化改造、部分系统重构等等。这些改造目前都算是“重要不紧急”，很多都是说要做，但是做了一半就放在那里了。一说这次要动那部分的代码，都想着能不能“顺手”把哪个改造也一起做了。\n如果拒绝有什么影响呢：\n 面上的，减少项目成果，降低项目意义和价值。像是做了个半吊子工程 部分代码要改，但改的不是最终版本，还要兼容，后面可能还要返工。这点会严重打击开发的积极性  如果接受，自然能避免这两个问题，但是会有其他问题\n 改动代码范围变多，质量风险会大大提高 项目范围膨胀，极有肯能严重延期或烂尾。 这两点都算是项目的命根子，如果发生这类问题，约等于成果为0，前功尽弃  为了在这些矛盾点做取舍，我们耗费了大量的精力去讨论、调整项目的边界。如果一件事情不做，项目意义是否会丢失，丢下的有什么补救措施，是否还需要二次开工。如果做了，对我们目标帮助到底有多大，会引入多少风险，需要多少资源开销。\n最开始的时候风险看起来不多，可以考虑多做一点，也很容易借此把大家团结到贼船上。到了中期，我们对整个项目的时间点已经有了比较清晰的预估，也提前协调好了测试资源和上线准备。但与此同时，整个项目有不断膨胀的趋势，我们几个主要负责人调整策略，一切以项目按时按质交付为第一目标。遇到任何带来风险的包袱，果断丢下。最终卡在边缘完成了交付。\n项目目标同步不到位 这个跟上面的相反，范围不清晰会引来项目膨胀，但目标不明确，会在开发过程中丢三落四。\n最广为熟知的案例莫过于造秋千。当工程师认为要做的只是在树上挂两根绳子时，整个项目已经在脱离目标和计划了。很多工程师最终得到的任务是给接口加两个字段，至于字段最后干嘛用，也不是特别清楚，更不用说加的对不对了。\n同样，我们耗费了很多精力去说明白我们到底要做什么，要向大家确认，做的事情跟目标是否一致。\n去年锁元老师带我们做了一个叫项目管理ABC的小游戏，我非常推荐刚开始接触项目管理的同学去玩两把。每次想到这个游戏和凄惨的结果，都觉得好像还有什么没跟大家交代清楚。\n规范型项目，项目的意义和愿景要深入人心 我以为有了目标，这事就算结了。直到我发现有一位同学，在参与这次技术改造时，很配合地把那些乱七八糟的接口都改成了约定的 ID，结果在新开的项目和接口里又用回了乱七八糟的标识。交流之后发现，在他理解上，只是以为我们要把那部分接口改一下，为什么要改，不关心。也不会意识到以后新的接口应该按规范的方式来。\n这件事情一开始我以为是规范没有确立导致的，加个明文规范：“强制必须使用业务主键来通信”。后来发现，这个规范其实跟没有一样，因为什么是“业务主键”完全是由开发自己说了算。\n在我的意识里，所谓的 MySQL范式可能是不言而喻的，但是对于很多人来说，根本分不清何为实体（entity），何为标识（Identity）和属性（property）。你得去跟他们讲明白，举例子，为什么这个字段是ID而那个字段不能是 ID。在别人看来，可能也只是你的一厢情愿。\n必须承认这里有个困局，一般项目宣讲会上，愿景、意义、目标普遍被认为是假大空，也是大家最不想听的，通常得到的反馈就是“你啰嗦了那么半天，我就想知道我具体要怎么做”。对于这一点，我自己也一直也没有什么好办法。目前唯一在尝试的，就是在过程中面对成员的困惑时，借机再用意义目标来引导。通常这个时候我讲的也更容易被接受。\n最惨的一个教训：拆分到具体可观测的小任务。 站会的时候，我们得到了开发同学的答复：某个接口已改完。后来发现，所谓“改完”。。\n这个问题以前就经常遇到，就连《人月神话》里也提过“已完成80%”的梗。但是直到自己的角色成了“项目负责人”，才真正开始思考怎样减少这类风险。\n代码未动，计划先行。 计划不一定是把准确的尺子，但一定是任何情况下的行动指南。\n最尴尬的问题：砍掉的范围，如何给后人交代 最没脾气的错误：对客户端的了解和发言权远少于后端 经常会面对这样一个场景，客户端告诉你这个太复杂，他那边不好处理。这个时候，即便你的意义愿景再牛逼，目标再清晰，这个时候也发挥不了什么用。\n我的一个经验是，主动走进客户端，了解他们的架构。通常情况下，你会发现他们说太复杂是按照要改5个模块算的，当你看了他们的架构后，可能只需要改2个模块就够了。这个过程中，也花了不少时间跟客户端同学在一块，人手把手地给我讲客户端的一些东西。就这次的案例来说，我觉得还是很值得的。\n你可能会问，这是否在质疑客户端的专业能力和架构能力。我觉得并没有，之所以能帮他们找到答案，并不是专业能力的差距，更多地是对项目目标的清晰认识和坚持，而他们，正因为对代码太熟了，更容易忘记自己当下的目的。举个不恰当的例子，我觉得我的器官缺一不可，结果一位盲人说，就算没有眼睛也可以活得不差。显然这位盲人并不是在说我眼睛没用。\n应对突发状况：灰度前2个小时发现新问题 可以有两分钟的情绪宣泄期，但作为“负责人”，一定要尽快冷静，召集相关的人，商量解决方案，做好接下来的安排。\n要顺势而为 开会叫多少人 最不好开口的：要资源 ","date":1569380909,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1569380909,"objectID":"429b11e4a7c084f1c204dd3db8fb703c","permalink":"/post/engineering/project_first/","publishdate":"2019-09-25T11:08:29+08:00","relpermalink":"/post/engineering/project_first/","section":"post","summary":"先说下标题，所谓独立推项目跟之前的推项目（最多只能叫跟项目）区别在哪里。 跟项目 推项目 项目来源 主版本的大项目，分了一小块给我来跟 由我向上面发起","tags":[],"title":"记一次“独立推项目”的心得体会","type":"post"},{"authors":null,"categories":["Kretech"],"content":"Go 让人吐槽的点之一就是动态特性低，比如不支持泛型、反射鸡肋等等。所以长期以来一直觉得搞一些动态功能是一件很酷的事情。\n这里主要做了两件事：\n 运行时获取变量名，并以此为基础做了一个调试工具 XGo/Dumper 运行时获取函数签名，以此为基础做了个小类库，可以将任意函数暴露为 http 接口，同时还支持生成 swagger 文档。  中间主要用到了 ast 包的工具（因为想偷懒，也踩了不少坑）。基本思路都是通过 runtime 或 reflect 包，得到一些基本的信息，比如 fileline 和 pc，然后借此再拿到 ast，通过一些上下文信息来定位相关部分的代码，转换为需要的东西。\n","date":1566578036,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1566578036,"objectID":"18f3bcdaf8e3843340ed6733147543e0","permalink":"/post/dynamic_in_go/","publishdate":"2019-08-24T00:33:56+08:00","relpermalink":"/post/dynamic_in_go/","section":"post","summary":"Go 让人吐槽的点之一就是动态特性低，比如不支持泛型、反射鸡肋等等。所以长期以来一直觉得搞一些动态功能是一件很酷的事情。 这里主要做了两件事： 运行","tags":["Go"],"title":"在 Go 里用 reflect 和 ast 实现动态特征","type":"post"},{"authors":null,"categories":[],"content":"先说说背景，为什么MacBook还在吃灰，又开始折腾Linux Desktop了\n 家里组了台PC，只打游戏太浪费，且实在搞不定windows写代码。 传闻 manjaro 优化的不错  于是同时把pc和数莓派都改了。\n烧U盘偶尔失败 表现为：烧录校验失败、无法启动\n按理以前从不会遇到，重新烧几次就好了，可能是u盘年久失修了。\n加速源 这个地方坑了半天，一直以为manjaro就是arch的源，后来经 zsrkmyn大佬 鄙视，才知道是不一样的。。\n所以 manjaro要做两件事，一是加速manjaro源，二是引进archlinux源，后者用来加一部分arch社区的软件。\n参考：\n# 换中国源 $ cat /etc/pacman.d/mirrorlist ### Country : China Server = https://mirrors.ustc.edu.cn/manjaro/stable/$repo/$arch # 加 archlinux $ tail /etc/pacman.conf [archlinuxcn] SigLevel = Optional TrustedOnly Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 还有个深坑，数莓派用的源的地址不能只把 manjaro 改成 manjaro-arm，后面的 $repo 和 $arch 顺序也不一样。 而且很多镜像源只提供 manjaro 不提供 marjaro-arm。\n最开始没仔细看，坑了好久。。\n无线网卡驱动 刚装机的时候没有网络，我用的老旧android手机连wifi，插到电脑上，允许usb上网。电脑会识别成以太网（win/mac也支持），网速还是挺快的，除了累赘，体验比无线网卡还好。\n我用的华硕USB-AC57，官网有驱动，下下来不能用。看下文件名，一般是 rtlXXX-linux-driver，这个rtlxxx就是型号，直接去网上搜关键词。arch aur 里就有社区版本，按步骤编译安装就好使了。\nTODO 开机联网慢，还没处理\nTODO 最近网络不稳，猜测也是这个驱动问题\n尽量还是走有线吧。\n输入法 默认安装好 fcitx 后，状态栏也有了，但是不能切换。原因是并没有在x环境下启用，我的处理办法是在 xinitrc 里加了几行配置。\n参考：\ntail ~/.xinitrc export XMODIFIERS=\u0026#34;@im=fcitx\u0026#34; export GTK_IM_MODULE=xim export QT_IM_MODULE=xim exec $(get_session) # 这行原来就有，不要动。在上面加三个export就行。 另外，fcitx-qt4 会和 fcitx-gtk* 冲突，我用的后者。前者貌似才能支持搜狗。\n网络 装机需要配个pac，不然很多东西下不动。\n最好是在路由器里支持。\nmanjaro里的话，好像只能针对每个网络单独配置。\n数莓派同时安装了酸酸乳和奶牛作为统一的入口，macbook顺利通过，但manjaro走奶牛PAC一直走不通，后来莫名其妙好了。。\n用户目录改英文 网上搜了一堆教程都需要 xdg-user-dirs-gtk-update，但默认只有 xdg-user-dirs-update，擅自用了后者发现不好使，要装一下前者：sudo pacman -S xdg-user-dirs-gtk\n","date":1565453088,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565453088,"objectID":"b7ac54782f337f6ee0152f18f1d5bd87","permalink":"/post/manjaro_go/","publishdate":"2019-08-11T00:04:48+08:00","relpermalink":"/post/manjaro_go/","section":"post","summary":"先说说背景，为什么MacBook还在吃灰，又开始折腾Linux Desktop了 家里组了台PC，只打游戏太浪费，且实在搞不定windows写代","tags":["Linux","Manjaro"],"title":"Manjaro 踩坑记录","type":"post"},{"authors":null,"categories":["最佳实践"],"content":"今年接手了一个新项目，不算vendor包，大概6W行代码，接的时候信心满满准备大干一场。结果半年内线上出了100多个bug。\n粗糙统计下，80%的代码是原来直接留下的，剩下的基本都是一脸懵逼地踩坑。其中也有不少是之前都知道，但是没处理掉，甚至还有查不到原因最后不了了之的。\n流程与业务规则隔离 其实在上一家公司工作时就已经意识到这个问题的严重性，尤其是业务流程和业务规则经常来回改。\n业务流程通常是一段简单的过程，甚至都不包含太多的分支流程。\n业务规则是指针对不同的数据，在各个环节里需要不同的处理。\n最常见的处理方式就是无处不在的 ifelse，这种方式的问题在于，每次改规则都要从头改一大堆代码，改完了还可能会影响其它 case，要整体回归才可以。效率和稳定性都很差。\n更好的办法是，在主流程上使用 interface 把业务流串下来，每种 case 各自实现接口，各自测试。\n有个小地方要注意，在设计这个 interface 时，要注意接口隔离原则，否则可能会出现为了增加一个特殊的 case，导致其它实现也跟着改一通。\n日志那么多，有多少能帮助你还原现场 每打一行日志，都想想什么时候用，怎么用。\n横向耦合、纵向耦合如果同时出现，代码就废了 一脚一个雷。\n该收的口子一定要收口 一段代码同时copy在多个流程里，维护起来丢三落四。\n丑陋的封装优于复制粘贴。\n聚合服务，千万不要关心别人的细节 尤其是多个依赖的细节还不一样，真是灾难\n双写幂等性，可修复性 不要第一次双写失败，导致后面数据都对不上。\n出现不一致，一定要第一时间报警\n避免阻塞性依赖 阻塞性依赖在流程管理中挺常见的，通常表现为在一系列操作中有几个操作依赖于不稳定的第三方。当中间一个环节出现不可控的故障时，会导致你的整个流程走不下去，然而因为是第三方出了问题，你只能干等着。\n如果同时你的接口不具有全局的幂等性，这个问题还会造成非常恶心的数据不一致，处理起来也非常麻烦。\n一个设计上的优化是把依赖第三方的环节后置。举个例子：\nBBS 里用户发的消息要经过敏感词检查才能放出来，但如果你的敏感词接口挂了，可能导致全站不能发帖。一个可行的办法是，先发帖成功，再异步调用敏感词接口。有个问题是，在敏感词接口返回结果或恢复正常前的这段时间，贴子展示出来是否有风险？这个可以依据业务场景来处理，平时可以默认先放出来，敏感时期，那就让这个帖子只有自己可见，其它人等审核完成后才能看到。\n成本会稍微高一些，但是系统健壮性会好很多。\n字段命名一致性 数据结构上，不建议一个字段在不同场景下表示不同含义 大概出于省空间的目的，一个字段在不同 case 下表示了完全不一样的含义，时间长了。大家都懵逼了。\n依赖服务的返回值，日志一定要清晰 善意的质疑，降低撕逼风险，这大概叫职业。\n处理err时，一定要想想：如果这个error出来了，如何主动让我发现 api 错误后，如何快速定位哪一层抛的错\n任何有业务含义的字段不能用来做pk 一改就疯\n数据修改记录的重要性 最严重的有一张表没有创建和修改的时间戳，查数据问题时，都不知道从哪里开始查。\n","date":1564381171,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1564381171,"objectID":"3101941da25de25fb42e0f0daed37b73","permalink":"/post/code_after_100_bugs/","publishdate":"2019-07-29T14:19:31+08:00","relpermalink":"/post/code_after_100_bugs/","section":"post","summary":"今年接手了一个新项目，不算vendor包，大概6W行代码，接的时候信心满满准备大干一场。结果半年内线上出了100多个bug。 粗糙统计下，80","tags":["Go"],"title":"Coding After 100+ Bugs","type":"post"},{"authors":null,"categories":["最佳实践"],"content":"最开始的项目目录\n$ tree . ├── ./api/ ├── ./service/ ├── ./dao/ ├── ./model/ ├── main.go func main(){ flag.Parse() artemis := NewArtemis(flag.String(`config`))\t// artemis 是我们的框架，类似beego \tlog.init() service.init() dao.init() worker.init() api.Route(artemis.Router) artemis.Run() } 写个测试吧\npackege dao func TestGetNote(t *testing.T){ db := NewNoteDB()\t// panic: app not init \tdb.Get(1) } 改：\n copy启动代码 把config路径改一下 去除不需要的部分，比如在 dao 里去掉 service.init()  func TestGetNote(t *testing.T){ artemis := NewArtemis(`../../config`) log.init() ddns.init() service.init() dao.init() // test code } // 也可以放在 TestMain 里统一处理 func TestMain(m *testing.M){ // init()  m.Run() }  简单粗暴的解决办法，调试也够用了。\n如果 package 比较少，也没那么多脚本要用，已经能满足需要了\n 但当时我觉得还是不完美，我的项目又比较复杂，然后继续尝试优化：\n先\u0008抽出个函数放重复代码\npackage boot func Boot(){ // init() } func BootTest(){ SetRootPath()\t// 在子目录跑ut时，要把 wd 对齐到项目目录 \tBoot() } package main func main(){ boot.Boot() artemis.Run() } package dao func test(){ boot.BootTest() // test code } $ go build import cycle not allowed # dao 和 boot 互相依赖 改成外部测试\npackage dao_test import \u0026#34;dao\u0026#34; func test(){ db := dao.NewDB() } 缺点：\n ugly 不能测私有函数 每次改动几乎重新编译整个项目  最后一点很重要，测试代码时会频繁修改，而每次修改几乎都要重新编译整个项目。 我的项目在忽略缓存的情况下，编译需要30s 调个bug，一下午就过去了。。\n回头一看整个过程，总结就是\n　  民科  \n于是，放下一切，重新开始\n我想要什么？\n 不用太多重复代码，好维护 需要时再加载，不需要在测试时搞一堆没用的东西  看看成熟的框架是如何处理的，以我熟悉的 Laravel 为例，很多地方都采用了这样的思路：先注册，后使用\nclass FooServiceProvider { function register($app) { $app-\u0026gt;singleton(\u0026#34;noteDB\u0026#34;, function(){ $noteDB = new NoteDB(); }) $app-\u0026gt;sinleton(IRouter::class, new Router()) } function boot() { make(IRouter::class)-\u0026gt;load(); } } 突然发现，Go的init就是天然的注册机制\n 所有的init都一定会在main之前执行 依赖包的init一定先于本包的init，连优先级都帮我做好了  于是大概轮廓就出来了：\n 在每个 init 里定义自己需要启动什么，代码里依赖了哪个包，就会调用对应的init，不依赖的不会启动 运行cmd（webserver/script/test）时，再逐个执行init时注册的任务  package dao func init(){ boot.Register(func(){ // ... \t}) } // web server func main(){ boot.Boot() defer boot.Shutdown() api.Route(artemis.App) artemis.Run() } // script func main(){ boot.Boot() // ... } // test func TestMain(m *testing.M){ boot.Register(factories.Init) boottest.Boot() defer boottest.Shutdown() m.Run() // ... } 到此，基本上达成了写脚本、写单测时不用操心框架启动的问题。\n不过限于框架限制，依然有一些不爽的地方没有解决。\n Go很多人摒弃了面向接口编程，导致在写UT时无从mock。后面想办法靠工具对所有的类走一次DI容器 测试的问题，限于框架限制，不能全局开始事务  ","date":1562037076,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1562037076,"objectID":"7f1e84edcc3f8c718bf4b5118db750a1","permalink":"/post/boot_test_in_go/","publishdate":"2019-07-02T11:11:16+08:00","relpermalink":"/post/boot_test_in_go/","section":"post","summary":"最开始的项目目录 $ tree . ├── ./api/ ├── ./service/ ├── ./dao/ ├── ./model/ ├── main.go func main(){ flag.Parse() artemis := NewArtemis(flag.String(`config`)) // artemis 是我们的框架，类似beego log.init() service.init() dao.init() worker.init() api.Route(artemis.Router) artemis.Run() } 写个测试吧 packege dao func TestGetNote(t *testing.T){","tags":["Go"],"title":"Go项目在组织启动代码上的一次尝试","type":"post"},{"authors":null,"categories":["最佳实践"],"content":"原以为浮点数是计算机编程的基础知识，后来发现个奇怪的现象：很多人都说浮点很坑，千万不要用，至于为什么却说不出个所以然。更有甚者，以专业民科的架势发明出一套处理浮点的办法，应该如何如何，不该如何如何。网上也看到不少人对这个现象很困惑，解释为湿猴理论。\n通常你问别人浮点有什么坑，如果别人说浮点数不能用==，十有八九这个人会认为，浮点数可以用\u0026gt;\u0026lt;的。不过你继续追问，他可能就会犹豫了。\n看代码：\na := 0.1 b := 0.2 c := 0.3 fmt.Printf(\u0026#34;%10s =\u0026gt; %v\\n\u0026#34;, \u0026#34;a+b\u0026#34;, a+b) fmt.Printf(\u0026#34;%10s =\u0026gt; %v\\n\u0026#34;, \u0026#34;a+b == c\u0026#34;, a+b == c) fmt.Printf(\u0026#34;%10s =\u0026gt; %v\\n\u0026#34;, \u0026#34;a+b \u0026lt; c\u0026#34;, a+b \u0026lt; c) fmt.Printf(\u0026#34;%10s =\u0026gt; %v\\n\u0026#34;, \u0026#34;a+b \u0026gt; c\u0026#34;, a+b \u0026gt; c) https://play.golang.org/p/QdoleMRyJr3\nwhy？\n  按照浮点标准，0.1 转化成二进制是个无限小数\n  浮点数有效长度有限，必有取舍\n  总结，二进制无法准确表达0.1，多多少少会有点失真。遂不能直接比较大小。\n更详细的论述：https://www.zhihu.com/question/28551135\n浮点数如何比较？ 通常做法，如果两个数的差值在可接受范围内，就认为是相等的。其实很多非精确的比较都是类似方法，比如\n1、两个人年龄、五官等等主要特征都很像，你就敢猜这俩人是双胞胎了。 2、你的服务10:03开始大量报错，隔壁服务10:02上了个线，你猜大概就是他的锅。\nvar floatPrecision = 1e-6 func floatEqual(a float64, b float64) bool { return math.Abs(a-b) \u0026lt; floatPrecision } func floatLess(a float64, b float64) bool { return b-a \u0026gt; floatPrecision } func floatGreater(a float64, b float64) bool { return a-b \u0026gt; floatPrecision } func main(){ fmt.Println(floatEqual(a+b, c))\t// true } 浮点数怎么转换 跟整型转换比较简单\n// 去尾 func floatFloor(a float64) int { return int(a) } // 四舍五入 func floatToInt(a float64) int { return int(math.Round(a)) //return int(a + 0.5) } 跟浮点转换就有意思了\n// 打印浮点数 func testFloatToString(){\tf := 16.99 fmt.Println(f * 10) fmt.Println(f * 100) fmt.Println(f * 1000) fmt.Println(f * 10000) fmt.Printf(\u0026#34;%.2f\\n\u0026#34;, f*10000) fmt.Printf(\u0026#34;%.0f\\n\u0026#34;, f*10000) } 169.89999999999998 1698.9999999999998 16990 169899.99999999997 169900.00 169900 strconv\n https://gowalker.org/strconv#FormatFloat https://gowalker.org/strconv#ParseFloat  浮点数要不要用字符串传输？ 有人问，如果别人想传1，结果传了个0.99999，不就失真了吗？\n基本上这样问的都是因为用的时候直接用了比较操作符。\n 原来的 double 有 15 位有效数字，一般转成 string 后只刻意保留了几位，如果是直接截取，其实是主动丢弃了准确度。\n举例：本来要传 1，截取之后传了 0.999 ，别人并不不知道这个 0.999 是准确值还是你截出来的。\n 个人推荐，传输的时候保留原数据，只有在渲染的时候再做格式化处理。\n问题核心：怎么存不重要，怎么用才是关键。想着存的时候干净一点，用的时候就随意了。\n财务场景下的特殊处理 仔细想了想，好像财务上也没什么特别要处理的，怀疑自己知识面不够，就去网上翻了翻，虽然没看到什么新问题，却又不少其他的收获。比如\n 系统性误差有系统性解决办法\n 我对这句话的理解，不要把计算机看得太重了，计算机只是解决领域问题的一个工具，准确的说只是特定时期的计算工具，专业的领域在手工计算的时代就有专业的算法了。\n这里只提一个最开始想到的跟普通场景的区别：不能简单的四舍五入\n先抛开小数不谈，现实生活中，3个人平分10块钱，理论上一人3.33，实际上大家会按照3-3-4来分就够了。放到微信群收款里，也是3.33*2+3.34。并没有统一用四舍五入。\n这种问题在实际问题中出现也比较多，把一笔订单拆分成几笔子订单，把一笔成本摊销到一年。在做除法的时候都要根据具体场景来做取舍。其实都不算什么浮点问题。\n扩展  能否直接用高精度 math/big.Float 来解决浮点数的诡异问题？https://play.golang.org/p/-8C7Gg7uHxd wiki https://zh.wikipedia.org/wiki/IEEE_754  ","date":1561385575,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1561385575,"objectID":"23b9393d8aa77a6c74bdd520cccba5b0","permalink":"/post/float_kidding/","publishdate":"2019-06-24T22:12:55+08:00","relpermalink":"/post/float_kidding/","section":"post","summary":"原以为浮点数是计算机编程的基础知识，后来发现个奇怪的现象：很多人都说浮点很坑，千万不要用，至于为什么却说不出个所以然。更有甚者，以专业民科的","tags":["float"],"title":"当我们在说浮点数精度不准的时候，到底在说什么","type":"post"},{"authors":null,"categories":["最佳实践"],"content":"原文地址：https://romatic.net/post/avoid_npe_in_go/\n空指针异常 NPE 在所有编程语言里都是个很麻烦的事情，Go 在设计之初已经在尽力减少 null 的使用范围。但是由于 Go 刻意隐藏了值和引用的概念，很多新手在编码时容易搞混空引用和空值，引发了不少 panic。\n这里试图提供一些减少 NPE 的方法出来。经验之谈，供参考。\n 先来看一种最常见的情形\n定义嵌套结构体时，尽可能不嵌套指针 比较容易理解\ntype Male struct{ Human } 组合时优先用 Human 而不是 *Human。\n有人会顾虑，那我想用 *Human 的方法怎么办，其实，*Male 其实是包含 *Human 的方法的。\n这样做最主要的原因，也是很多人在 new(Male) 时忘记 new(Human)，导致给上层抛了个 nil。如果这个 struct 直接转成 json 抛了出去，下游恰好对 null 也没处理好，这就是个跨端 bug 了。\n帮同事查问题时还遇到过更隐藏的坑，这个 Human 里可能还有个结构体指针假如是 *Face，代码从 Male 直接调 *Face 的方法，自然就 panic 了。悲催的是，在 IDE 里帮他调代码，会直接跳过 Human 这一层，在阅读代码时没有直接找到问题所在，不得不搬出 DEBUG 才看到。\n这个也可以衍生一个小建议，定义变量尽量用 struct 而不是指针，传参的时候再使用。不过到底有多少收益，还值得商榷。\n函数尽可能不返回 nil 看一个连环坑\n// 获取 user 对象 func GetUser() (*User, error) func main() { user,err := GetUser() if err != nil { write(err.Error()) return } println(user.Name)\t// panic user=nil } 一般的，我们会觉得既然我都判 error 了，user 的值总该是正常了吧。只能说 too naive，真正垃圾的代码是没有底线的。反应快的人可能马上想到解决办法，在 err != nil 的地方也判一下 user：\nif err != nil || user == nil { write(err.Error()) } 然后，就悲催的发现还是 panic 了。因为当 user=nil \u0026amp;\u0026amp; err==nil 时，也会走到 err.Error() 这里，这里的 err.xx 又是一个 NPE！\n老老实实的一个个处理固然是好办法，但是难保谁一个手抖。\n所以我们换个思路，想想能不能对 GetUser 这个函数做一些要求。问题就变成了有什么简单的办法让函数不返回 nil。\n不说中间的尝试了，直接说我们的结论：\n 函数返回值可能返回 nil 时，定义返回值必须 带上变量名，并且在函数体内 首行进行初始化。函数返回时 不带变量名\n 给个例子：\nfunc GetUsers() (users []*User, err error) { users = make([]*User, 0, 32) // function body \treturn } 三个条件\n 必须有变量名 必须首行初始化 return 无参数  这三点共同保证第一个目的：函数在任何地方 return，都不会给上层抛出 nil\n具体解释一下，为什么 变量名放在函数签名里而不在 return 里。是因为当函数很复杂需要多个 return 时，每个 return 时 users 里是啥你心里不一定有概念。也顾不上去考虑。索性把这个任务就交给定义阶段了。\n另外，返回值在函数开头就一起定义\u0026amp;初始化了。在 code review 时也更容易注意到。在看函数体的时候也不用再去想这个问题了。\n 调用函数时尽可能不传 nil 在 Go 里有个很普遍的情况，函数的最后一个入参其实表示的是函数返回值。看例子：\nfunc getUserArticles(userId int, articles map[int]Article) { articles[1] = \u0026amp;Article{}\t// panic: articles 未初始化 } 好说，那我 new 一个吧。一般没问题。\n但是如果 articles 里已经有一部分数据了，这里只是需要你 append 呢？更常见的，articels 是个结构体指针，里面有一些字段是需要的，你不能给删咯。\n还有，如果这个参数传了好多层，鬼还记得他里面到底是啥。\n针对这种 case，我们也做了一些简单的约定：\n 谁定义，谁初始化\n 参照这个例子来说，\n 如果函数为 func() articles，那我来初始化，保证不返回 nil，如果保证呢？参照上面那条规范。 如果函数为 func(articles)，那调用方来初始化，保证不传 nil  两个简单的约束，保证绝大多数参数简单稳定地运行。\n 下班时突然心血来潮想整理一下，休息一下。未完待续。。\n欢迎讨论。\n","date":1558015104,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1558015104,"objectID":"7baba1c21fc791d040959ffc2f6c4405","permalink":"/post/avoid_npe_in_go/","publishdate":"2019-05-16T21:58:24+08:00","relpermalink":"/post/avoid_npe_in_go/","section":"post","summary":"原文地址：https://romatic.net/post/avoid_npe_in_go/ 空指针异常 NPE 在所有编程语言里都是个很麻烦的事情，","tags":["NPE","Go"],"title":"Go 里减少空指针异常的小经验","type":"post"},{"authors":null,"categories":[],"content":"缘起 写代码里有个绕不开的话题就是如何写构造函数\n Java 里有 JavaBean 作为标准，空构造参数 + 自定义的 setter C++ 里靠重载实现任意场景的构造 Python 里可以可以支持传你需要的参数  Go 呢，一无所有，最通行的办法，大概是可变参作为可选的 options\nfunc NewX(options ...Option) *X { x := \u0026amp;X{} for _, opt := range options { opt.apply(x) } return x } 但是，你每次不得不把一个个简单的参数定义成一大堆的 option，多么烦人。\n所以，goption 就出场了\n一睹为快 是不是太快了看不清。听我慢慢道来。\n以 Goland 为示例，首先在定义 struct 时添加标识\n//go:generate goption -p . -c Person -w type Person struct{ // your person fields } 这样的好处是，IDE 可以为你提供快捷按钮，你只需要点一下就生成了。\n点击按钮后，会在同 packagge 下生成 person_option_gen.go 代码大约是这个样子：\ntype PersonOption func(*Person) func NewPerson(opts ...PersonOption) (person *Person) { person = \u0026amp;Person{} for _, opt := range opts { opt(person) } return } func WithPersonName(name string) func(*Person) { return func(person *Person) { person.Name = name } } // ... 如何使用呢，也很简单：\nfunc main() { p1 := NewPerson()\t// 普通构造方式  p2 := NewPerson(\t// 自定义字段方式 \tWithPersonName(`zhangsan`), WithPersonAge(18), ) println(p1, p2) } 使用起来真是爽了不少。\n放上代码地址：https://github.com/micln/goption\n如何实现 最开始绕了点弯路，自己一层层解析 ast.Node，后来发现 go/doc 已经帮你解析了 package，里面有哪些 Types，哪些 Funcs，都非常清楚，可以直接拿来用。\n唯一需要处理的就是如何 ast.Expr 表示的代码展示出来，好在之前玩过 ast 相关的，也整理了一下 astutil 放了出来，后面还会继续完善。所以就大大减少了难度。\n后续 费这么大劲如果只做这一件事确实有点亏，后续希望把 Generator 开放出来，我帮你解析源码和集成 IDE，你只需要自定义模板，就可以生成任何你想要的辅助方法。\n","date":1557767371,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557767371,"objectID":"df21a8ddac8d6525a06153bab788100f","permalink":"/post/goption/","publishdate":"2019-05-14T01:09:31+08:00","relpermalink":"/post/goption/","section":"post","summary":"缘起 写代码里有个绕不开的话题就是如何写构造函数 Java 里有 JavaBean 作为标准，空构造参数 + 自定义的 setter C++ 里靠重载实现任意场景的构造 Python 里可以可以支持传你需要的","tags":["Go"],"title":"Goption：一个针对 Go struct 的代码生成器","type":"post"},{"authors":null,"categories":[],"content":"起因是因为犯懒，随手在一个函数体内定义一个类型\nfunc foo() { type Article = map[string]interface{} } 看起来好像也很正常，突然有一天在 gowatch 的控制台里看到了\nruntime: goroutine stack exceeds 1000000000-byte limit fatal error: stack overflow runtime stack: runtime.throw(0x1a556a1, 0xe) /usr/local/Cellar/go/1.12.5/libexec/src/runtime/panic.go:617 +0x72 runtime.newstack() /usr/local/Cellar/go/1.12.5/libexec/src/runtime/stack.go:1041 +0x6f0 runtime.morestack() /usr/local/Cellar/go/1.12.5/libexec/src/runtime/asm_amd64.s:429 +0x8f ... 以为是程序出 panic 了，不过仔细看了看，好像不是我的代码，仔细一研究，发现程序还没跑起来，go build 时已经 panic 了。然后经过各种 git stash，终于发现，原来是因为外面也定义了一个 type Article struct{} 导致的 panic。\n印象中函数体内和函数外是可以重名的，而且，即便不可以，也应该编译失败才对，怎么就 panic 了。\n于是尝试了一下\n如果同时定义两个重名类型，会提示 redeclared in this block\ntype A struct{} type A = map[string]string // A redeclared in this block 如果分开到两个 block，就编译通过了。\ntype A struct{} func main(){ type A = map[string]string } // build success 奇了个怪。那为什么我的程序会 panic 呢？\n又经过尝试，终于发现，在本包内正常调用是可以的，只有当其他包引用此包时才会 panic。而且，如果把函数体内的 type X = Y 改成 type X Y 也是可以编译通过的。\n总结起来，两个条件：\n 在两个 block 内同时定义 type X 和 type X= 在其他包里引入此包  之后，给 goteam 提了个 issue 来反馈这个诡异的 bug。\n忧伤的地方来了，自己只能发现 bug，完全不具备追查 bug 产生的原因。\n立个 flag 吧，希望有时间可以研究研究编译器相关的一些知识。\n","date":1557765338,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557765338,"objectID":"a65b3c4e30de8941c9d7c25b3e982974","permalink":"/post/a_go_build_panic_bug/","publishdate":"2019-05-14T00:35:38+08:00","relpermalink":"/post/a_go_build_panic_bug/","section":"post","summary":"起因是因为犯懒，随手在一个函数体内定义一个类型 func foo() { type Article = map[string]interface{} } 看起来好像也很正常，突然有一天在 gowatch 的控制台里看到了 runtime: goroutine stack exceeds 1000000000-byte limit fatal error: stack overflow runtime stack: runtime.throw(0x1a556a1, 0xe)","tags":["Go"],"title":"一个会导致 go build panic 的 bug","type":"post"},{"authors":null,"categories":["最佳实践"],"content":" 项目逐渐都切到了 go mod，用的时候遇到了各种奇奇怪怪的坑，记录一下。\n 流程实践 语义化版本 Go mod 在设计时没有支持诸如 \u0026gt;2.0, ~3.4, ^4.0 这样场景的语法。而是以语义化版本的约定来处理：\nx.y.z ≈ ^x.y + \u0026lt;=y.z\n实际中，对于内部频繁升级的 common 包，每次改动都需要 y+=1 才能保证兼容性。为此我专门搞了个小玩意来升级 y，可以通过 hook 在 push 前先 gt ft。\n有个比较恶心的问题，common 包的版本号长期维持在 1.y.0 且 y 很大。暂时没用解决的办法，后面再看看 x 能有什么新玩法。\n不同分支依赖冲突 如图，一个常见的场景，多人开发项目时，有可能在开发过程中使用了不同的依赖包，在合并代码的时候也会冲突。\n以前的办法是有个专门的 vendor 分支，把有关依赖的变动串行化。\n但是用了 gomod 后，如果你只在 vendor 分支 里加了依赖没有用，go mod tidy 时又会把依赖给去掉。\n好在大部分时候都是需要更新而不是新增依赖，这个思路依然可用。我们给项目里专门准备了一个脚本来升级依赖，这个脚本做的事情也比较简单，切换到 vendor 分支，更新，提交。再合回 feature 分支。\n异常问题处理 go replace 替换大小写时不支持同时依赖大小写 P-\u0026gt;A P-\u0026gt;xx-\u0026gt;a\n天真以为把 A replace a 就好了。还是会报同时用了大小写的错。\n只有当所有依赖都依赖 A，但是 github 已经改成 a 时，才能 replace。\n问题最初是由于 github.com/sirupsen/logrus 更换大小写引起，如果项目全用 Sirupsen 是可以 replace 的，后来有了混用就不行了。终极解决办法是干掉 logrus 。。\n 凡是随意修改包路径、函数签名的 Go Libs，基本上都被我列入黑名单了。\n build xx: ambiguous import: xx in multiple modules: 通常是在没有使用语义化版本时，对一个包有不同版本的依赖导致。例如：\nbuild xxx.com/com/projA: cannot load xxx.com/com/projB/model: ambiguous import: found xxx.com/com/projB/model in multiple modules: xxx.com/com/projB v0.0.0-20181119101949-92ae1f75b49a (.../pkg/mod/xxx.com/com/projB@v0.0.0-20181119101949-92ae1f75b49a/model) xxx.com/com/projB/model v0.0.0-20190311082816-bfb94e79a84f (.../pkg/mod/xxx.com/com/projB/model@v0.0.0-20190311082816-bfb94e79a84f) 可以通过下面方式来找\nfd go.mod | xargs grep -r projB vendor/xxx.com/com/base/go.mod:\txxx.com/com/projB/registry v0.0.0-20190312132550-a101ae8810b6 // indirect vendor/xxx.com/com/artemis/go.mod:\txxx.com/com/projB/app/goprojB v0.0.0-20190312132550-a101ae8810b6 vendor/xxx.com/com/projB/registry/go.mod:module xxx.com/com/projB/registry go replace 不能替换依赖包的依赖 我的项目P -\u0026gt; A\u0026amp;B，且 B-\u0026gt;A\n如果把 A replace 成 A‘，只能修改 P-\u0026gt;A 的依赖， B-\u0026gt;A 是改不了的。\n所以 replace 不能解决梯子的问题，要用 goproxy\ngo get: error loading module requirements go clean -modcache  清理 modcache 几乎是各种问题的终极大杀器，但是成本也很高，需要你下次重拉所有 mod。如果公司内有 proxy 做 cache 的话会好一些。\n","date":1555212027,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1555212027,"objectID":"21d372529fb9c0ff684ebc8680679fef","permalink":"/post/gomod/","publishdate":"2019-04-14T11:20:27+08:00","relpermalink":"/post/gomod/","section":"post","summary":"项目逐渐都切到了 go mod，用的时候遇到了各种奇奇怪怪的坑，记录一下。 流程实践 语义化版本 Go mod 在设计时没有支持诸如 \u0026gt;2.0, ~3.4, ^4.0 这样场景的语法。而是以语","tags":["go","gomod"],"title":"Go Module 实践中的问题（持续更新）","type":"post"},{"authors":null,"categories":null,"content":"abc\naaa\n","date":1554997151,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1554997151,"objectID":"a6f52b0e5c0ef5dfb93386f030f66472","permalink":"/project/gt/","publishdate":"2019-04-11T23:39:11+08:00","relpermalink":"/project/gt/","section":"project","summary":"abc\naaa","tags":["tool"],"title":"gt","type":"project"},{"authors":null,"categories":["简书","随笔"],"content":" 迁移自简书，格式可能未经校对。\n 事件经过：  收到反馈测试环境某个服务打开 swagger ，进程会卡死 根据经验，初步判定是有死循环。 在本地启动该服务，打开 swagger ，发现 CPU 单核100%，确认有死循环 pprof 抓取 cpu profile  在 marshal 前后打断点，对于特定链接，marshal 没结束(没看到 done 日志) 更换为官方 json 库，恢复正常。确认是 json-iterator 导致  在其他项目做同样操作，未能复现问题。对比jsoniter 版本，初步判定是版本过老导致。 通过 debug，确认是下面这个循环走不出来 升级 jsoniter ，恢复正常  到官方一看，这个bug 很早就解决了。但是出事的服务还在依赖 2017-8-9 的版本。（修复链接：https://github.com/json-iterator/go/commit/f7063353029dd177a959dbf6b29f48746441fbfa#diff-34ab17b5ece86461ae47905134a8d94c）  第二个问题，为什么整个程序会假死 按理说，for{} 会造成单个协程停不下，CPU 单核打满都好理解，但为什么会让整个进程死掉？\n原因在于 GC标记前，需要通知所有 goroutine 停下来，但是问题协程一直停不下来，而正常协程都已经停下来在等待。所以对外无法正常服务，看起就是死掉了。\n暴露的问题  对 Go 底层完全 hold 不住 第三方依赖管理不规范  参考链接  历史四年的关于for{}的抢占式讨论 https://github.com/golang/go/issues/10958 Goroutine调度实例简要分析 https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/ 滴滴大佬如何定位 golang 进程 hang 死的 bug https://gocn.vip/article/441  ","date":1553444565,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1553444565,"objectID":"2e054d5bf54a9a8e788af5455bf261ab","permalink":"/post/jianshu/json-iterator-%E5%9C%A8-swagger-%E4%B8%8B%E5%8D%A1%E6%AD%BB%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%92%E6%9F%A5/","publishdate":"2019-03-25T00:22:45+08:00","relpermalink":"/post/jianshu/json-iterator-%E5%9C%A8-swagger-%E4%B8%8B%E5%8D%A1%E6%AD%BB%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%92%E6%9F%A5/","section":"post","summary":"迁移自简书，格式可能未经校对。 事件经过： 收到反馈测试环境某个服务打开 swagger ，进程会卡死 根据经验，初步判定是有死循环。 在本地启动该服务，打开 swagger ，发","tags":["Json","Iterator","swagger","Go"],"title":"Json Iterator 在 swagger 下卡死程序的排查","type":"post"},{"authors":null,"categories":["简书","随笔"],"content":"[TOC]\n 背景\n最近想写一些简单的非技术文章，希望能给其他行业的说明白计算机所能和所不能，方便大家用好计算机这个工具。\n 为什么数据都有了，但是不让我查询和统计？ 思考：\n 如果计算机记录了每个用户读了哪本书，那么是不是也很容易知道一本书被哪些用户读过？\n 你可能会觉得理所当然。\n但是，答案其实是 No。关键在于索引，什么是索引呢，举个例子：\n 如果我要在字典里取找“李”这个字，常见的办法是在字典目录里先找“木”字头的所有字，假如找出100个，再到这些字里找到“李”。\n反过来，我能不能先找“子”为底的所有字，再从中找“李”呢？\n 想法是好的，但现实是，没有哪本字典能提供这样的功能。\n之所以我们能先找“木”字头而不能先找“子”字底，是因为字典帮我们提供了一份“木”字头的目录而没有提供后者的目录。\n这个目录，在计算机里就称作“索引”（Index）。\n我们一般会说，字典为“木”字头建立了索引，但是没有为“子”字底建立索引。如果我们也为“子”建立一份索引，就可以反过来查到“李”字了。顺便，我们也可以在索引里面直接数出“子”字底的字有多少个。\n回到思考题，我们知道用户读过的书，但却不能统计一本书的阅读用户。你就大概猜到了，记录每个用户读了哪些书，潜台词就是我在“用户”维度建立了索引，但是却不一定也给“书”的维度建立了索引。\n再举个例子加深你的理解\n 如果你在大街上随便问一个人读过哪些书，他可以很快答出来。\n但是，如果要问你大街上有哪些人读过某一本书，你可能就需要大费周折了。\n 这是因为，当一本书被一个人读了之后。虽然是“书”和“人”这两个主体发生了关联。但是，只有人的脑子里记录了这个关联，书店并不会记录这本书被某人读了。人脑记住的这份关联，就是索引。\n","date":1553326653,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1553326653,"objectID":"d85f2d2f6de69a9779b8f9df180e527a","permalink":"/post/jianshu/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%8D%E7%9B%B4%E8%A7%89%E7%8E%B0%E8%B1%A1/","publishdate":"2019-03-23T15:37:33+08:00","relpermalink":"/post/jianshu/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%8D%E7%9B%B4%E8%A7%89%E7%8E%B0%E8%B1%A1/","section":"post","summary":"[TOC] 背景 最近想写一些简单的非技术文章，希望能给其他行业的说明白计算机所能和所不能，方便大家用好计算机这个工具。 为什么数据都有了，但是不让我查询","tags":[],"title":"关于计算机的一些反直觉现象","type":"post"},{"authors":null,"categories":["简书","随笔"],"content":"以前在引入第三包的时候，为了兼容性和定制扩展的考虑，一般会浅浅地封装一层。自从入了 Go 坑，发现连标准库也得小心再小心了。\ndecode(map) 之后 int 会变成 float64 思考一下，把一个 map encode 之后再 decode，结果和原来的 map 是否相等？直觉上肯定是对的，然而\u0026hellip;\n看一段代码（https://play.golang.org/p/DHb-kZNHidd）：\nm := make(map[int]interface{}) m1 := make(map[int]interface{}) m[2] = 3 b, _ := json.Marshal(m) json.Unmarshal(b, \u0026amp;m1) fmt.Println(m)\t// map[2:3] fmt.Println(m1)\t// map[2:3] fmt.Println(reflect.DeepEqual(m, m1))\t// false 看起来是不是很诡异，打印出来的都一模一样，然而两个却不相等。是不是 DeepEqual 里藏着什么猫腻？按照代码注释， 只要每个元素都相等，整个 map 就相等。\n难不成这个2和3有问题？我们再打印一下看看：\nfmt.Printf(\u0026#34;%T %T\u0026#34;, m[2], m1[2]) // int float64 这个时候发现，decode 出来的数字被悄悄地变成了 float64。后来发现，其实官方也早有说明。只是这种不起眼的功能平时没注意。\n如果上面例子里改成 m[2] = 3.0，结果就正常了。参见：https://play.golang.org/p/vAC1BXc7nCO\nencoding 时自动追加 \u0026lsquo;\\n\u0026rsquo; 跑 Unit Testing 时遇到的。在 github 上看到有人问到过这个问题，官方给的理由是看起来舒服。不得不说，Go Team 在写 std 时真是太随意了。\n暂时没想到特别好的解决方案，在自己的工具类 JsonEncode 里手动给去掉了。因为一般使用的 json 末尾都是 } ]。后面或许会加个全局的开关来配置？\n默认情况下会开启 escapeHTML 严格来说不能算坑，但确实跟我之前的习惯不太一样。而且要关闭的时候，还不能直接设置，得绕个大弯：\nbuffer := \u0026amp;bytes.Buffer{} encoder := json.NewEncoder(buffer) encoder.SetEscapeHTML(false) // 到这才算 init 完成  encoder.Encode(...) 现在很多人使用 Go 只是提供一个简单的 json 给客户端，html 字符，其实不太会搞出什么麻烦，有时候也就懒得处理了。\n不能处理递归指针（会死循环） 如果对象的属性是指向自己的指针（例如循环列表），marshal 时会陷入死循环。在 dump 复杂对象时需要注意。\nprintln 函数没有这个问题，因为会把指针直接打印出地址。\n最后 建议大家使用的自己也能稍微封装一下，至少在各种特殊场景下能自己掌控住。尤其 Go 很多官方包不像 Java 那样接口先行，而且 Go 还不支持继承，以至于在项目大了后想替换个 struct 非常痛苦。\n另外我自己也在尝试对这些问题做一些整理，欢迎加入。\n","date":1535372915,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1535372915,"objectID":"9eacb31828ae63dc0c89e9182bd5a2ce","permalink":"/post/jianshu/go-encoding-json-%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91/","publishdate":"2018-08-27T20:28:35+08:00","relpermalink":"/post/jianshu/go-encoding-json-%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91/","section":"post","summary":"以前在引入第三包的时候，为了兼容性和定制扩展的考虑，一般会浅浅地封装一层。自从入了 Go 坑，发现连标准库也得小心再小心了。 decode(map) 之后 int 会变成 float64 思考一","tags":["Go","encoding","json"],"title":"Go encoding json 的几个坑","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" 迁移自简书，格式可能未经校对。\n 越来越多的应用里需要依赖大量的对外请求（内部服务或第三方平台）。但是很多的 client 只有基本的请求，这在复杂的场景里根本无法应对各种问题，所以我试图整理一下之前遇到的坑，也是封装一个 httpClient 所需要支持的地方。\n重试策略：\n  立即重试\n  延时重试\n 动态延时，1s 2s 4s 8s \u0026hellip;    频率限制\n  全局 Pool\n  针对同一服务下，排队\n  配置级别：\n  全局\n  服务级\n  调用方\n  服务方\n    Request\n  日志记什么：\n  请求耗时\n  请求信息\n  url = host + path\n  args = header + query + form\n    请求结果\n  response header 一定得记\n  如果结果是简单数据，比如 json，就全记下\n  如果对方接口挂了，返回了 nginx 错误HTML，比如5xx，要记录\n  如果是文本文件流，可以记录关键部分；如果是二进制，至少记下 md5 + size\n    TraceId（参考 https://www.jianshu.com/p/73346f667f3d)\n  ","date":1535286146,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1535286146,"objectID":"ca8880b2be732a5666e93ad6fa97d40d","permalink":"/post/jianshu/httpclient-%E7%9A%84%E5%87%A0%E4%B8%AA%E7%82%B9/","publishdate":"2018-08-26T20:22:26+08:00","relpermalink":"/post/jianshu/httpclient-%E7%9A%84%E5%87%A0%E4%B8%AA%E7%82%B9/","section":"post","summary":"迁移自简书，格式可能未经校对。 越来越多的应用里需要依赖大量的对外请求（内部服务或第三方平台）。但是很多的 client 只有基本的请求，这在复杂的场景里根","tags":["HttpClient"],"title":"HttpClient 的几个点","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" 迁移自简书，格式可能未经校对。\n 场景还原 先说个场景：\nAPP上某个操作出现了 系统异常。错误码：abc012，我们收到错误码之后，可以一次性查出这条请求完整的请求路径，穿越了哪几个服务，出错的代码堆栈信息，甚至中间发生了哪些 SQL 查询。这样我们基本在脑子里复现整个场景了。\n其中涉及的几个地方：\n  错误码：很多时候并不能得到这个错误截图，我们可以用户反馈的时间、用户ID、功能大致定位到。错误码放在全局的 response header 里\n  请求轨迹：在请求来的时候加个 traceId，这个 traceId 注入到后面的 logger 和 client，这样所有的log就都能识别了。\n  堆栈信息：像 Php Java 可以很方便的在出现 ERROR 时把堆栈信息跑出去（Php还能记录每个函数的调用参数）。我们用 Go 比较麻烦一些，要专门加个记录 stack 的 error 类型。\n  SQL日志：这个看需要了，如果你的 ORM 框架对钩子支持好，加起来也不是难事。\n  日志框架 功能上，个人觉得有个强大的 Hook 就够了。这样每个团队都可以根据自己需要来加自己需要的东西\n  Hook\n  继承 context\n  必要时候输出代码位置信息\n    Keyword\n  Extra Map\n  输出和存储   格式：支持不同环境下不同的格式，比如dev模式，关键字就挺好。线上可能需要以json格式打到相关的日志服务里。\n  分卷存储：有的框架会按照日期来分文件，个人觉得没必要，可以用 logrotate 这样专业的工具来做。还有一种思路，用 rsyslog 把日志导出到你的日志服务里去，本机的日志，不用存多少就可以删掉了。\n  监控报警   如果性能没那么苛刻，推荐直接集成 Sentry\n  如果团队实力比较强，可以根据日志做各种分析和监控，参考 open-falcon\n  参考  优秀日志实践准则  ","date":1535202165,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1535202165,"objectID":"3a405deb7efba0b441221eadb28cc21c","permalink":"/post/jianshu/%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97%E7%9A%84%E5%87%A0%E4%B8%AA%E6%83%B3%E6%B3%95/","publishdate":"2018-08-25T21:02:45+08:00","relpermalink":"/post/jianshu/%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97%E7%9A%84%E5%87%A0%E4%B8%AA%E6%83%B3%E6%B3%95/","section":"post","summary":"迁移自简书，格式可能未经校对。 场景还原 先说个场景： APP上某个操作出现了 系统异常。错误码：abc012，我们收到错误码之后，可以一次性查出这","tags":[],"title":"关于日志的几个想法","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" 迁移自简书，格式可能未经校对。\n Github：https://github.com/Kretech/xgo\n缘起是因为 Go 的很多语法太啰嗦，也许 Go 官方为了通用性牺牲了简洁，而我们日常更青睐于 约定优于配置，所以我们需要对我们的80%情况做一些优化。\n整理了哪些东西：\n  常见的 utils 库\n 类似于随机数 rand(100)、转下划线 word.UnderlineCase('HelloWorld')等等    基础数据结构\n 科班都学过的链表、树、图以及这些数据结构上的基本算法    略复杂的数据结构\n Array + Dict 类似于 Php 里的 array。在性能不那么要命的地方用起来很爽 Redis 基本数据结构：跳跃表    ","date":1534526775,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1534526775,"objectID":"e6b65dc4e95e8c55c9280c89945a19ee","permalink":"/post/jianshu/%E6%95%B4%E7%90%86%E4%B8%80%E5%A5%97-go-%E7%9A%84%E8%BD%AE%E5%AD%90/","publishdate":"2018-08-18T01:26:15+08:00","relpermalink":"/post/jianshu/%E6%95%B4%E7%90%86%E4%B8%80%E5%A5%97-go-%E7%9A%84%E8%BD%AE%E5%AD%90/","section":"post","summary":"迁移自简书，格式可能未经校对。 Github：https://github.com/Kretech/xgo 缘起是因为 Go 的很多语法太啰嗦，也许 Go","tags":["Go"],"title":"整理一套 Go 的轮子","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" 迁移自简书，格式可能未经校对。\n 这里只会记录在学习 Redis 源码时觉得比较好玩的地方，不会一五一十的讲细节。\n内存分配 zmalloc 在实际 malloc 到的内存前面加一个 size 。\nvoid *zmalloc(size_t size) { void *ptr = malloc(size+PREFIX_SIZE); *((size_t*)ptr) = size; update_zmalloc_stat_alloc(size+PREFIX_SIZE); return (char*)ptr+PREFIX_SIZE; } 动态字符串 sds sds 在基础的 char* 前面加一段 header 来记录信息（类似于 Go 实现）。\n// 除了 sdshdr64，还有 sdshdr32、sdshdr16... 区分不同的长度上限 struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; sds sdsnewlen(const void *init, size_t initlen) { ... sh = s_malloc(hdrlen+initlen+1); s = (char*)sh+hdrlen;\t// 实际字符串  memcpy(s, init, initlen); return s; } 字典 dict   基本数据结构\n dictEntry：键值对。（冲突处理：开链） dictht：哈希表。记录使用情况用来 rehash dict typedef struct dict { dictType *type;\t// 不同type有不同的hash算法  void *privdata; dictht ht[2];\t// 两个 ht 来实现渐进式的 rehash  long rehashidx; /* rehashing not in progress if rehashidx == -1 */ unsigned long iterators; /* number of iterators currently running */ } dict;     哈希算法\n  rehash：冲突元素太多时扩容。通过两个哈希表进行\n 渐进式策略：  每次执行操作时转移一个 定时每次转移100个      数据操作\n 每次操作前尽可能进行一次 rehash。 rehash 时，要依次在两个表里查询；其他操作类似。    跳跃表 zset  数据结构  span    整数集合 intset  数据结构  encoding 记录元素大小，对于小的数字，使用 int16_t 来节省内存。   resize  先分配足够内存，再调用 memmove 函数进行搬移 单向升级，只有在插入元素的时候，如果 encoding 过小时会进行    鸣谢  Redis源码剖析  ","date":1533402967,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1533402967,"objectID":"284998423a012dba36e3936c2a713a82","permalink":"/post/jianshu/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","publishdate":"2018-08-05T01:16:07+08:00","relpermalink":"/post/jianshu/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","section":"post","summary":"迁移自简书，格式可能未经校对。 这里只会记录在学习 Redis 源码时觉得比较好玩的地方，不会一五一十的讲细节。 内存分配 zmalloc 在实际 malloc 到的内存前面加一个 size 。 void","tags":["Redis"],"title":"Redis 学习笔记","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" 迁移自简书，格式可能未经校对。\n 用 Laravel 很久了，whereHas 简直是连表大杀器，本来需要写大量 SQL 的查询用 whereHas 都可以很快的实现。不过在一些场景里，遇到了严重的性能问题。\n我们有个A表，大约是百万级数据，与之关联的有个B表，大约万级数据。在做关联查询的时候我们自然使用 A::whereHas('b', function(){...}) 。\n后来发现了许多慢查询，仔细一看发现，Laravel 的 whereHas 在生成 SQL 的时候会使用  select * from A where exists ( select * from b where ... ) 。当我们的左表远远大于右表时，A 表就成了性能瓶颈。\n最直接的方法当然是拆成两条 SQL，但是嫌麻烦，还得一条条优化。再加上我们很多 SQL 都是靠各种工具生成，所以改起来也挺麻烦。\n于是就考虑加了个 whereHasIn 的方法，接口参数跟 whereHas 一致，只不过在生成 SQL 的时候会生成 select * from A where A.id in (select id from B)。这样就不需要改什么 SQL 了，只要在调用 A::whereHas() 的地方加两个字符变成 A::whereHasIn() 就搞定了。在实际中，我们这条查询的耗时从几秒一下降低到了20毫秒。\n下面是一个实现的 demo，暂时只支持 一对多的情况。如果大家有什么更好的想法，一起讨论讨论。\n\u0026lt;?php use Illuminate\\Database\\Eloquent\\Relations; abstract class AbstractModel { /** * whereHas 的 where in 实现 * * @param \\Illuminate\\Database\\Eloquent\\Builder $builder * @param string $relationName * @param callable $callable * @return Builder * * @throws Exception */ public function scopeWhereHasIn($builder, $relationName, callable $callable) { $relationNames = explode(\u0026#39;.\u0026#39;, $relationName); $nextRelation = implode(\u0026#39;.\u0026#39;, array_slice($relationNames, 1)); $method = $relationNames[0]; /** @var Relations\\BelongsTo|Relations\\HasOne $relation */ $relation = Relations\\Relation::noConstraints(function () use ($method) { return $this-\u0026gt;$method(); }); /** @var Builder $in */ $in = $relation-\u0026gt;getQuery()-\u0026gt;whereHasIn($nextRelation, $callable); if ($relation instanceof Relations\\BelongsTo) { return $builder-\u0026gt;whereIn($relation-\u0026gt;getForeignKey(), $in-\u0026gt;select($relation-\u0026gt;getOwnerKey())); } elseif ($relation instanceof Relations\\HasOne) { return $builder-\u0026gt;whereIn($this-\u0026gt;getKeyName(), $in-\u0026gt;select($relation-\u0026gt;getForeignKeyName())); } throw new Exception(__METHOD__ . \u0026#34; 不支持 \u0026#34; . get_class($relation)); } } ","date":1530018441,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1530018441,"objectID":"55d5121dc7a5495dec45bbfe7269a8b8","permalink":"/post/jianshu/laravel-eloquent-wherehas-%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BC%98%E5%8C%96/","publishdate":"2018-06-26T21:07:21+08:00","relpermalink":"/post/jianshu/laravel-eloquent-wherehas-%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BC%98%E5%8C%96/","section":"post","summary":"迁移自简书，格式可能未经校对。 用 Laravel 很久了，whereHas 简直是连表大杀器，本来需要写大量 SQL 的查询用 whereHas 都可以很快的实现。不过在一些场景里，遇","tags":["Laravel","Eloquent","whereHas"],"title":"Laravel Eloquent whereHas 的一个优化","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" 迁移自简书，格式可能未经校对。\n 最近看到了几种加缓存的方法，整理对比一下。\n拿一个case来说，我们要去数据库取一条用户记录，迫于性能，还要加一层缓存。我们针对这个问题看看几种使用姿势的对比。\nLaravel 中 Facades 做法\n$person = Cache::remember(\u0026quot;person.{$id}\u0026quot;, 5, function () use ($id) { return PersonDao::find($id); });  Spring Cache 的做法\n@Cache(key = \u0026quot;person#id\u0026quot;, ttl = 5) public Person getPerson(Integer id) { return PersonDao.find(id); } Person person = repository.getPerson();  备注：\n PersonDao.find 表示从DB里去拿数据  这两种方法看起来都很简单，除了必要的语法格式，你需要写的代码就是：\n cache 函数或标记，表明需要缓存 key 不解释 ttl 不解释 func… 回源数据  基本上可以说是要啥写啥了，不啰嗦。\n其实 Php 和 Java 的语法很接近，两种方法在两种语言里都适用。不过 Php 需要第三方的注解支持；Java 需要 8 以上来支持 lambda。\n简单的东西一定面临扩展性的问题，我们来看一看他们的可能性。\n如果我们要更换缓存驱动怎么办？\nLaravel\nCache::store('redis')-\u0026gt;remember(...)  Spring\n@Cache(driver = redisCache.class)  依然很简单。\n有些时候，在使用 redis 作为缓存的时候，我们会用不同的编码\nLaravel\nCache::store('redis')-\u0026gt;encoding('json')-\u0026gt;remember(...)  Spring\n@Cache(encoding = JsonEncoding.class)  方法其实是相似的，一般的，Lavavel 利用自己习惯的链式操作和 Php 的不定参数，可以让你随时传入自己个性化的需求。Spring 也利用 Annotation 来实现类似的效果。\n更多的，Laravel 和 Spring Boot 都遵循了约定优于配置的原则，使得在大多数情况下，你都不需要传这些，只需要使用全局的默认配置就能满足需求。也就是上面的最方便的办法。\n简单的方法介绍完了，我们来聊聊 Go 里的做法\n刚刚接手一个 Go 项目，里面看到是这样处理缓存的：\nproxy := Proxy{ Prefered: RedisAdapter{ RedisClient }, Backup: DaoAdapter{ PersonDao } } person := proxy.Get('xxx').(Person)  是不是一下看懵逼了，我也是，这还是简化的版本。真正实现一个这样的功能，大约新增了三个实现了数个空接口新类和几个方法。\n更蛋疼的，这三个类都是类型相关的，换句话说，list/detail 两种功能各自都需要3个类，换个 model 也不能复用。更悲催的，因为 IDE 对 Go 的 interface 分析都不太好，当你阅读别人的代码的时候，你完全不知道哪里是哪里。\n所以，这里想尝试一下，能否在 Go 里使用上面的简单方法处理缓存。\nid := 9 person := remember(\u0026quot;key\u0026quot;, 30 * time.Second, func() interface{} { return PersonDao.find(id) }).(*Person) // 或者更 Go 一点 var person Person remember(\u0026amp;person, \u0026quot;key\u0026quot;, 30 * time.Second, func(iface interface{}) { *iface.(*Person) = *PersonDao.find(id) })  比较烦的是，Go 不支持泛型，定义函数的时候要尽可能少依赖类型。常用的办法是把类型传入。\n前者看起来简单，但有个很要命的地方，你需要很严格的把 Person 类进行序列化。否则从 cache 里取出来后类型可能会丢，导致断言失败。\n那么，第二种办法可以吗？或者说，在 Go 里能不能通过简单标记的办法来实现多态？\n我只能说，不好弄。\nSpring 里很多注解效果，都是靠动态代理实现的（相当于 Php 里阉割版的 __call )。但遗憾的是，Go 目前不能支持这一特性。如果要硬上的话，也可以，搞出来可能跟我接的代码挺像的。\n","date":1529067814,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1529067814,"objectID":"4b10750e96178f96713e67bea6bfb428","permalink":"/post/jianshu/%E6%80%8E%E6%A0%B7%E5%BF%AB%E9%80%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98-cache/","publishdate":"2018-06-15T21:03:34+08:00","relpermalink":"/post/jianshu/%E6%80%8E%E6%A0%B7%E5%BF%AB%E9%80%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98-cache/","section":"post","summary":"迁移自简书，格式可能未经校对。 最近看到了几种加缓存的方法，整理对比一下。 拿一个case来说，我们要去数据库取一条用户记录，迫于性能，还要加一","tags":["Cache","Laravel","Go","Java","Spring"],"title":"好用的 Cache API","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" 迁移自简书，格式可能未经校对。\n 入门  官方文档 英文 中文  深入理解  《From Apprentice To Artisan》 讲Laravel内部设计的小册子，能帮你了解laravel的整体实现 《详解Laravel源码》 分模块去介绍源码  开发相关  Laravel Plugin for PhpStorm Laravel ide-helper for PhpStorm 识别各种魔术方法，包括 Facedes 和 Eloquent 等。最好先了解 PhpDoc  社区  Laravel China  ","date":1521598915,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1521598915,"objectID":"2c694ff18623f81dcf0e51b32f155334","permalink":"/post/jianshu/laravel-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","publishdate":"2018-03-21T10:21:55+08:00","relpermalink":"/post/jianshu/laravel-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","section":"post","summary":"迁移自简书，格式可能未经校对。 入门 官方文档 英文 中文 深入理解 《From Apprentice To Artisan》 讲Laravel内部设计的小册子，能帮你了解lara","tags":["Laravel"],"title":"Laravel 学习路线","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" 迁移自简书，格式可能未经校对。\n 还会更新，只是懒得整理，先堆这里了\nPlatUML 代码：\n@startuml \u0026#39; 底层驱动部分 class DatabaseManager{ connection() factory的大脑 } class ConnectionFactory{ newConnection() } interface Connection { defaultBuilder defaultGrammar defaultProcesser run() // 真正到DB里跑SQL的 } interface Connector { connect() } package Query|Schema { interface Grammar interface Processer note right of Processer: 对数据库返回值的二次拼装 class QueryBuilder { IConnection IGrammar IProcesser paginate() } } DatabaseManager *--\u0026gt; ConnectionFactory DatabaseManager *--\u0026gt; Connection DatabaseManager *--\u0026gt; Connector ConnectionFactory *--\u0026gt; Connection ConnectionFactory *--\u0026gt; Connector Connection --|\u0026gt; Grammar Connection --|\u0026gt; Processer QueryBuilder --|\u0026gt; Grammar QueryBuilder --|\u0026gt; Processer Connection -- QueryBuilder \u0026#39; Eloquent package Eloquent{ abstract class Relation{ Ebuilder constraints } class EBuilder{ model scopes earerLoad macro first() has() } class model{ scopes events __call() serialize() } } @enduml ","date":1520047425,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1520047425,"objectID":"986f66489a4209df7fab9b98fe664210","permalink":"/post/jianshu/laravel-orm-%E6%A8%A1%E5%9D%97%E5%9B%BE/","publishdate":"2018-03-03T11:23:45+08:00","relpermalink":"/post/jianshu/laravel-orm-%E6%A8%A1%E5%9D%97%E5%9B%BE/","section":"post","summary":"迁移自简书，格式可能未经校对。 还会更新，只是懒得整理，先堆这里了 PlatUML 代码： @startuml \u0026#39; 底层驱动部分 class DatabaseManager{ connection() factory的大脑 } class ConnectionFactory{ newConnection() } interface Connection { defaultBuilder defaultGrammar defaultProcesser run() //","tags":["Laravel","ORM"],"title":"Laravel ORM 模块图","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" ORM 于创业项目快速迭代的重要性不言而喻。我也一直在不停地寻找更好的方案。\n 造了个轮子：Loulan-java\n市面上有些不错的 orm 框架，诸如 Laravel、Ror、Gorm。\n参考这些整理并增加了下面的特征：\n OR Mapping 约定及自定义的mapping规则，书写简单，不能每个字段都写一堆标记 Scalable 只需简单配置，支持各个级别的分库分表分读写 Hook / Plugin 支持各个级别的hook，支持自定义插件/中间件 Functional QueryBuilder 良好的细节屏蔽，需要语法简约，支持复用，可扩展，容易支持缓存 Pagination 简单的分页接口支持 Relations Eager Loading 预加载 Collections 兼容链式操作的集合框架 Mutators / Casting Full SQL 诸如事务、联表、简单计算等  ","date":1516074342,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1516074342,"objectID":"9b71a097efcf6a349d85545c65e9143b","permalink":"/post/jianshu/%E7%90%86%E6%83%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E5%BA%93/","publishdate":"2018-01-16T11:45:42+08:00","relpermalink":"/post/jianshu/%E7%90%86%E6%83%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E5%BA%93/","section":"post","summary":"ORM 于创业项目快速迭代的重要性不言而喻。我也一直在不停地寻找更好的方案。 造了个轮子：Loulan-java 市面上有些不错的 orm 框架，诸如 Lara","tags":["Laravel","Loulan","Go","ORM"],"title":"理想的数据库操作库","type":"post"},{"authors":null,"categories":["简书","Snippets"],"content":" 迁移自简书，格式可能未经校对。\n 缘由：网上google出来的东西要么排版太丑要么啥都没有\n安装 apt install vsftpd  限制目录 ftp 在 /etc/vsftpd.conf 里有个 local_root=/home/sftp_root。测试发现， 只对不加密的ftp有效。\nsftp 要限制sftp的权限，都要通过限制ssh访问的方式。大概方法是：\n 建立一个用来限制目录的组 sftp-users\n  建立一个专门用来登陆sftp的用户 sftpu1，并加入到上面的组里\n  在sshd里限制这个组的访问空间\n  建用户组\n groupadd sftp-users    建用户并加到组里\n useradd -g sftp-users -s /bin/false sftp    限制该组的活动空间\n  在 /etc/ssh/sshd_config 里追加以下内容\nMatch Group sftpuser ChrootDirectory /home/sftp_root ForceCommand internal-sftp AllowTcpForwarding no X11Forwarding no 改完之后记得让ssh重读配置\nsudo service sshd reload  但是，这样基本上要求你的ssh用户和sftp用户没法是同一个人了\n","date":1496591700,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1496591700,"objectID":"6ce0f2ca11735edc9e6009eb1cf35276","permalink":"/post/jianshu/sftp-%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/","publishdate":"2017-06-04T23:55:00+08:00","relpermalink":"/post/jianshu/sftp-%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/","section":"post","summary":"迁移自简书，格式可能未经校对。 缘由：网上google出来的东西要么排版太丑要么啥都没有 安装 apt install vsftpd 限制目录 ftp 在 /etc/vsftpd.conf 里有个 local_root=/","tags":["sftp"],"title":"sftp 配置笔记整理","type":"post"},{"authors":null,"categories":["简书","Snippets"],"content":" 迁移自简书，格式可能未经校对。\n 下载 \u0026amp; 安装 使用 Visio Studio 2012 开发时，要选 SQL Server Data Tools\n但是！！它其实装的是2010版！！所以装好后只能从 vs2010 里建 IS 项目\n如果要从 vs2012 里建，还需要安装东西。参考 http://blog.csdn.net/CodeRookieGuo/article/details/50471123\n无法读取表或视图 原因不明，暂时用了 select，先解决问题，明天再说\nSQL Server 密码不对 登陆的时候专门选了混合登陆，但是一直提示登不上，改了密码依旧如此，怀疑是缺少证书。\n暂时换了 windows 身份验证连上。\n未完待续，毕竟坑无限。\n","date":1482609970,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1482609970,"objectID":"ba18e0a49fb27badd47cc8f0c54b4b93","permalink":"/post/jianshu/ssis-%E7%AC%94%E8%AE%B0/","publishdate":"2016-12-25T04:06:10+08:00","relpermalink":"/post/jianshu/ssis-%E7%AC%94%E8%AE%B0/","section":"post","summary":"迁移自简书，格式可能未经校对。 下载 \u0026amp; 安装 使用 Visio Studio 2012 开发时，要选 SQL Server Data Tools 但是！！它其实装的是2010版！！所以装好后只能从 vs2010 里建 IS 项目 如果要从","tags":["SSIS"],"title":"SSIS 笔记","type":"post"},{"authors":null,"categories":["简书","Snippets"],"content":" 迁移自简书，格式可能未经校对。\n !/bin/sh # homebrew /usr/bin/ruby -e \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026#34; # iTerm2 brew install Caskroom/cask/iterm2 # zsh zsh # .oh-my-zsh sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026#34; # macdown brew install Caskroom/cask/macdown PhpStorm Dash macdown ","date":1482116591,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1482116591,"objectID":"fab49d4987328aca852e03bcb2424857","permalink":"/post/jianshu/mac-%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","publishdate":"2016-12-19T11:03:11+08:00","relpermalink":"/post/jianshu/mac-%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","section":"post","summary":"迁移自简书，格式可能未经校对。 !/bin/sh # homebrew /usr/bin/ruby -e \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026#34; # iTerm2 brew install Caskroom/cask/iterm2 # zsh zsh # .oh-my-zsh sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026#34; # macdown brew install Caskroom/cask/macdown PhpStorm Dash macdown","tags":["Mac"],"title":"Mac 基本开发环境","type":"post"},{"authors":null,"categories":["简书","Snippets"],"content":" 迁移自简书，格式可能未经校对。\n 推荐 https://github.com/fatedier/frp 比 ngrok 好用很多  看文档太复杂了，脑子又记不住，先贴这了。\n需要的时候改一下DOMAIN 直接跑\n参考自：https://aotu.io/notes/2016/02/19/ngrok/\nInstall #!/bin/sh  DOMAIN=your-domain.com cd $GOPATH/src git clone https://github.com/inconshreveable/ngrok.git cd ngrok # 生成 key openssl genrsa -out rootCA.key 2048 openssl req -x509 -new -nodes -key rootCA.key -subj \u0026#34;/CN=${DOMAIN}\u0026#34; -days 5000 -out rootCA.pem openssl genrsa -out device.key 2048 openssl req -new -key device.key -subj \u0026#34;/CN=${DOMAIN}\u0026#34; -out device.csr openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000 cp rootCA.pem assets/client/tls/ngrokroot.crt cp device.crt assets/server/tls/snakeoil.crt cp device.key assets/server/tls/snakeoil.key make release-server make release-client Run Server bin/ngrokd -domain=\u0026quot;${DOMAIN}\u0026quot; -httpAddr=\u0026quot;:10080\u0026quot; -httpsAddr=\u0026quot;:10443\u0026quot;  Client cd bin echo \u0026#39;server_addr: \u0026#34;\u0026#39;${DOMAIN}\u0026#39;:4443\u0026#34;\u0026#39; \u0026gt; ngrok.cfg echo \u0026#39;trust_host_root_certs: false\u0026#39; \u0026gt;\u0026gt; ngrok.cfg ./ngrok -subdomain demo -config=ngrok.cfg 8080 ","date":1481299893,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1481299893,"objectID":"19143fc86be7691e3edc92f4a7a16bfa","permalink":"/post/jianshu/ngrok-%E6%90%AD%E5%BB%BA%E8%84%9A%E6%9C%AC/","publishdate":"2016-12-10T00:11:33+08:00","relpermalink":"/post/jianshu/ngrok-%E6%90%AD%E5%BB%BA%E8%84%9A%E6%9C%AC/","section":"post","summary":"迁移自简书，格式可能未经校对。 推荐 https://github.com/fatedier/frp 比 ngrok 好用很多 看文档太复杂了，脑子又记不住，先贴这了。 需要的时候改一下DOMAIN 直接跑 参考自：https","tags":["ngrok"],"title":"ngrok 搭建脚本","type":"post"},{"authors":null,"categories":["简书","随笔"],"content":" 迁移自简书，格式可能未经校对。\n 大学时，我一直有个问题不明白。为什么我不是我的team里最厉害的，跟其它team的老大相比也不是那么耀眼，但我带的team却成了最成功的团队（之一）。\n说说一些看法\n提前说明，大部分基于上学时的经验，少量参考职场经验。\nleader定位 工作后，我发现很多leader所谓的带人，不过就是让手底下的人能按照自己的吩咐去做事，当你真正交给他一个事情时，他就懵逼了。挑不起担子，无法独立思考，做决定。\n再联想到大学的时候学校也有其他的team，有一大类特别强调leader的权威，最后都很难成气候。虽然会在开始的一阵子让你感到满面春风，到长久也就成了行尸走肉。\n但是那些一开始就相对注重团队成员自我实现的，尽管前期会充满荆棘与摇摆。但会有一天，每个人都会释放无穷尽的能量。大一呆的辩论队也隐约有这个感觉。\n我觉得，leader从来就不应该是一个团队的核心，也完全不应该成为一个团队的精神象征。leader的作用应该只是维护团队的核心灵魂，维护好了，那个魂自己就回去吸引合适的人参与进来。\n带什么 举个很明显的区别，我们备课的时候，最不能接受知识点的罗列，经常在课前让主讲同学把整个ppt的逻辑颠倒。讲课的时候也一直强调在过程中启发。结果啥样自己去试。\n有些团队的培训，大部分都是很直白的一份讲义，散漫的列着想到啥是啥的东西，然后一个个过一下教大家这东西怎么用。\n从效率上来说，后者还是很明显的，一节课下来很多人反应收获不少。但是我们那样上课会让人觉得讲的太空太范。\n但实际上我认识的比较厉害的同学，大都是在自己折腾的过程中，突然脑海浮现一个点，然后把问题搞定。没有谁会去靠着课上那些东西来用。\n工作后也很明显，很多老大都是说你要做什么，却不提及背后的逻辑。底下人只能套用“做事模板”来干活。突然有天事情有了微妙的变化，然后不明所以的遭到了一顿骂。\n未完待续。\n","date":1480732013,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1480732013,"objectID":"6eaa5da03691c570170e0b588346eb5f","permalink":"/post/jianshu/%E5%BC%80%E5%9D%91%E5%85%B3%E4%BA%8E%E5%B8%A6%E5%9B%A2%E9%98%9F/","publishdate":"2016-12-03T10:26:53+08:00","relpermalink":"/post/jianshu/%E5%BC%80%E5%9D%91%E5%85%B3%E4%BA%8E%E5%B8%A6%E5%9B%A2%E9%98%9F/","section":"post","summary":"迁移自简书，格式可能未经校对。 大学时，我一直有个问题不明白。为什么我不是我的team里最厉害的，跟其它team的老大相比也不是那么耀眼，但我","tags":[],"title":"开坑，关于带团队","type":"post"},{"authors":null,"categories":["简书","随笔"],"content":" 迁移自简书，格式可能未经校对。\n 突然发现，工作已经一年了。\n87天日报，18篇周报，78000+字，算是记录。\n前半年里，多是些完成一个清晰明确的既定任务，之后更多的是处理一个相对大一点的项目。\n之前从0到1，现在从1到10，后面的过程，加入了许多非技术因素，很多时候少了所谓的标准答案，不确定性增多了，犯的错也多了，所思所想也开始变多变杂，很多时候就在说不清道不明的是非中突然顿悟。问我顿悟了什么，也说不明白，只是感觉曾经书本上那些无聊的讨论今天就摆在了面前。\n从小，有人会教你工作应该是啥样，不该是啥样。一入职场，发现并不是那么回事，时间久了，发现又好像是那么回事。\n赶上美国大选，结果算是如愿。我一直不知道我什么对川普感兴趣，现在想想，可能我也一贯如此，总想打破污浊的黑云。\n我从来不知道前路在哪里，但是却鄙夷那些肮脏的路。\n未完待续先吃饭。。\n","date":1479032630,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1479032630,"objectID":"988c0733b94c5284f74085e03d3d2a9e","permalink":"/post/jianshu/%E8%81%8C%E5%9C%BA%E5%91%A8%E5%B9%B4%E8%AE%B0/","publishdate":"2016-11-13T18:23:50+08:00","relpermalink":"/post/jianshu/%E8%81%8C%E5%9C%BA%E5%91%A8%E5%B9%B4%E8%AE%B0/","section":"post","summary":"迁移自简书，格式可能未经校对。 突然发现，工作已经一年了。 87天日报，18篇周报，78000+字，算是记录。 前半年里，多是些完成一个清晰明确的","tags":[],"title":"职场周年记","type":"post"},{"authors":null,"categories":["简书","软件工程"],"content":" 迁移自简书，格式可能未经校对。\n Github 新出的squash 功能可以使主仓的log 更加干净，但是有个恶心的情况：\nfetch  company/master -\u0026gt; my/master -\u0026gt; my/dev\ndevlop  my/dev (10 commit) \u0026ndash;\u0026gt; squash \u0026ndash;\u0026gt; company/master (1 commit)\nmodify  my/dev (11 commit)\nmerge  company/master -\u0026gt; my/dev ==\u0026gt; conflict\n暂时解决方法是要求  每次动手前都要拉代码 每次改动都去开新分支  ","date":1478439620,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1478439620,"objectID":"725cfb3e0decec7214e2502af024e327","permalink":"/post/jianshu/github-squash-%E7%9A%84%E4%B8%80%E7%82%B9%E5%9D%91/","publishdate":"2016-11-06T21:40:20+08:00","relpermalink":"/post/jianshu/github-squash-%E7%9A%84%E4%B8%80%E7%82%B9%E5%9D%91/","section":"post","summary":"迁移自简书，格式可能未经校对。 Github 新出的squash 功能可以使主仓的log 更加干净，但是有个恶心的情况： fetch company/master -\u0026gt; my/master -\u0026gt; my/dev devlop my/dev (10 commit) \u0026ndash;\u0026gt; squash \u0026ndash;\u0026gt; company/master (1 commit) modify my/dev (11","tags":["Github","Squash"],"title":"Github Squash 的一点坑","type":"post"},{"authors":null,"categories":["简书","读书笔记"],"content":" 迁移自简书，格式可能未经校对。\n 看到前5章，只能说是读起来很艰难。\n满满的委曲求全的隐忍和男尊女卑，以及各种拗口的日本名词。\n序言说这是二战后的作品，隐忍就好理解了。但时代背景太强，心生一股抵触。我对历史一贯的态度是，可以有作者自身的态度（没有主观态度的书籍是不存在的），但是如果受外界大环境影响太深，就会遮住历史原来的道理。\n在日本女性要听话挺常见，但作者不知为何花那么大笔墨去强调这个问题，暂时没有查到相关资料。难道是作者是故意反讽吗？前五章里，重大的历史进行都托付在女人身上，你说他们不重要，当然不对。广忠以一种 loser 的姿态听从着三个女人对他“男尊女卑”的教诲，实在太搞笑。\n有人把它比作日本的三国演义？我还真保持质疑，三国里跑龙套的小城主小将军不计其数，有几个能有这般权谋，就连那些个主要人物，也都是被几个谋士耍来耍去。完全没有这种全民搞计谋、每个人都捉摸不透的渗人。\n","date":1475602040,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1475602040,"objectID":"99394fcdfe4dadde947ed8a10c0d550f","permalink":"/post/jianshu/%E5%BE%B7%E5%B7%9D%E5%AE%B6%E5%BA%B7%E7%AC%AC%E4%B8%80%E7%AF%87/","publishdate":"2016-10-05T01:27:20+08:00","relpermalink":"/post/jianshu/%E5%BE%B7%E5%B7%9D%E5%AE%B6%E5%BA%B7%E7%AC%AC%E4%B8%80%E7%AF%87/","section":"post","summary":"迁移自简书，格式可能未经校对。 看到前5章，只能说是读起来很艰难。 满满的委曲求全的隐忍和男尊女卑，以及各种拗口的日本名词。 序言说这是二战后的作","tags":[],"title":"《德川家康》第一篇","type":"post"},{"authors":null,"categories":["简书","软件工程"],"content":" 迁移自简书，格式可能未经校对。\n 这周也帮其他人看了看代码，发现大家对一些规范不以为然，所以我想借这个机会聊聊。代码规范的重要性说的太多了，我来说说代码不规范的危害。\n为什么要统一、规范的命名 举个例子，我们有公寓表 suites、房间表 rooms ，rooms 里有个关联到公寓的字段叫 suite_id。试问把 suite_id 改成 house_id 是否合理？\n单从这个例子来说，好像并无不妥，suite 和 house 都能表示公寓的意思。\n但是如果我告诉你我们现在还有额外的两张表：\n house_resources 信息采集端的外部房源，是外部房源进入收房系统的入口 resource_house 楼盘字典中的公寓，沉淀下来的外部房源，暂定  这个时候，假如你是非直接开发人员，比如其他工程师、需要看数据库的运营、财务或是 BI，你第一感觉，rooms 表的 house_id 是到哪个表的关联？我觉得猜到 house_resources 的人会多一些，但如果是 suite_id，再辅之以注释，就会好很多。可即便如此，BI 同学也经常过来问字段的关系。。\n这个例子想说明，当你的系统已经复杂到无法靠简单的 “望文生义” 去识别\u0026amp;区分时，你就得靠统一的规范去保证大家不会乱。我们约定所有的 xx_id 都是到 xx 表的关联，大家就不会再困惑。\n如果只是自己私下写一个二三十行的小脚本，你用 abcdefg 命名没啥问题，但在这里，你 hold 不住的。\n 信息采集端的几个表前缀都是 house_resource ，渠道就是house_resource_users ，渠道费就是 house_resource_bills ，也算一个识别标记。其实从更大的角度来说，房源和客源的跟进，也都该放一起，历史遗留问题。。\n 为什么要抽象和封装 思考：为什么我和孟德都没有参与过合同、活动的开发，但都能在几分钟内添加一个可以自定义规则的新活动？答案是，因为现有的封装已经满足现阶段的需要，我们无须关注整个实现逻辑，只需要改一个文件里的一小段（其实就一个 array）就能实现了。\n如果之前没有做这些工作，那么市场部今天下午告诉你12点前要上一个活动，你要从头熟悉整个代码，要熟悉每个节点的处理方式。恐怕你就是不吃饭不睡觉也来不及。\n其他的系统里，遇到的问题也是一样的：\n 做支付平台，能否在不涉及业务逻辑的情况下，快速添加一个支付平台 做分期平台，能否在不涉及业务逻辑的情况下，快速添加一个分期公司 做房源对接，能否在不涉及业务逻辑的情况下，快速添加一个信息平台 做供应商管理，能否在不涉及业务逻辑的情况下，快速添加一个供应商  如果你为了省一天的时间，在将来却给每个人加了一天的工作量，那么你的代码就是有毒的。\n诚然有很多情况，你并不能预测将来发生的情况，但是按照软件工程的原则，你应该留有扩展的空间。如果其他人已经帮你预料到接下来会有一个类似的东西时，你就必须考虑了。\n小故事，退转换上线前的一个晚上，10点多。我在那里吐槽又要改需求，高靖听到了就跑出来跟我说，你们的系统要做的模块化，在碰到这种情况的时候就能快速组合几个模块达到他们的目的，我们以前巴拉巴拉省略500字。。\n我当时一阵惊讶，一个不写代码的人都懂这个道理，可为什么我们这些“专业人员”却要对几十年的行业经验嗤之以鼻。\n为什么会有必读源码 必读源码最大的用处就是让新人知道这个系统是怎么运作的。\n当时我挑了好多个文件才决定选用这几份代码，有几个考虑：\n 里面包含了laravel、orm 的基本用法和文档，能让你快速上手 有我们沉淀下来的各种轮子，能让你快速实现常用的功能 有我们最一般最一般的产品设计规范，避免你为了达到某一个效果费劲脑汁  看这三份代码花不了个把小时，但是不看呢，有几个人都踩了坑，其结果是本来几十行代码的事，花了几百行才搞完。费时费力还有坑\n分享两例小故事，\n  有天雷雷一激动说我们能不能把完成标成红色（好像是喜庆的意思），我还没开口，旁边一个销售就说我们习惯绿色了，然后我才说我们把红色作为警告的意思。\n  还有我们的列表里按钮一般都在首列，结果就是无论第一列是“编辑”还是一个图标，大家都知道那个修改的地方。\n   红和绿、行首或行尾，都不是什么原则问题。但是在现有环境下，随机改动就增加了其他人的识别和使用成本，那就属于不合理的设计。\n  系统内部的 Error、Flash（小提示）、Confirm 以及 DataEditor 的错误提醒，都是统一的组件，即能提高你的开发效率，也能保证绝大多数人快速上手你的作品。\n 总结就是，强调代码规范，不是闲的蛋疼去满足个人的代码洁癖，而是不想让大家再去踩之前已经踩过的坑，提升整个团队的效率。 至于什么是代码洁癖，我可以分享一下我的一些洁癖：\n 我不喜欢一大行从半截折开，我自己设的最大宽度是160，后来妥协于 psr 规范，改成了120，出现了很多我觉得奇丑无比的折行。而且经过“科学试验”，我认为我们的项目设140比较合适，为此和张卫还争论过。。 我写 json，key/val 之间的冒号我要对齐，工具不支持我就手动对齐，但是为了统一，我也放弃了。绝大多数工具是冒号左边有空格，右边却没空格，我也觉得丑，但。。你懂的。 一个表达式a + b*c，仔细看，+ 两边有空格，但 * 两边没有空格，这是 Go 官方fmt 工具的标准格式，它会把优先级高的运算放一起，低的才有空格。在接触 Go 之前，我自己其实也这么干，特长的表达式，几个空格、几对括号的情况都有过。就为了阅读清晰。 有贝原名 uubee ，我在后台都写的 Ubee，是因为首字母要大写，我觉得 Uubee 又极丑无比，所以就省了 u。好在有 namespace 挡着，应该不会干扰其他人。  所以，不要觉得我是在故意刁难，为了遵循psr 规范我已经很委屈了。。\n其实说这些东西，并不是因为水平多么厉害才提，这些规范都和技术本身无关。提到的东西，也都是一路颠簸的血泪教训。谁没被自己的代码恶心过几回？\n今天这些更多的是想说为什么要好好设计你的代码，至于怎么设计，以后一点点的整理吧 ^_^\n最后 我坚信，写代码不是砌砖，不是画条线放块砖就完成任务了。奥对了，即便是砌砖工人，发现有块砖烂掉了也会毫不犹豫的扔掉，也不会以“赶工期”为由说“就这样吧，反正又不会塌”。\n","date":1474770753,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1474770753,"objectID":"7c3238a7fe0a80b2ede83a065d8e7a56","permalink":"/post/jianshu/code-review-%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/","publishdate":"2016-09-25T10:32:33+08:00","relpermalink":"/post/jianshu/code-review-%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/","section":"post","summary":"迁移自简书，格式可能未经校对。 这周也帮其他人看了看代码，发现大家对一些规范不以为然，所以我想借这个机会聊聊。代码规范的重要性说的太多了，我来","tags":["Code","Review"],"title":"Code Review 那点事儿","type":"post"},{"authors":null,"categories":["typecho"],"content":"背景 我们在以前的数学题中一定遇到过这样的问题：\nA说xxxx B说xxx C说xxx\n然后给一些条件，让你判断每个人说话的真假\n这个题目是这样的：\n 计算机学院准备组织院篮球赛，某班有ABCDE五个同学商量组队参加，他们在讨论谁来打前锋的时候发生了争执，于是他们请了另一个班的同学J当评委，五个人PK百米速度，谁的速度最快就由谁来当前锋，其实五个同学速度相当，比赛结束时，J让他们猜猜排名情况\n  A说：“E一定是第一名” B说：“我可能是第二名” C说：“A最慢” D说：“C不是最快的” E说：“D应该是第一名”    J最后说：“E肯定不是第二名或者第三名，你们几个只有获得第一名和第二名的人猜对了，你们应该知道谁最快了吧？” 编程给出五个同学的排名。\n算法 习惯了通过表达式去计算一个结果的人，很难去用枚举的思维方式来处理问题。尤其对于枚举的模型很难把握。\n枚举算法求解这类问题其实很简单，我尝试用以下三句话来说明：\n 把每个人说的话用一个逻辑表达式表示出来 枚举解空间内所有可能出现的情况 按照题中条件，筛选合法解  建立说话内容（断言）的模型 可以很容易想到，上述问题中A的内容“E是第一名”可以写成：\nScore['E'] == 1;\r 关键在于，如何描述“A说”的这个过程。很容易想到，这个过程实际上是一个从字符到表达式的映射。表达式在C语言中如何作为一个变量来使用？当然是函数指针，于是可以写出下面的代码：\nint guessA(){ return Score[\u0026#39;E\u0026#39;] == 1; } int guessB(){ return Score[\u0026#39;B\u0026#39;] == 2; } ... int (*guess[256])();\t//\t定义一个函数指针的数组 guess[\u0026#39;A\u0026#39;] = guessA; guess[\u0026#39;B\u0026#39;] = guessB; ... 这样的话，就可以用guess['A']()来表示A猜得正确与否\n枚举解空间 这个题目较为简单，5个人的排名当然有5!种情况，可以用C++提供的全排列的库实现，也可以用深搜自己实现。这里使用康托展开逆运算得到（每次计算的时间复杂度为O(1)）\n//\t生成1~n的全排列中得第k项，返回值在ret中 int fac[]={1,1,2,6,24,120,720,5040,40320,362880}; void invKT(int n, int k, int ret[]){ k--; int vst[8]={0}, j; for ( int i=0; i\u0026lt;n; i++){ int t = k/fac[n-i-1]; for (j=1; j\u0026lt;=n; j++){ if (!vst[j]){ if (t==0) break; t--; } } ret[i] = j; vst[j] = 1; k %= fac[n-i-1]; } } 我们可以枚举得到每次的结果：\nint score[N];\t//\tscore[i]表示(\u0026#39;A\u0026#39;+i)排第几名 int rank[N];\t//\trank[i]表示第i名是谁 for ( int i=1; i\u0026lt;=fac[n]; i++) { invKT(n, i, score); for ( int j=0; j\u0026lt;n; j++) rank[score[i]] = \u0026#39;A\u0026#39;+i; } 筛选 有了以上的准备工作，筛选就非常容易了。\n只有第一名和第二名说的正确：\nif ( guess[ rank[1] ]() == 1 \u0026amp;\u0026amp; guess[ rank[2] ]() == 1 \u0026amp;\u0026amp; guess[ rank[3] ]() == 0 \u0026amp;\u0026amp; guess[ rank[4] ]() == 0 \u0026amp;\u0026amp; guess[ rank[5] ]() == 0 ) E不是第二和第三：\nif ( score['E'-'A'] != 2 \u0026amp;\u0026amp; score['E'-'A'] != 3 )\r 总代码 实际的代码为了偷懒，在一些细节上跟上面的分析不太一样，仅供参考。\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstdlib\u0026gt; int score[6]; // i排第几 int rank[6]; // 第i名是谁  void invKT(int n, int k, int ret[]); int guess(int i); int main(){ int n = 5; for ( int i=1;i\u0026lt;=120;i++){ invKT(n, i, score+1); for ( int j=1;j\u0026lt;=n;j++) rank[score[j]] = j; if (guess(rank[1]) \u0026amp;\u0026amp; guess(rank[2]) \u0026amp;\u0026amp; guess(rank[3])==0 \u0026amp;\u0026amp; guess(rank[4])==0 \u0026amp;\u0026amp; guess(rank[5])==0 \u0026amp;\u0026amp; score[5]!=2 \u0026amp;\u0026amp; score[5]!=3) { for ( int j=1;j\u0026lt;=n;j++){ printf(\u0026#34;%c：第%d名\\n\u0026#34;, \u0026#39;A\u0026#39;+j-1, score[j]); } } } return 0; } int guess(int i){ return (i==1)*(score[5]==1) || (i==2)*(score[2]==2) || (i==3)*(score[1]==5) || (i==4)*(score[3]!=1) || (i==5)*(score[4]==1); } int fac[]={1,1,2,6,24,120,720,5040,40320,362880}; void invKT(int n, int k, int ret[]){ k--; int vst[8]={0}, j; for ( int i=0; i\u0026lt;n; i++){ int t = k/fac[n-i-1]; for (j=1; j\u0026lt;=n; j++){ if (!vst[j]){ if (t==0) break; t--; } } ret[i] = j; vst[j] = 1; k %= fac[n-i-1]; } } ","date":1444677300,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1444677300,"objectID":"1f5d3f3475964dc6300aa1f7f9a4513b","permalink":"/post/typecho/shui-shi-qian-feng/","publishdate":"2015-10-13T03:15:00+08:00","relpermalink":"/post/typecho/shui-shi-qian-feng/","section":"post","summary":"背景 我们在以前的数学题中一定遇到过这样的问题：\nA说xxxx B说xxx C说xxx\n然后给一些条件，让你判断每个人说话的真假\n","tags":["IT技术堆"],"title":"用程序去判断每个人说话的真假 - 写给新手的枚举介绍","type":"post"},{"authors":null,"categories":["typecho"],"content":"一直以来很想写一个自动签到的程序，因为很多免费工具网站不签到根本进行不下去。\n问题的关键在于设计一个统一的签到流程。最开始想的很简单，就是一组共享数据的请求，于是就有了第一个版本\nhttps://coding.net/u/kzzhr/p/gosigner/git\n这个程序能够完成ss的签到，但是到了v2ex却不行了。v2ex在login页面有一个用来防止csrf的token，这个token需要在页面中动态获取。\n吃个饭去。。\n","date":1444093380,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1444093380,"objectID":"ebcbc91076d6423cde70cb33e8aaa4dd","permalink":"/post/typecho/gosigner/","publishdate":"2015-10-06T09:03:00+08:00","relpermalink":"/post/typecho/gosigner/","section":"post","summary":"一直以来很想写一个自动签到的程序，因为很多免费工具网站不签到根本进行不下去。 问题的关键在于设计一个统一的签到流程。最开始想的很简单，就是一组","tags":["小玩意"],"title":"一个自动签到的程序","type":"post"},{"authors":null,"categories":["typecho"],"content":"悲剧就是善的冲突。至少，是不坏的冲突。\n因为想离职的事情跟我最敬爱的刘杰老师聊了一会人生，最后伤了老师的心。一个初来乍到的小毛孩，怎么可能跟一位长者有同样的认知。\n前辈们总是不断的分享经验告诫年轻人，而初生牛犊总要去惹一惹凶猛的老虎，人生的喜怒哀乐也尽藏于这样一代一代的循环往复中。\n我们无法得知在多年以后我们会是怎样的感叹庆幸或是哀叹遗憾。在当下，做一个疯狂的决定在自我感觉上无疑是最有价值的一瞬间。\n","date":1442132640,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1442132640,"objectID":"22ddcba62bd6e0be96ffdc73fa02c50d","permalink":"/post/typecho/beiju/","publishdate":"2015-09-13T16:24:00+08:00","relpermalink":"/post/typecho/beiju/","section":"post","summary":"悲剧就是善的冲突。至少，是不坏的冲突。 因为想离职的事情跟我最敬爱的刘杰老师聊了一会人生，最后伤了老师的心。一个初来乍到的小毛孩，怎么可能跟一","tags":["记事","随想"],"title":"悲剧","type":"post"},{"authors":null,"categories":["typecho"],"content":"先呵呵一下表示对自己的鄙视，明明不是写博的料却分要三番五次的开开开，开了又不写字。这次重开有两个基础，一是最近发现需要一个记录点点滴滴，二是发现自己确实需要一个比CSDN更自由的技术页面。所以以后的博客以这两方面为主。另外呢，阿里云提供了学生特惠，每月10块，非常感谢。\n","date":1441955340,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1441955340,"objectID":"0e65c99bd4d1d3f9a2bf33da28b38407","permalink":"/post/typecho/blogagain/","publishdate":"2015-09-11T15:09:00+08:00","relpermalink":"/post/typecho/blogagain/","section":"post","summary":"先呵呵一下表示对自己的鄙视，明明不是写博的料却分要三番五次的开开开，开了又不写字。这次重开有两个基础，一是最近发现需要一个记录点点滴滴，二是","tags":["记事","我的微博","tweet"],"title":"重开博客","type":"post"},{"authors":null,"categories":["typecho"],"content":"2015，真是倒霉。\n回家前一天，实验室一个同学没有锁好门。下午饭时实验室被窃。她的一台笔记本，一部手机，我的移动硬盘，身份证，学生证。\n在派出所搞到第二天接近中午，拿了派出所的证明到火车站取了车票（今年开始代售点必须刷学生证）\n补办身份证需要3个月，正在申请阿里云的备案又得等等了（写这篇文章的时候外网还不能访问）\n最悲剧的莫过于硬盘丢失，从高一开始将近6年的数据，全没了。其中包括很多很多个人信息譬如5年的3个G的QQ聊天记录，上万张照片有贵重的证件照还有珍贵的回忆，有无数日日夜夜积攒的代码，也有费尽精力整理的各种学习资料，各种应用软件。\n回家之后，手机连不上家里的WIFI，于是想重新刷机，忘了m2s没有SD卡，照旧使用Go备份。最后手机数据全没了。\n归零。\n","date":1423078236,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1423078236,"objectID":"cd20d00fb77589c47853aa0edec7ec0f","permalink":"/post/typecho/zero/","publishdate":"2015-02-05T03:30:36+08:00","relpermalink":"/post/typecho/zero/","section":"post","summary":"2015，真是倒霉。 回家前一天，实验室一个同学没有锁好门。下午饭时实验室被窃。她的一台笔记本，一部手机，我的移动硬盘，身份证，学生证。 在派出","tags":["记事"],"title":"归零","type":"post"},{"authors":null,"categories":["typecho"],"content":"温故不一定知新，不温故一定变傻！\n","date":1421517600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1421517600,"objectID":"1151edc73319bb422fff5918c7c47674","permalink":"/post/typecho/%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/","publishdate":"2015-01-18T02:00:00+08:00","relpermalink":"/post/typecho/%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/","section":"post","summary":"温故不一定知新，不温故一定变傻！","tags":["随想","我的微博","tweet"],"title":"温故而知新","type":"post"},{"authors":null,"categories":["typecho"],"content":"优秀是一种习惯！ 而不是某一时刻的水平高低！！！ 习惯！！！\n","date":1420950420,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1420950420,"objectID":"e2b5c9d8a5db08dd39b297a77fa81f19","permalink":"/post/typecho/excellence_is_habit/","publishdate":"2015-01-11T12:27:00+08:00","relpermalink":"/post/typecho/excellence_is_habit/","section":"post","summary":"优秀是一种习惯！ 而不是某一时刻的水平高低！！！ 习惯！！！","tags":["随想","我的微博","tweet"],"title":"优秀是一种习惯","type":"post"},{"authors":null,"categories":["typecho"],"content":"昨天Deepin2014.2内置了CrossOver Deepin专版，其中最大的惊喜莫过于QQ的正常使用。越来越感觉到 Deepin 才是普通 Linux 用户的未来。所以整理了一下这份资料。\n第一步：添加软件源 这一步网上可以看到很多教程，但是都是两年前的版本了，还得自己改成新的，所以这里重新整理一下\n打开 /etc/apt/sources.list，在末尾添加下面两行。\ndeb http://packages.linuxdeepin.com/deepin trusty main non-free universe\rdeb-src http://packages.linuxdeepin.com/deepin trusty main non-free universe%\r打开终端，导入密钥\nwget http://packages.linuxdeepin.com/deepin/project/deepin-keyring.gpg\rgpg --import deepin-keyring.gpg\rsudo gpg --export --armor 209088E7 | sudo apt-key add -\rsudo apt-get update\r第二步：安装深度商店及组件 sudo apt-get install deepin-software-center\rsudo apt-get install python-deepin-gsettings\r","date":1420752480,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1420752480,"objectID":"33c267eb5747884482f8ed4e353135eb","permalink":"/post/typecho/ubuntu_deepin/","publishdate":"2015-01-09T05:28:00+08:00","relpermalink":"/post/typecho/ubuntu_deepin/","section":"post","summary":"昨天Deepin2014.2内置了CrossOver Deepin专版，其中最大的惊喜莫过于QQ的正常使用。越来越感觉到 Deepin 才是普通 Linux 用户的未来。所以整理了一下这份资料。\n","tags":["IT技术堆"],"title":"xbuntu 添加 Deepin 软件源 2014.2","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n 基本的抓取 import urllib content = urllib.urlopen('http://www.x.com').read() 使用代理服务器 proxy = urllib2.ProxyHandler({'http':'http://host:port'}) opener = urllib2.build_opener(proxy, urllib2.HTTPHandler) urllib2.install_opener(opener) content = urllib2.urlopen('http://www.xxxx.com').read() Cookie import urllib2, cookielib cookie = urllib2.HTTPCookieProcessor(cookielib.CookieJar()) opener = urllib2.build_opener(cookie, urllib2.HTTPHandler) urllib2.install_opener(opener) content = urllib2.urlopen('http://www.xxx.com').read() POST 数据 比如说需要向 http://www.xxx.com/post/ 接口 POST 数据 name=’liluo’, age=’21’, blog=’http://liluo.org’\n首先需要准备数据\ndata = urllib.urlencode({ 'name': 'liluo', 'age' : '21', 'blog': 'http://liluo.org' }) 然后生成并发送 HTTP 请求\nreq = urllib2.Request(url='http://www.xxx.com/post/', data=data) ret = urllib2.urlopen(req).read() 伪装成浏览器 很多网站不喜欢爬虫（比如糗事百科），发送的请求会被拒绝。这个时候我们可以用修改 HTTP headers 信息来伪装成浏览器:\nheaders = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.168 Safari/535.19' } req = urllib2.Request( url = 'http://www.xxx.com', headers = headers ) ret = urllib2.urlopen(req).read() 绕过“反盗链” 某些网站（再比如糗事百科）图片会有所谓的反盗链设置，其实就是检查 HTTP 请求的 headers 里的 referer 是否来自该网站。所以只需改下 headers:\nheaders = {'Referer': 'http://www.qiushibai.com' } req = urllib2.Request( url = 'http://qiushibaike.com/', headers = headers ) ","date":1417492800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1417492800,"objectID":"753f52b2b8f11c9dc5a0eae6129a9129","permalink":"/post/dashayu/1417492800-python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/","publishdate":"2014-12-02T12:00:00+08:00","relpermalink":"/post/dashayu/1417492800-python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 基本的抓取 import urllib content = urllib.urlopen('http://www.x.com').read() 使用代理服务器 proxy = urllib2.ProxyHandler({'http':'http://host:port'}) opener = urllib2.build_opener(proxy, urllib2.HTTPHandler) urllib2.install_opener(opener) content = urllib2.urlopen('http://www.xxxx.com').read() Cookie import urllib2, cookielib cookie = urllib2.HTTPCookieProcessor(cookielib.CookieJar()) opener = urllib2.build_opener(cookie, urllib2.HTTPHandler) urllib2.install_opener(opener)","tags":null,"title":"python爬虫基础","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n 什么是Tkinter Tkinter（也叫Tk接口）是Tk图形用户界面工具包标准的Python接口。Tk是一个轻量级的跨平台图形用户界面（GUI）开发工具。Tk和Tkinter可以运行在大多数的Unix平台、Windows、和Macintosh系统。 Tkinter 由一定数量的模块组成。Tkinter位于一个名为_tkinter（较早的版本名为tkinter）的二进制模块中 。Tkinter包含了对Tk的低 级接口模块，低级接口并不会被应用级程序员直接使用，通常是一个共享库（或DLL），但是在一些情况下它也被Python解释器静态链接。 除了Tk接口模块，Tkinter也包含了一定数量的Python模块。其中两个最重要的模块是Tkinter本身和名为Tkconstants的模块。前者自动引导后者，因此使用Tkinter，你首先需要做的是导入Tkinter模块， 代码如下： import Tkinter 或 from Tkinter import *\n第一个Tkinter程序 File: hello1.py\nfrom Tkinter import * root = Tk() w = Label(root, text=\u0026quot;Hello, world!\u0026quot;) w.pack() root.mainloop() 运行结果如下： 转-Tkinter入门(一) 关闭这个窗口即可终止这个程序的运行。\n二、对代码的说明：\n我们通过导入Tkinter模块开始。Tkinter模块包含了用Tk工具包工作所需的所有的类，函数和其它一些必须的东西。在大多数情况下，你只需要简单的从Tkinter导入所有的东西到你的模块的名字空间，如下所示： from Tkinter import *\n然 后初始化Tkinter,方法是我们必须先创建一个Tk root（根）窗口部件，它是一个普通的窗口，带有标题条和其它由你的窗口管理器供给的附属。你 应该只创建一个root窗口部件，这个root窗口部件必须在其它窗口部件创建之前创建。初始化Tkinter的代码如下：\nroot = Tk() 接着我们创建一个Label（标签）窗口部件作为这个root窗口的孩子，代码如下：\nw = Label(root, text=\u0026quot;Hello, world!\u0026quot;) Label窗口部件可以显示文本、图标或图象。我们这里用text选项来指定要显示的文本。\n接下来我们在Label窗口部件上调用了pack方法，它告诉Label窗口部件去调整自己的尺寸来适应所给定文本的大小，并且使用自己可见，代码如下：\nw.pack() 但是在这些发生之前，我们必须进入Tkinter的事件循环，代码如下：\nroot.mainloop() 这 个程序将一直处在事件循环之中，直到我们关闭了这个窗口。事件循环不仅仅处理来自用户的事件（如鼠标敲击和按键按下）或者窗口系统（重绘事件和窗口配置消 息），它也处理来自Tkinter自身的工作等待队列，这些工作之一就包括由pack方法所产生的工作和显示更新。这就意味着这个应用程序窗口在进入这个 事件循环之前将不会显示出来。\n第二个Tkinter程序 当我们在写一个较大的程序的时候，把代码封装在类中通常是一个好的主意。\nFile: hello2.py\nfrom Tkinter import * class App: def __init__(self, master): frame = Frame(master) frame.pack() self.button = Button(frame, text=\u0026quot;QUIT\u0026quot;, fg=\u0026quot;red\u0026quot;, command=frame.quit) self.button.pack(side=LEFT) self.hi_there = Button(frame, text=\u0026quot;Hello\u0026quot;, command=self.say_hi) self.hi_there.pack(side=LEFT) def say_hi(self): print \u0026quot;hi there, everyone!\u0026quot; root = Tk() app = App(root) root.mainloop() 运行结果如下： 转-Tkinter入门(一) 如果你点击Hello按钮，将在控制台打印出”hi there, everyone!” 。如果你点击QUIT按钮，程序将终止。\n二、代码说明：\n这个简单的应用程序被写成了一个类。这个构造器（init 方法）通过一个父部件被调用，并针对父部件增加了一些子部件。构造器通过创建一个Frame（帧）窗口部件开始。一个帧是一个简单的容器，在这个例子中，我们仅用来容纳另外的两个部件。\nclass App: def __init__(self, master): frame = Frame(master) frame.pack() 这个帧实例被存储在一个名为Frame的局部变量中。在创建了这个部件后，我们立即调用pack方法来使用这个帧可见。\n然后我们创建两个Button（按钮）窗口部件作为这个帧的孩子。\nself.button = Button(frame, text=\u0026quot;QUIT\u0026quot;, fg=\u0026quot;red\u0026quot;, command=frame.quit) self.button.pack(side=LEFT) self.hi_there = Button(frame, text=\u0026quot;Hello\u0026quot;, command=self.say_hi) self.hi_there.pack(side=LEFT) 这次，我们传递了一定数量的选项给构造器。第一个按钮被标为”QUIT”，字为红色（fg是foreground\u0026lt;前景色\u0026gt;的缩写）。第二个被标为”Hello”。两个按钮都有一个command选项。这个选项指定了一个函数或方法，在按钮被点击时会被调用。\n按 钮实例被存储在实例属性组中。side=LEFT 参数表示这两个按钮在帧中将被分开放置；第一个按钮被放置在帧的左边缘，第二个被放在第一个的右边（帧 的左边缘仍保留着空格）。默认情况下，部件的放置都是相对于它们的父亲（frame部件相对于master，button相对于frame）。如果 side选项没指定，side默认值为TOP。\n“Hello”按钮的回调函数如下所示，它在按钮每次被按下时简单地打印一条信息给控制台：\ndef say_hi(self): print \u0026quot;hi there, everyone!\u0026quot; 最后我们提供了一些脚本级的代码来创建一个Tk root部件，和一个App类的实例（这个实例使用这个root部件作为它的父亲）：\nroot = Tk() app = App(root) root.mainloop() root.mainloop()调用root部件的mainloop方法。它进入Tk事件循环，这个应用程序将处于这个Tk事件循环之中直到quit方法被调用（点击QUIT按钮），或窗口被关闭。\n关于窗口部件引用\n在第二个例子中，frame部件被存储在一个名为frame的局部变量中，而button部件则存储在两个实例的属性组中。这是否隐藏着一个严重的问题呢：当 init 函数返回并且frame变量超出了范围会发生什么呢？。\n不 要紧；这儿确实没有必要去保持对窗口部件实例的引用。Tkinter自动维护一个窗口部件树（通过对象实例的master和children属性），因 此，当应用程序的最后一个引用消失时窗口部件不会消失；窗口部件必须显示的用destroy方法销毁。但是如果你希望在窗口部件被创建以后用它来做一些事 情，你最好保持对你自己的窗口部件实例的引用。\n注意如果你不需要保持对一个窗口部件的引用，你可以用单独的一行来创建和pack（包装）它，如下：\nButton(frame, text=\u0026quot;Hello\u0026quot;, command=self.hello).pack(side=LEFT) 不要存储这个操作的结果，当你试图去用这个结果时你会很失望（因为pack方法返回None）。为小心起见，最好将将pack（包装）分开，如下所示：\nw = Button(frame, text=\u0026quot;Hello\u0026quot;, command=self.hello) w.pack(side=LEFT) 关于窗口部件的名字\n另一个容量引起混淆的方面（尤其是使用Tcl编程Tk的有一些经验的人）是Tinter的窗口部件的名字的概念。在Tcl中，你必须显示的命名每一个窗口 部件。例如下面的Tcl命令创建一个名为ok的按钮作为名为dialog的窗口部件的孩子（dialog又是root窗口的孩子）：\nbutton .dialog.ok 相应的Tkinter调用将如下： ok = Button(dialog) 在 这个Tkinter案例中，ok和dialog是对窗口部件实例的引用，不是窗口部件实际的名字。因为Tk自身需要这些名字，Tkinter自动为每个新 窗口部件赋一个唯一的名字。在这个Tkinter案例中，这个dialog的名字或许类似”.1428748”，并且button可能 是”.1428748.1432920”。如果你希望得到一个Tkinter窗口部件的完整名字，你可以在这个窗口部件实例上使用str函数：\n\u0026gt;\u0026gt;\u0026gt; print str(ok) .1428748.1432920 如果你确实需要为一个窗口部件指定一个名字，你可以在你创建这个窗口部件时使用name选项。你这么做的原因可能是你需要和用Tcl写的代码接口。\n下面的例子将产生一个名为”.dialog.ok”的窗口部件（如果你忘了命名dialog,那么名字可能类似”.1428748.ok”）： ok = Button(dialog, name=“ok”)\n为了避免与此同时Tkinter的名字机制相冲突，不要使用只包含数字的名字。同样注意name是只能创建一次的选项；一旦你创建了这个部件的名字，那么你就不能再改变它的名字了。\n","date":1417406400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1417406400,"objectID":"cb2842362d3fe049803197189935f2c7","permalink":"/post/dashayu/1417406400-tkinter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","publishdate":"2014-12-01T12:00:00+08:00","relpermalink":"/post/dashayu/1417406400-tkinter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 什么是Tkinter Tkinter（也叫Tk接口）是Tk图形用户界面工具包标准的","tags":null,"title":"Tkinter学习笔记","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n 资源列表： python  简明 Python 教程 浅显易懂，快速上手 Python快速教程 全。不过对新手会有点鸭梨 fenby 边学边练 一些可能会用到的模块 网易公开课 零基础学Python - 老齐 东西很全。缺点是太多啰嗦，基础部分适合文科生  Tkinter  易百 全面、详细、图文演示  dajango  【网易公开课】快速上手 一个下午熟悉 Dajango  博客  Sun 很详细的学习笔记 张哲的新浪博客 很全面  别人整理的资源列表  github.com/Yixiaohan  ","date":1417060800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1417060800,"objectID":"9d5781faf092255f029b0ff94e1cfa1d","permalink":"/post/dashayu/1417060800-python%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/","publishdate":"2014-11-27T12:00:00+08:00","relpermalink":"/post/dashayu/1417060800-python%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 资源列表： python 简明 Python 教程 浅显易懂，快速上手 Python快速教程 全。不过对新手会有点","tags":null,"title":"python上手指南","type":"post"},{"authors":null,"categories":null,"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n    目录结构：  ./project/ |- src/ | |- package1/a.java\tjava source | |- package2/b.java | |- WebRoot/ | |- META-INF/ | |- MANIFEST.MF | |- WEB-INF/ | |- classes/ | | |- */*.class 编译后自动生成 | | |- struts.xml | |- lib/ | | |- *.jar\t依赖包 | | | |- web.xml\t全局配置，首页、路由都在这里 | |- index.jsp\tviews |     原理示意图：        要点：   action.X中，变量名必须和 form中的name值一至，否则会报错空指针。    ","date":1416124002,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1416124002,"objectID":"40142032ecf125ecf8940c1ea220c71b","permalink":"/post/csdn/struts2-%E5%85%A5%E9%97%A8%E5%9B%BE%E8%A7%A3/","publishdate":"2014-11-16T15:46:42+08:00","relpermalink":"/post/csdn/struts2-%E5%85%A5%E9%97%A8%E5%9B%BE%E8%A7%A3/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 目录结构： ./project/ |- src/ | |- package1/a.java java source | |- package2/b.java | |- WebRoot/ | |- META-INF/ | |- MANIFEST.MF | |- WEB-INF/ | |- classes/ | | |- */*.class 编译后自动生成 | | |- struts.xml | |- lib/ |","tags":["struts2"],"title":"struts2 入门图解","type":"post"},{"authors":null,"categories":["typecho"],"content":"以后的Js演示都放在这里啦\n","date":1415847960,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1415847960,"objectID":"9a30360fcb1d29243332476fc66ce566","permalink":"/post/typecho/h5tricks_codingapp_com/","publishdate":"2014-11-13T11:06:00+08:00","relpermalink":"/post/typecho/h5tricks_codingapp_com/","section":"post","summary":"以后的Js演示都放在这里啦","tags":["IT技术堆","我的微博","tweet"],"title":"JS动画","type":"post"},{"authors":null,"categories":["typecho"],"content":"【大清相国】火车上一口气地把《大清相国》读完了。王岐山推荐的书，果然不一般。以往我们看广场小说都写的多么多么黑，且结局一定悲催地发人深省。但是这本书看完了最直观的感受就是对陈廷敬的膜拜。官场辗转多年依然亭亭独立的真不多见。回来后忍不住把康熙王朝又看了一遍，最大的收货就是开始思考趋利避害，对人对事。以往我都是因一弊而舍全身，现在看看人家感觉太厉害了！\n","date":1415430540,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1415430540,"objectID":"22be4ca1daef9fe1d0d5964d550f4062","permalink":"/post/typecho/chentingjing/","publishdate":"2014-11-08T15:09:00+08:00","relpermalink":"/post/typecho/chentingjing/","section":"post","summary":"【大清相国】火车上一口气地把《大清相国》读完了。王岐山推荐的书，果然不一般。以往我们看广场小说都写的多么多么黑，且结局一定悲催地发人深省。但","tags":["随想","读书","tweet"],"title":"大清相国","type":"post"},{"authors":null,"categories":["typecho"],"content":"请到演示地址里进行拖动鼠标吧！\n本来是想看看做一个跟随鼠标的时钟有多复杂，后来就觉得可以尝试做一个图案心，一定特别漂亮。\n关于心形的方程可以在Matrix67的博客里看到，里面有各种复杂的情况，但是对于js而言，太复杂了。于是找了取巧的办法，就是把一个椭圆过中心斜着切一刀，把一半图案反转就可以得到一个近似的心。\n椭圆很容易得到，把一个圆一边压缩就可以了，圆更容易得到，可以通过极坐标方便计算。\n\r\r","date":1413162960,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1413162960,"objectID":"581abeb6e62d6b2f537dfd86193805a0","permalink":"/post/typecho/mouseheart/","publishdate":"2014-10-13T09:16:00+08:00","relpermalink":"/post/typecho/mouseheart/","section":"post","summary":"请到演示地址里进行拖动鼠标吧！ 本来是想看看做一个跟随鼠标的时钟有多复杂，后来就觉得可以尝试做一个图案心，一定特别漂亮。 关于心形的方程可以在M","tags":["小玩意"],"title":"一个跟随鼠标变换的心形图案","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n     其实一贯都是用string来着。。  其实后来看刘汝佳的书又喜欢上了fgets然后一路过关斩将来着。。    这次觉得题水就用了gets啊啊啊啊  然后就WA了9次啊有木有！！！       H. Decode  TimeLimit: 1s MemoryLimit: 64M  Description  Bruce Force has had an interesting idea how to encode strings. The following is the description of how the encoding is done:   Let x   1   ,x   2   ,...,x    n    be the sequence of characters of the string to be encoded.   1.Choose an integer m  and n  pairwise distinct numbers p  1  ,p  2  ,...,p  n   from the set { 1  , 2  , ..., n  } (a permutation of the numbers 1  to n  ).  2.Repeat the following step m  times.  3.For 1  ≤ i ≤ n  set y  i  to x  pi  , and then for 1  ≤ i ≤ n  replace x  i  by y  i  .  For example, when we want to encode the string \"hello\", and we choose the value   m = 3   and the permutation   2, 3, 1, 5, 4   , the data would be encoded in 3 steps: \"hello\" -  \u0026gt; \"elhol\" -\u0026gt; \"lhelo\" -\u0026gt; \"helol\".   Bruce gives you the encoded strings, and the numbers   m   and p   1   , ..., p    n    used to encode these strings. He claims that because he used huge numbers   m   for encoding, you will need a lot of time to decode the strings. Can you disprove this claim by quickly decoding the strings?   Input  The input contains several test cases. Each test case starts with a line containing two numbers   n   and   m   (   1 ≤ n ≤ 80   ,   1 ≤ m ≤ 10     9    ). The following line consists of   n   pairwise different numbers p   1   ,...,p    n    (   1   ≤ p   i   ≤   n   ). The third line of each test case consists of exactly   n   characters, and represent the encoded string. The last test case is followed by a line cont  aining two zeros.  Output  For each test case, print one line with the decoded string.     SampleInput  5 3 2 3 1 5 4 helol 16 804289384 13 10 2 7 8 1 16 12 15 6 5 14 3 4 11 9 scssoet tcaede n 8 12 5 3 4 2 1 8 6 7 encoded? 0 0     SampleOutput  hello second test case encoded?            不说啥了，就是mod一个周期就行。getline的代码在最下面，纪念一下死的多坑。    #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;algorithm\u0026gt; #define LL long long using namespace std;\nconst int INF = 999999999; const double eps = 1e-6;\nint T,I,n,m,t; LL tt, sum; int a[1111]; int f[1111]; int dp[888][888]; char s[888]; char ans[888]; char ss[888];\nint so(int v){ if (a[v] == v ) return 1; int t = a[v]; int res = 1; while (t!=v){ t = a[t]; res++; } return res; }\nint too(int v,int k){ for (int i(1);i\u0026lt;=k;i++){ v = a[v]; } return v; }\nint main(){ while ( fgets(ss, INF, stdin) ) { sscanf(ss, \u0026ldquo;%d%d\u0026rdquo;,\u0026amp;n,\u0026amp;m); if (n==0 \u0026amp;\u0026amp; m==0) break;\n fgets(ss, INF, stdin); char *p = strtok(ss, \u0026quot; \u0026quot;); for (int i(1);i\u0026amp;lt;=n;i++) { sscanf(p, \u0026quot;%d\u0026quot;, \u0026amp;amp;a[i]); p = strtok(NULL, \u0026quot; \u0026quot;); f[i] = 0; } for (int i(1);i\u0026amp;lt;=n;i++) { f[i] = so(i); } fgets(s+1, INF, stdin); for ( int i(1); i\u0026amp;lt;=n; i++) { ans[too(i, m%f[i] )] = s[i]; } ans[n+1] = 0; printf(\u0026quot;%s\\n\u0026quot;,ans+1); } return 0;  } \n   #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; const int MAXN = 888; int n, m; int a[MAXN], f[MAXN]; char ans[MAXN], s[MAXN], ch; int to(int v, int w){ while( w\u0026ndash; ) v = a[v]; return v; }\nint main(){ while( EOF != scanf(\u0026quot;%d %d\\n\u0026rdquo;, \u0026amp;n, \u0026amp;m) ){ if( !n \u0026amp;\u0026amp; !m ) break; //getchar(); for(int i=1; i\u0026lt;=n; i++) cin\u0026gt;\u0026gt;a[i];//scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;a[i]), getchar(); cin.getline(s+1, MAXN); cin.getline(s+1, MAXN); for(int i=1; i\u0026lt;=n; i++) if( a[i]==i ) f[i] = 1; else{ int t=a[i], cnt=1; while( t!=i ) t=a[t], cnt++; f[i] = cnt; } for(int i=1; i\u0026lt;=n; i++) ans[ to(i, m%f[i]) ] = s[i]; ans[n+1] = 0; cout\u0026lt;\u0026lt;ans+1\u0026lt;\u0026lt;endl; } return 0; }  \n 真切感慨以后在时间充裕的时候能用C++就用C++。别自作多情的装逼用c啥啥的     ","date":1412734171,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1412734171,"objectID":"aefa5e63edd7985c72c21e859c1a26a4","permalink":"/post/csdn/usc-1329-decode-%E5%9D%91%E5%9D%91%E5%9D%91gets/","publishdate":"2014-10-08T10:09:31+08:00","relpermalink":"/post/csdn/usc-1329-decode-%E5%9D%91%E5%9D%91%E5%9D%91gets/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 其实一贯都是用string来着。。 其实后来看刘汝佳的书又喜欢上了fgets然后一路过关斩将来着。。 这","tags":["USC"],"title":"USC 1329 Decode 坑坑坑gets","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n 好久不水 开始深入算法了。  题目传送门   题目其实很简单，暴搜都可以，网上最多的解法都是记忆化搜索，效率应该不差。 不过对于一个迷恋上DP的人，又怎么愿意去干搜索这种体力活。  原归正转，先看题目数量无限，但是想一下就知道每种物品最多就3个，所以把所有物品拆成3n个， 然后觉得跟LIS是一样的，所以就来了两重循环。  for ( int i(1); i\u0026lt;=n; i++) { d[i] = a[i].c; for ( int j(1); j\u0026lt;i; j++) { if (a[j].a\u0026lt;a[i].a \u0026amp;\u0026amp; a[j].b\u0026lt;a[i].b \u0026amp;\u0026amp; d[j]+a[i].c\u0026gt;d[i]){ d[i] = d[j] + a[i].c; } } ans = max(ans, d[i]); }  出来之后发现不对。仔细想想发现跟LIS不一样，因为无序，会出现ACB这样的情况。  怎么办呢？ 靠直觉我又把上面的循环走了n次。。  for ( int k(1); k\u0026lt;=n; k++){ for ( int i(1); i\u0026lt;=n; i++){ for ( int j(1); j\u0026lt;=n; j++) if (a[j].a\u0026gt;a[i].a \u0026amp;\u0026amp; a[j].b\u0026gt;a[i].b \u0026amp;\u0026amp; d[j]+a[i].c\u0026gt;d[i] ){ d[i] = d[j]+a[i].c; } } }  AC确实没问题了，关键是复杂度抬高了一个数量级！  再仔细想想发现原来真的是想多了。回到刚刚说的问题，仿LIS主要的问题是会出现ACB的情况，按照题意，既然出现了ACB，便不再会有ABC的情况。这样的话，我只需要排个序，把C放在B前面即可，排序条件当然是按底面积。  最后代码如下：  #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int INF = 0x3fffffff; const double eps = 1e-6;\nstruct NODE{ int a,b,c; NODE(){} NODE(int x,int y,int z): a(x),b(y),c(z) {} }a[111];\nbool cmp(NODE a,NODE b){ if (a.a==b.a) return a.b\u0026lt;b.b; return a.a\u0026lt;b.a; } int d[111];\nint I,T,n,m;\nint main(){ freopen(\u0026ldquo;in.txt\u0026rdquo;,\u0026ldquo;r\u0026rdquo;,stdin); while ( scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;n) \u0026amp;\u0026amp; n){ for ( int i(0); i\u0026lt;n; i++) { int a1,b1,c1; scanf(\u0026quot;%d%d%d\u0026rdquo;,\u0026amp;a1, \u0026amp;b1, \u0026amp;c1); if (b1\u0026lt;a1) swap(a1,b1); if (c1\u0026lt;b1) swap(b1,c1); if (b1\u0026lt;a1) swap(a1,b1); // printf(\u0026quot;%d,%d,%d\\n\u0026rdquo;,a1,b1,c1); a[i3+1]=NODE(a1,b1,c1); a[i3+2]=NODE(a1,c1,b1); a[i3+3]=NODE(b1,c1,a1); } n=3; sort(a+1,a+n+1,cmp); memset(d, 0, sizeof(d)); int ans = 0; for ( int i(1); i\u0026lt;=n; i++) { d[i] = a[i].c; for ( int j(1); j\u0026lt;i; j++) { if (a[j].a\u0026lt;a[i].a \u0026amp;\u0026amp; a[j].b\u0026lt;a[i].b \u0026amp;\u0026amp; d[j]+a[i].c\u0026gt;d[i]){ d[i] = d[j] + a[i].c; } } ans = max(ans, d[i]); }\n printf(\u0026quot;Case %d: maximum height = %d\\n\u0026quot;, ++I, ans); } return 0;  }\n 看最后的思路，时不时一下透亮了许多。 感叹果然DP大法神。 就是要非常理解方程背后的道理。这个才真的有价值！    ","date":1412068825,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1412068825,"objectID":"344736ce41b9eb83b0c98dd7460d7f62","permalink":"/post/csdn/uva-437-the-tower-of-babylon/","publishdate":"2014-09-30T17:20:25+08:00","relpermalink":"/post/csdn/uva-437-the-tower-of-babylon/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 好久不水 开始深入算法了。 题目传送门 题目其实很简单，暴搜都可以，网上最多的解法都是记忆化搜索，效率应该","tags":["UVa","Algorithm","ACM"],"title":"UVa 437 The Tower of Babylon","type":"post"},{"authors":null,"categories":["typecho"],"content":"突然觉得《The Road Not Taken》跟王国维先生的《三境界》有点像\n","date":1409250000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1409250000,"objectID":"a908c097b1b714ec2468b0fc081a4177","permalink":"/post/typecho/road_not_taken_vs_sanjingjie/","publishdate":"2014-08-29T02:20:00+08:00","relpermalink":"/post/typecho/road_not_taken_vs_sanjingjie/","section":"post","summary":"突然觉得《The Road Not Taken》跟王国维先生的《三境界》有点像","tags":["随想","读书","我的微博","tweet"],"title":"RoadNotTaken And 三境界","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  好久不写代码果然手会生成屎 题目在 poj上也有   题意就是给你一堆单词，按首位顺序排列起来，问你有没有解。 第一眼看上去是个哈密顿通路，单词当做节点，首尾关系作边，听上去妥妥的不过N有100000 复杂度太恐怖。 其实是从刘汝佳的小白书第二版（其实该叫小紫红书了）上欧拉回路那节看到的，所以得考虑考虑转换 把单词当边，首尾字符当做点 题目就转变为 欧拉通路  不得不感慨，图论算法的重点还是在构图！！！   判断欧拉通路：  1. 一个有向图存在欧拉回路必定也存在欧拉通路...因为通路的定义包括了回路  2. 不考虑为欧拉回路的情况..一个有向图是欧拉通路就必须有一个点出度-入度=1,一个点入度-出度=1..这两点就是欧拉通路的起点和终点..并且该图连通  3. 我自己加一条，其实是对2的理解：  入读-出度\u0026gt;1 时直接return false ，排除 a-\u0026gt;b a-\u0026gt;c 这种情况   判断欧拉回路：  无向图是欧拉图的充要条件是所有点的度为偶数并且所有点联通   有向图是欧拉图的充要条件是所有点的入度=出度..并且联通...     判断连通  1. dfs遍历， 这里有一份参考代码  不过我一直怀疑其正确性。因为你无法确定有向图的起点，比如 a-\u0026gt;b-\u0026gt;c 如果你从b点开始搜的话就会悲催，但是你不知道b点上面还有没有点。 2. 并查集，并查集的方便之处不用废话。但是在图论中两点之间有多条边时需要注意一些细节的处理。  关于判断入读出度 一种办法是分别记录 in[] out[] 我用的办法是一个数组：sz[x]++ 表示拉出一条边，sz[x]--表示走来一条边，sz[x]==1 sz[x]==-1 就是上面的两种情况  上代码吧 这是只开sz[]的 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #define N 101010 using namespace std; int sz[333]; int fa[333]; bool ok[333]; // 数据中使用到的单词 int n, T;\nint getfa(int v) { if ( fa[v] == v ) return v; return fa[v] = getfa(fa[v]); }\nvoid init() { memset(ok, 0, sizeof(ok)); memset(sz, 0, sizeof(sz)); cin \u0026gt;\u0026gt; n; string a; for ( int i(\u0026lsquo;a\u0026rsquo;); i \u0026lt;= \u0026lsquo;z\u0026rsquo;; i++) fa[i] = i; for ( int i(1); i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a; int x = a[0], y = a[a.size() - 1]; fa[getfa(x)] = getfa(y); ok[x] = ok[y] = true; sz[x]++; sz[y]\u0026ndash;; } }\nbool check() { int tf = 0 , i; for ( i = \u0026lsquo;a\u0026rsquo;; i \u0026lt;= \u0026lsquo;z\u0026rsquo;; i++) { if (ok[i]) { if ( !tf ) tf = getfa(i); else if ( getfa(i) != tf ) return false; // 不连通 } }\nint c1 = 0, c2 = 0; for ( int i('a'); i \u0026amp;lt;= 'z'; i++) { if (!ok[i]) continue; if ( sz[i] == 0 ) continue; else if ( sz[i] == 1 ) c1++; else if ( sz[i] == -1) c2++; else return false;\t// 其它乱七八糟的情况 比如 ab ab out[a]=2 in[b]=2 } if ( (c1 == 1 \u0026amp;amp;\u0026amp;amp; c2 == 1) || (c1 == 0 \u0026amp;amp;\u0026amp;amp; c2 == 0) ) // 单向路径 or 回路 return true; else return false;  }\nint main() { freopen(\u0026ldquo;in.txt\u0026rdquo;, \u0026ldquo;r\u0026rdquo;, stdin); for ( cin \u0026gt;\u0026gt; T; T\u0026ndash;; ) { init(); if (check()) cout \u0026lt;\u0026lt; \u0026ldquo;Ordering is possible.\u0026rdquo; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026ldquo;The door cannot be opened.\u0026rdquo; \u0026lt;\u0026lt; endl; } }  \n为保险起见，还是开了两个数组的 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #define N 101010 using namespace std; int in[333], out[333]; int fa[333]; bool ok[333]; // 数据中使用到的单词 int n, T;\nint getfa(int v) { if ( fa[v] == v ) return v; return fa[v] = getfa(fa[v]); }\nvoid init() { memset(ok, 0, sizeof(ok)); memset(in, 0, sizeof(in)); memset(out, 0, sizeof(out)); cin \u0026gt;\u0026gt; n; string a; for ( int i(\u0026lsquo;a\u0026rsquo;); i \u0026lt;= \u0026lsquo;z\u0026rsquo;; i++) fa[i] = i; for ( int i(1); i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a; int x = a[0], y = a[a.size() - 1]; fa[getfa(x)] = getfa(y); ok[x] = ok[y] = true; out[x]++; in[y]++; } }\nbool check() { int tf = 0 , i; for ( i = \u0026lsquo;a\u0026rsquo;; i \u0026lt;= \u0026lsquo;z\u0026rsquo;; i++) { if (ok[i]) { if ( !tf ) tf = getfa(i); else if ( getfa(i) != tf ) return false; // 不连通 } }\nint c1 = 0, c2 = 0; for ( int i('a'); i \u0026amp;lt;= 'z'; i++) { if (!ok[i]) continue; if ( in[i] == out[i] ) continue; else if ( in[i] - out[i] == 1 ) c1++; else if ( in[i] - out[i] == -1) c2++; else return false; //else {printf(\u0026quot;%d%d\\n\u0026quot;,in[i],out[i]);return false;} // 其它乱七八糟的情况 } if ( (c1 == 1 \u0026amp;amp;\u0026amp;amp; c2 == 1) || (c1 == 0 \u0026amp;amp;\u0026amp;amp; c2 == 0) ) // 单向路径 or 回路 return true; else return false;  }\nint main() { //freopen(\u0026ldquo;in.txt\u0026rdquo;, \u0026ldquo;r\u0026rdquo;, stdin); for ( cin \u0026gt;\u0026gt; T; T\u0026ndash;; ) { init(); if (check()) cout \u0026lt;\u0026lt; \u0026ldquo;Ordering is possible.\u0026rdquo; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026ldquo;The door cannot be opened.\u0026rdquo; \u0026lt;\u0026lt; endl; } }  \n    ","date":1408020898,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1408020898,"objectID":"49d9d7f4184d4c2dd5d5b53eaea84171","permalink":"/post/csdn/uva-10129-play-on-words/","publishdate":"2014-08-14T20:54:58+08:00","relpermalink":"/post/csdn/uva-10129-play-on-words/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 好久不写代码果然手会生成屎 题目在 poj上也有 题意就是给你一堆单词，按首位顺序排列起来，问你有没有解。","tags":["UVa","Algorithm","ACM"],"title":"UVa 10129 Play on Words","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  首先到官网下载最新版本，由于官网只提供了32bit版本，所以只能下载这个。 wget http://wdl1.cache.wps.cn/wps/download/Linux/unstable/wps-office_8.1.0.3724~b1p2_i386.deb   安装 sudo dpkg -i wps-office_8.1.0.3724~b1p2_i386.deb  这个时候如果去安装电脑可能会假死，不用担心，装好之后会提示依赖关系不正确。强制补充就行   sudo apt-get install -f  回车之后，会提示装一大堆 i386的组件，因为我们的系统是64bit提供的也是64bit的组件而软件需要32bit环境。  一般来说，到这里之后wps就算安装好了。  启动 wps  从终端启动如果失败就会提示错误信息，可能会提示缺少 libXyx.so 之类的，这个时候只需要安装对应的32bit版本就可以。但是要注意名字，Xyz一律小写为xyz，末尾还要加上版本号（输入xyz后直接tab就可以得到）  sudo apt-get install libxyzV  装好之后再尝试终端打开wps，缺什么补什么，原本想整理出一份列表出来，但是发现不同机器差别极大，暂时没有去处理。  不过在装64bit的rpm包时提示了一堆依赖，如果换到32bit的话应该对应换来就行。  启动之后，会有一个提醒告诉你字体缺失，如果你不喜欢ubuntu的字体的话就自己去装吧（ http://bbs.wps.cn/thread-22355435-1-1.html  ）。装好之后小心浏览器里都变成宋体。  ","date":1405923412,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1405923412,"objectID":"eae0856c7b96e4855a7c3ef84b074043","permalink":"/post/csdn/ubuntu-%E5%AE%89%E8%A3%85-wps.deb/","publishdate":"2014-07-21T14:16:52+08:00","relpermalink":"/post/csdn/ubuntu-%E5%AE%89%E8%A3%85-wps.deb/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 首先到官网下载最新版本，由于官网只提供了32bit版本，所以只能下载这个。 wget http://wdl1.cache.wps.cn/wps/download/Linux/unstable/wps-office_8.1.0.3724~b1p2_i386.deb 安装 sudo dpkg -i wps-office_8.1.0.3724~b1p2_i386.deb 这个时候如","tags":["ubuntu"],"title":"ubuntu 安装 wps.deb","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n 题目链接  题目很水，纯模拟 麻烦的地方在于，会面临多次用小件填充大件剩余。 最开始觉得不同大小时决策不一样，所以各自写各自的，结果越写越凌乱，果断wa了。 最悲催的是拿到数据后依然无从下爪（代码真的太乱了！）  于是开始重理思路，把该有的地方封装起来再调试，果然明朗许多。 唉教训啊教训  #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int n=6,t; int a[8]; int push(int t,int i, int num){ // 把num个a[i]放进容量为t的箱子里，返回箱子容量 if ( num \u0026gt; a[i]) num = a[i]; t -= i*i * num; a[i] -= num; return t; } int main(){ for(;;){ int ts = 0; for ( int i(1);i\u0026lt;=n;i++){ cin \u0026gt;\u0026gt; a[i]; ts+=a[i]; } if (!ts) break;  int s =a[6]+a[5]+a[4]; // a5 if (a[5]*11 \u0026amp;gt;= a[1]) a[1] = 0; else a[1] -= a[5]*11; // a4 for ( int i(1);i\u0026amp;lt;=a[4];i++){ t = push(20,2,5); if (t) t = push(t,1,t); } // a3 s += a[3] / 4;\t// 整装3 a[3] %= 4; if (a[3]){\t//\t剩下的空间分情况装2 t = 36 - a[3]*9; if ( a[3] == 1 ) t = push(t,2,5); if ( a[3] == 2 ) t = push(t,2,3); if ( a[3] == 3 ) t = push(t,2,1); if (t) t = push(t,1,t);\t//\t剩下的空间都装1 s++; } // a2 s += a[2] / 9; a[2] %= 9; if (a[2]){ t = 36 - a[2] * 4; t = push(t,1,t); s++; } // a1 s += a[1] / 36; a[1] %= 36; if (a[1]) s++; cout \u0026amp;lt;\u0026amp;lt; s \u0026amp;lt;\u0026amp;lt; endl; } return 0;  }   \n  ","date":1405680694,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1405680694,"objectID":"3e02cbe019ddeddd08541caff6006591","permalink":"/post/csdn/poj-1017-packets-%E6%82%BC%E5%BF%B5%E6%AD%BB%E5%8E%BB%E7%9A%84%E6%A8%A1%E6%8B%9F/","publishdate":"2014-07-18T18:51:34+08:00","relpermalink":"/post/csdn/poj-1017-packets-%E6%82%BC%E5%BF%B5%E6%AD%BB%E5%8E%BB%E7%9A%84%E6%A8%A1%E6%8B%9F/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目链接 题目很水，纯模拟 麻烦的地方在于，会面临多次用小件填充大件剩余。 最开始觉得不同大小时决策不一样","tags":["POJ","Algorithm","ACM"],"title":"POJ 1017 Packets 悼念死去的模拟","type":"post"},{"authors":null,"categories":["typecho"],"content":"看围棋抢边界: 不愿费劲冒险只能就此game over, 冒险进击才有可能有收获.\n生命便是如此，很多时候我们或懒惰或畏惧，以至于我们没有向前哪怕迈出一步，其结果是我们永永远远地都停留在那个地方。\n有时候，我们鼓起勇气，往前迈出了哪怕一丁点的距离，多年后回首发现，那其实是你人生中至关重要的一大步。\n常人安于故习，学者溺于所闻。\n如是而已。\n共勉。\n","date":1404849060,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1404849060,"objectID":"9da0450a010075f6d8ec2cbd1b88a585","permalink":"/post/typecho/chess_game_over/","publishdate":"2014-07-09T03:51:00+08:00","relpermalink":"/post/typecho/chess_game_over/","section":"post","summary":"看围棋抢边界: 不愿费劲冒险只能就此game over, 冒险进击才有可能有收获. 生命便是如此，很多时候我们或懒惰或畏惧，以至于我们没有向前哪怕迈出一步，","tags":["随想"],"title":"围棋·变·生命","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n 这篇文章有三个标签LXMP``Go``HUSTOJ，在我接管服务器以前，这三个东西我是一个也不知道的，靠着自己的不懈折腾，时隔大半年，收获颇丰。今夜不眠，拿出来聊聊。\nLAMP 这是HUSTOJ的原始架构，我接管服务器的第一件事就是一周内搭好oj，那一周我是在机房没日没夜的呆了几天，终于把我们自己的oj给架起来了。\nLinux 如果真的要找基础，就是大一下蹭在KDE下生活过三个月，后来移居OSX但是敲命令的习惯还是保留了下来。以至于至今没怎么好好的用过Windows！\n在最开始，很多人给我的建议就是鸟哥的私房菜，天哪这么厚一本书我怎么可能几天内看完！所以在最开始的时候其实很简单，需要什么了就去百度就去Google，查不到的就去问各路大神了。由于迁居OSX导致一直没有踏踏实实地下来学习过Linux，导致今日依旧小白一个。\nApache 最早接触这些东西是当年看哈佛的计算机公开课时提到的XAMPP，然后一直用了它很久包括使用Linux时在本地学HTML5依旧用得它。所以在这个时候格外吃力，都是去百度Apache如何修改网站位置``Apache如何添加子域名之类白痴之极的问题，也曾立志去研习Apache配置详解，后来由于你们猜得到的原因就没怎么碰过了。\n在Linux下最喜欢的命令就是apt-get，特别喜欢update和upgrade的感觉。我曾两次upgrade服务器，第一次出现了小问题一个下午搞定了，第二次依旧手贱，结果把HUSTOJ的Judged搞坏了，边被吐槽边修复了两三天（当时正值计算机学院在OJ上做算法作业！）深感无力回天，不得已拿Go重写了Judged。由于积累了数天的重判任务于是就把判题端开到了十进程。。两三天的调试，至今运行良好。\nMySQL 其实对MySQL的熟悉完全是嘴表层最表层的，没有系统学过数据库理论，甚至连SQL语法都没怎么学过，同样是遇到一个问题就去白痴地问一次。开发oj时几乎也都是copy-paste照猫画虎过来的。后来学Go时认识了orm这类东西，从此对SQL再没有去看了。早上看到一篇程序员等级，最低级的被成为CRUD程序员，我估计我连这些都不算够格。\nPHP PHP在这些东西是最早接触的，曾在w3school上看过，但是由于上述知识的匮乏，其实跟没学一样（曾一度去琢磨php和js该学哪个），\n开发oj时真正要用php了那个时候一般我改一句代码oj就会挂一次，经常被问得就是今天oj我怎么上着上着就上不去了过一会又好了！？``你是在作死！！！等等之类的。\n庆幸毕竟是有压力在身上，学对PHP还是学了点。也认识了很多，从语法灵活度来说PHP是多么简单的语言，但是在语法组织上你会觉得这是让人烦到死的东西。由于是Python``Ruby``Go 等极简语法语言的崛起。\nGo 我为什么会走上Go说来完全是打发寂寞，于是我就去网上看世界上有哪些语言，先被python``ruby 这类轻巧的语言所吸引，又因为速度的传言转到了NodeJS，暑假期间蹭用HTML5写过一个游戏，我感觉到了JS在某些方面的力不从心（当然一定是有解的只是感觉不那么优雅）。后来意外看到了Go语言并被它深深地吸引。\n 意外的是我的两个朋友哈工大的光光和电子科大的42大神都开始学Go。回过头看那个时候正是一些东西在国内迅猛发展的时期，Astaxie、UnKnwon等大神开始大力推广Go，MongoDB当时还算最火的，当时SSDB貌似还没出来的说。当时我周围的学长们大多都不知道这是些什么玩意。\n  在那个时候几列火车从我身边高速驶过，我不知道我是否属于这些列车，但是我知道，这些列车都将开往未来。  Nginx 由于某些历史原因使得我成了在很多方面有强迫症的人，很多方面都试图用最好的且不惜成本，浏览器、编辑器、播放器甚至输入法、日历等几乎所有类型的工具我都要做个横向对比找出最顺手的。\n服务器软件也不例外，不知道被谁忽悠了Nginx远远优于Apache。下定决心要进入Nginx的世界，从LNMP的搭建、配置这些基本的学起，到后来需要高级功能时已不再使用Apache，后来学了Go，对pass``rewrite要求多了就再没离开过Nginx了。但是说时候这个环境比LAMP复杂多了大概最开始的几次每次都出小问题，多配几次才可以顺利地搞下来。\nHUSTOJ HUSTOJ的代码写得极其简单随意，像我这种没有软件工程基础的人大概花了不到一天的功夫就搞懂了它的大概框架，改起来自然也是得心应手，越来后来一些问题也越来越明显：\n  代码清晰度有待提高，大框架简单，细节上自然要复杂多了。\n 在做二次开发时每次的思路的很简单，但工作量甚大，譬如user改一个字段，你就得把所有select了user的页面代码全部修改，还得边改边调试。\n   从这几方面来讲随着需求越来越高，一直二次开发下去是个很不明智的做法，所以有必要规划一套适合各种复杂情况的在线编程学习平台。\n庆幸我正好在学Go。\n如果把HUSTOJ分为三块，Web``Judged``Judge_client。前两部分基本已经用Go重写。其中Judged已经在服务器上正常使用半年，目前运行良好。\n最后 之前在做OJ的时候我就考虑一个问题，如果要比做OJ，那我永远做不过杭电，结合自己的教育梦，我希望能一步一步打造一个在线编程教育平台。\n","date":1404273600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1404273600,"objectID":"ed93c40ed901cd174ea8cb852e9fda2b","permalink":"/post/dashayu/1404273600-cs203%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/","publishdate":"2014-07-02T12:00:00+08:00","relpermalink":"/post/dashayu/1404273600-cs203%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 这篇文章有三个标签LXMP``Go``HUSTOJ，在我接管服务器以前，这三个东","tags":null,"title":"cs203的那点事儿","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n 网络服务 查看端口占用\n","date":1404187200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1404187200,"objectID":"7bcdbc0dfa5932d06a5928ab3a50acbe","permalink":"/post/dashayu/1404187200-mac-tips/","publishdate":"2014-07-01T12:00:00+08:00","relpermalink":"/post/dashayu/1404187200-mac-tips/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 网络服务 查看端口占用","tags":null,"title":"Mac - tips","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n 爱生活，爱思考\n兴趣爱好  编程技术  程序设计 服务端开发 前段折腾 嵌入式探索    社交网络  Weibo Facebook Github Coding.net  献丑集 2011  KJO：基于vs2010的OI题库管理系统。这是高一时第一次在无人指导下完成的作品。 《*r*m*ife》：不忍直视的3D动画  2012  康杰中学3D模型：3DsMAX建模学习 坦克大战游戏：HTML5初体验  2013  ArmGo：通过设计程序指令来控制机械臂。基于HTML5，参照cargo-bot [uscoj]()：基于HUSTOJ二次开发的在线评测系统。纯属为了交差 uoj：基于beego的在线程序评测系统，原想重写OJ，结果。。已残废  2014  [博客前段]()：前段练习 ztalk：精简结构却不失强大的论坛系统，主要是为了练习beego，为 xxx 打基础 zqn: 简单好用的七牛Go库  ","date":1404100800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1404100800,"objectID":"99c6bc396ff33beaea3ec7522b6601c8","permalink":"/post/dashayu/1404100800-about-me/","publishdate":"2014-06-30T12:00:00+08:00","relpermalink":"/post/dashayu/1404100800-about-me/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 爱生活，爱思考 兴趣爱好 编程技术 程序设计 服务端开发 前段折腾 嵌入式探索 社交网络 Weibo Facebook Github","tags":null,"title":"About Me","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n 既然来了，就说说为什么来吧。\n今天是个比较兴奋地日子，因为我的新显示器（AOC LV242WEM）终于到了，一下子就喜欢上了新屏幕，敞亮、饱和、逼真、鲜艳，反正就是棒极了！\n稀里糊涂就想试试拿 gor 在 github.io 上搭个博客了，说实话阿里的服务器即将到期没有资本也木有必要去续费。github.io 却看起来可以永存。\n使用几分钟后 从 gor 的使用到github.io，到各种配置，官网都有很详细的说明我就不再赘述了。也可以看我的第一篇\nDISQUS广告 拿到这个博客你首先得干的第一件事应该就是去除评论框该死的广告！在widgets/comments/config.yml里，把short_name改成你自己的，如果没有怎么办？可以选择去建一个（也可以有一个快速去广告的办法就是乱加几个字母，这样首先就没有广告了），建的时候有一大堆对勾要选注意其中有一个发现，果断去掉。然后更新short_name就ok了\n换成多说评论框 多说是在国内用的还算比较多的一个，所以把disqus替换成多说也是个很好的想法，置于怎么替换，下次再说。。\n题外话 MacDown 这是一个看起来特别棒的markdown编辑器，堪比CMD Markdown但是看起来不是偏离Markdown那么离谱。但是只支持Mac平台。\n好了该说说这个博客要干嘛了。由于在github上，所以考虑还是技术为主吧。如果搞得还行，把抽风系列挂过来也不错~\n就这样了，还得睡觉。\n","date":1404100800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1404100800,"objectID":"172f9889fc2365122540446b0e869e6d","permalink":"/post/dashayu/1404100800-hello-gor/","publishdate":"2014-06-30T12:00:00+08:00","relpermalink":"/post/dashayu/1404100800-hello-gor/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 既然来了，就说说为什么来吧。 今天是个比较兴奋地日子，因为我的新显示器（AOC LV","tags":["gor","disqus"],"title":"hello, gor","type":"post"},{"authors":null,"categories":["typecho"],"content":"花了两天时间看完《春秋五霸》《战国七雄》，不同于各种一家之言的是，李山教授尽可能地全面讲述历史，在过程中会把各家观点都摆出来做简单地对比，更加全面、客观地理解这个灿烂的时期。\n人物分类  这里并不是要列出所有人物，只是列出一些性格鲜明的人来简单研究  德才兼备 晋文公、楚庄王、管仲、孙叔敖\n毫无疑问，德才兼备是多么优秀的品质。这类君王可以富国强兵，名垂千古。而这类臣子可以建功立业，更重要的权倾朝野却无人嫉妒。\n相比之下，吴起、商鞅等功业千秋却没落得好下场的人也发人深省。（当然简单的治国跟变法还是有很大的不同，我们应当予以认同）。\n有才无德 赵武灵王、齐闵王、庞涓、魏冉、白起、范雎\n这类人大多争议颇多、褒贬不一。很多时候我们可能更多地有一种遗憾。这类人大多都曾经辉煌一时但最后都没得什么好下场。上述两个君王一个抽筋而死一个被活活饿死不可谓可怜。而这些能臣名将大多都有些自己的脾气，在权倾一时之际忘记自己身份，把个人意志置于国家利益之上最终不得好死，也没落得什么好名声。\n有德少才 齐桓公、宋襄公、秦穆公、魏文侯\n只找出四个君主，不过想想也是，没有本事的人也做不了什么大臣，从这个方面来说，贴上“无才”的标签确实有点刻薄。但是客观的跟有才的君王做对比还是能看出一些不同。最明显的就是对贤人的依赖，比如当齐桓公没了管仲之后，齐国再也折腾不起来了。但是整体而言，这四个君王在整个历史上都算的上是一代明主。\n无德无才 赵括\n就列了这么一个，跟上面的原因类似。没本事的人能一下统兵四十万简直不能再幸运。这种人当政给国家带来的影响算是灾难性的。如果不是后来出了个李牧，可能赵国早都被戎狄给吃掉了。\n随便扯一扯 关于权臣 这个似乎是不可避免的问题：国家统一是个浩大的工程，必然要用贤，而用贤必然要重赏，而重赏必然会直接导致私人势力的崛起，然后就开始闹事，国家要处理这个事情，必然要再用其他的贤，然后再赏···就陷入了死循环。看起来似乎是个必然事件。\n秦国是极少出现这类事件的国家，但是秦国的大多宰相下场都很惨。于是乎让人想到了如果把事情都外包出去，乙方做完了事情就跟甲方没啥关系了，是不是就能避免本土势力的积累。当然用相这里毕竟有一点点像是一个卖方市场，找不到那么多人当宰相。人才哪是随随便便说来就来的。\n最后 附录 这里想列一些相关的东西\n  大秦帝国\n  看的时候做的简单的笔记 春秋五霸 战国七雄\n ","date":1402734540,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1402734540,"objectID":"3cd35df937153c6b2aa5e8d4f99d23cb","permalink":"/post/typecho/cqzg/","publishdate":"2014-06-14T16:29:00+08:00","relpermalink":"/post/typecho/cqzg/","section":"post","summary":"花了两天时间看完《春秋五霸》《战国七雄》，不同于各种一家之言的是，李山教授尽可能地全面讲述历史，在过程中会把各家观点都摆出来做简单地对比，更加全面、客观地理解这个灿烂的时期。\n","tags":["随想","影视"],"title":"百家讲坛《春秋五霸》《战国七雄》感悟","type":"post"},{"authors":null,"categories":["typecho"],"content":"才得知云云关门了。翻到一年前随便写的一篇云云的体验，没有回复。http://t.cn/zTU8GF7\n往常写点东西吐个槽提个建议，多多少少会的得到官方的回复。用户的声音都被无视，很难想象在团队内部是如何对待队友的意见。\n","date":1402057260,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1402057260,"objectID":"d84ebdd11114e2fec6e2bc5043421549","permalink":"/post/typecho/57-%E4%BA%91%E4%BA%91%E4%BA%8C%E4%B8%89/","publishdate":"2014-06-06T20:21:00+08:00","relpermalink":"/post/typecho/57-%E4%BA%91%E4%BA%91%E4%BA%8C%E4%B8%89/","section":"post","summary":"才得知云云关门了。翻到一年前随便写的一篇云云的体验，没有回复。http://t.cn/zTU8GF7 往常写点东西吐个槽提个建议，多多少少会的","tags":["互联网"],"title":"云云二三","type":"post"},{"authors":null,"categories":["typecho"],"content":"以下所有命令基于 ubuntu12.04 系统。centos、rhel 慎重\n系统环境 grub修复 linux改为主引导\n之前装mac时把引导毁掉了，pe只能修复win引导。linux引导还得自己再修复。\nliveCD（我直接用的烧在U盘的ubuntu试用）。\n# fdisk -l # mount /dev/sdaX /mnt # mount /dev/sdaY /mnt/boot #如果有单独boot分区 # grub-install --root-directory=/mnt /dev/sda # init 6 重启之后就ok了～\n过程中出现了warning 。不用管，重启没有问题。\ngrub添加到windows下 主要目的是兼顾mac\n在装linux 的时候，可以把grub安装在linux磁盘/sdaX，然后在win下用easyBCD把grub添加到win下，这样在一个引导下就可以选择三个系统。\n不启动桌面环境 首先在 /etc/default/grub 里添加\n然后 sudo update-grub\n用户相关 添加用户 # useradd\r# adduser #会自动创建目录\r添加 sudoers # vim /etc/sudoers\ruser All=(All) NOPASSWD: ALL\r%admin\tALL=(ALL) NOPASSWD: ALL\r服务器环境 修改主机名/机器名 首选修改 /etc/hostname 和 /etc/hosts 文件对应的机器名\n然后 hostname NAME\n查看端口占用 $ netstat -tunpl\r添加ssh免密码登陆 网上教程一大堆，坑在了权限\nsudo chmod 700 ~/.ssh\rsudo chmod 644 ~/.ssh/authorized_keys\rsudo chmod 600 ~/.ssh/id_rsa.pub\r","date":1401955800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1401955800,"objectID":"f22bd67bf5f6aad6f98d02f531126b6c","permalink":"/post/typecho/19-linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","publishdate":"2014-06-05T16:10:00+08:00","relpermalink":"/post/typecho/19-linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","section":"post","summary":"以下所有命令基于 ubuntu12.04 系统。centos、rhel 慎重\n","tags":["IT技术堆"],"title":"Linux学习笔记","type":"post"},{"authors":null,"categories":["typecho"],"content":"突然想到一条为什么fb衰落的如此之快的原因？暂且跟 Google 比一下，google 起家靠的是技术，fb 起家考的是产品形态；google 的核心竞争力是信息交流，是刚需，fb 的核心竞争力是吐槽场所，弹性很大。玩的是新颖，如果不时时刻刻去调整，很容易被大众抛弃\n","date":1401839880,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1401839880,"objectID":"f440fc101e84fb14b5c5b0e86158dcdd","permalink":"/post/typecho/f_b_g_o_o_g_l_e/","publishdate":"2014-06-04T07:58:00+08:00","relpermalink":"/post/typecho/f_b_g_o_o_g_l_e/","section":"post","summary":"突然想到一条为什么fb衰落的如此之快的原因？暂且跟 Google 比一下，google 起家靠的是技术，fb 起家考的是产品形态；google 的核心竞争力是信","tags":["互联网","tweet"],"title":"fbvsGg","type":"post"},{"authors":null,"categories":["typecho"],"content":"团购的立足点到底是帮用户省钱还是帮商家处理产能过剩？http://t.cn/RvIHX26\n","date":1401837300,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1401837300,"objectID":"0b87591f626b7e60ee829f748872290a","permalink":"/post/typecho/meituan/","publishdate":"2014-06-04T07:15:00+08:00","relpermalink":"/post/typecho/meituan/","section":"post","summary":"团购的立足点到底是帮用户省钱还是帮商家处理产能过剩？http://t.cn/RvIHX26","tags":["互联网","我的微博","tweet"],"title":"团购何来","type":"post"},{"authors":null,"categories":["typecho"],"content":"十多年前互联网兴起的时候，这个炒那个炒，然后炒出了一堆泡沫。十年过去，移动互联网兴起，浮躁的90后们也按耐不住了。随便翻开一家科技媒体，都有一大堆两千年前就有了的“新概念”，每个新概念之后都是一大波创业浪潮。\n","date":1397087940,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1397087940,"objectID":"680fa7f310677c3c0b710e7c756c7ef0","permalink":"/post/typecho/paomo/","publishdate":"2014-04-10T07:59:00+08:00","relpermalink":"/post/typecho/paomo/","section":"post","summary":"十多年前互联网兴起的时候，这个炒那个炒，然后炒出了一堆泡沫。十年过去，移动互联网兴起，浮躁的90后们也按耐不住了。随便翻开一家科技媒体，都有","tags":["互联网","我的微博","tweet"],"title":"泡沫","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  以 CL1588BS 8*8点阵 为例  引脚说明   这个家伙有上下两排共16个引脚，每个引脚负责一行（或一列的信号）。 当 行为高电平 列为低电平 时灯会亮。( r[x] == 1 \u0026amp;\u0026amp; c[y] == 0 ) 在网上找到了一个对应行列图，铭牌朝自己。      点亮一个灯  思路很简单，就是把行列输出对应的电平， 注意一下初始状态，如果我要点亮 L(x,y)，那么第 x 行其它列必须初始化为 HIGH 电平，不然整个x 行都会亮。  代码大概是这个样子（因为只是学习，所以我只用了中间4*4的区域） const int _r = 3, // 行偏移 _c = 8, // 列偏移 Fr = 100 // 频率 ; void setup() { for ( int i(_r); i \u0026lt;= 12; i++) pinMode(i, OUTPUT); flash(); }\nvoid flash(){ for ( int i(1 + _r); i \u0026lt;= 4 + _r; i++) digitalWrite(i, LOW); for ( int i(1 + _c); i \u0026lt;= 4 + _c; i++) digitalWrite(i, HIGH); }\nvoid echo(int i, int j) { flash(); digitalWrite(i + _r, HIGH); digitalWrite(j + _c, LOW); delay(Fr); }\nvoid loop() { for ( int i(1); i \u0026lt;= 4; i++){ for (int j(1); j \u0026lt;= 4; j++){ echo(i, j); } } }   这个代码会按照行列依次点亮每个灯。\n  点亮多个灯  对于点亮一行灯而言，没有难度。 当要点亮夸行列的灯时，     ","date":1396876439,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1396876439,"objectID":"6aa10bfcec7d623894fb927397814311","permalink":"/post/csdn/led%E7%82%B9%E9%98%B5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8E%A2%E7%B4%A2/","publishdate":"2014-04-07T21:13:59+08:00","relpermalink":"/post/csdn/led%E7%82%B9%E9%98%B5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8E%A2%E7%B4%A2/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 以 CL1588BS 8*8点阵 为例 引脚说明 这个家伙有上下两排共16个引脚，每个引脚负责一行（或一列的信号）。 当 行为高","tags":["LED"],"title":"LED点阵的基本操作探索","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目传送门     网络流模版题，本想水一水，莫想到因为没好好看题给跪了。    题目大意就是 给你一堆水洼地，还有一些水沟，最终让水洼里的水通过水沟流入溪流。  要留意的就是据说会有重边，需要额外处理。（第二次练习 DInic 时发现完全不需要）    再就是要看清题意 “ For any given ditch, water flows in only one direction ” 就是说是有向图，读题的时候专门留意了可是做题的时候却记了个无向图还专门加了个反向。结果坑了半个多小时。。WA了好几次。。深刻检讨！    写了两个代码，虽然都是零毫秒，不过要学习嘛。。  第一种是最简单的寻找增广路 Ford-Fulkerson 算法  #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #define INF 1\u0026lt;\u0026lt;30 #define N 222 using namespace std; struct EDGE { int to, cap, rev; };\nvector\u0026lt;EDGE\u0026gt; g[N]; int ff[N][N]; bool used[N]; int n,m;\nint dfs(int v,int t,int f){ if ( v == t ) return f; used[v]= true; for ( int i(0); i \u0026lt; g[v].size(); i++){ EDGE \u0026amp;e = g[v][i]; if ( !used[e.to] \u0026amp;\u0026amp; e.cap \u0026gt; 0){ int d = dfs(e.to, t, min(f,e.cap)); if ( d \u0026gt; 0){ e.cap -= d; g[e.to][e.rev].cap += d; return d; } } } return 0; }\nint max_flow(int s,int t){ int flow = 0; while (1){ memset(used,0,sizeof(used)); int f = dfs(s,t,INF); if (f) flow += f; else return flow; } }\nvoid add_edge(int from, int to, int cap){ g[from].push_back((EDGE){to,cap,g[to].size()}); g[to].push_back((EDGE){from,0,g[from].size()-1}); }\nint main(){ freopen(\u0026ldquo;in.txt\u0026rdquo;,\u0026ldquo;r\u0026rdquo;,stdin); while ( ~scanf(\u0026quot;%d%d\u0026rdquo;,\u0026amp;m,\u0026amp;n)){ for ( int i(0);i\u0026lt;N;i++) g[i].clear(); memset(ff,0,sizeof(ff)); while ( m\u0026ndash; ){ int from,to,cap; scanf(\u0026quot;%d%d%d\u0026rdquo;,\u0026amp;from,\u0026amp;to,\u0026amp;cap); ff[from][to] += cap; } for ( int i(1);i\u0026lt;=n;i++){ for ( int j(1); j\u0026lt;=n;j++){ if ( ff[i][j] ){ add_edge(i,j,ff[i][j]); } } } printf(\u0026quot;%d\\n\u0026rdquo;,max_flow(1,n)); } return 0; }\n   第二种是优化后的 Dinic 算法，方法是 对整个图加了一个分层，每次只找最短的增广路，找不到就一层一层下去。原书《挑战程序设计竞赛（巫泽俊 译）》里还有个 iter[] 表示当前弧，不过没看到用。所以我就擅自去掉了。  #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #define N 222 #define INF 1\u0026lt;\u0026lt;30 using namespace std; struct EDGE{ int to, cap, rev; }; vector\u0026lt;EDGE\u0026gt; g[N]; queue\u0026lt;int\u0026gt; que; int dist[N]; int n, m;\nvoid add_edge(int from, int to, int cap){ g[from].push_back((EDGE){to, cap, g[to].size()}); g[to].push_back((EDGE){from, 0, g[from].size() - 1}); }\nvoid bfs(int s){ memset(dist, -1, sizeof(dist)); while ( !que.empty() ) que.pop(); dist[s] = 0; que.push(s); while (!que.empty()){ int v = que.front(); que.pop(); for ( int i(0); i != g[v].size(); i++){ EDGE \u0026amp;e = g[v][i]; if ( e.cap \u0026gt; 0 \u0026amp;\u0026amp; dist[e.to] \u0026lt; 0){ dist[e.to] = dist[v] + 1; que.push(e.to); } } } }\nint dfs(int v, int t, int f){ if ( v == t ) return f; for ( int i(0); i != g[v].size(); i++){ EDGE \u0026amp;e = g[v][i]; if ( e.cap \u0026gt; 0 \u0026amp;\u0026amp; dist[e.to] \u0026gt; dist[v]){ int d = dfs(e.to, t, min(f, e.cap)); if ( d \u0026gt; 0){ e.cap -= d; g[e.to][e.rev].cap += d; return d; } } } return 0; }\nint Dinic(int s, int t){ int flow = 0; while (1){ bfs(s); if (dist[t] \u0026lt; 0) return flow; int f; while ((f = dfs(s, t, INF)) \u0026gt; 0) flow += f; } }\nint main(){ freopen(\u0026ldquo;in.txt\u0026rdquo;, \u0026ldquo;r\u0026rdquo;, stdin); while ( ~scanf(\u0026quot;%d%d\u0026rdquo;, \u0026amp;m, \u0026amp;n)){\n for ( int i(0); i \u0026amp;lt; N; i++) g[i].clear(); memset(ff,0,sizeof(ff)); while (m--){ int from, to, cap; scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;amp;from, \u0026amp;amp;to, \u0026amp;amp;cap); add_edge(from,to,cap); } printf(\u0026quot;%d\\n\u0026quot;, Dinic(1, n)); } return 0;  }    \n   ","date":1396450665,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1396450665,"objectID":"64279ba0bff005642de18ed5cb26e513","permalink":"/post/csdn/poj-1273-drainage-ditches-%E7%BD%91%E7%BB%9C%E6%B5%81%E6%A8%A1%E7%89%88/","publishdate":"2014-04-02T22:57:45+08:00","relpermalink":"/post/csdn/poj-1273-drainage-ditches-%E7%BD%91%E7%BB%9C%E6%B5%81%E6%A8%A1%E7%89%88/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目传送门 网络流模版题，本想水一水，莫想到因为没好好看题给跪了。 题目大意就是 给你一堆水洼地，还有一些","tags":["POJ","Algorithm","ACM"],"title":"POJ 1273 Drainage Ditches 网络流模版","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目链接   一天时间做了两道 dfs序 的题， 都是 WA 不停，最后一道改成 100W的数组，一道改成双向边就AC了。。能不能再坑一点的。。    好，继续说这道题。。  上一道题苹果树是统计叶子节点的和，这道题是统计叶子节点中比自己权值小的和    思路   首先按照上一道题的惯性思路，会觉得很复杂。因为再算和的时候要额外判断一下大小。由于树状数组是预处理的，显然无法再单独判断，于是就不知如何是好。  后来想到，能不能在 dfs 中记录一下比自己小的数。    如何统计？  第一会想到 DP 一样的东西，如果比子节点大，直接加上，如果小的话，貌似跪了。。。  突然想到以前有过一次 在树状数组的建树过程中动态维护区间和，觉得可以试试。  于是就有了这样的算法：    在dfs过程中，第一次（也是唯一一次）碰到一个点 v 时， visit[i] = 1. 此时，pre[v] = visit[0,v) 的和也就是比v小的数的个数！因为 dfs序的性质，现在计算的和是不含它的子节点的，当一个点dfs过后，再计算一下s = visit[0,v) 的和，它表示的便是包含子节点在内的所有比 v 小的点的和。因为dfs序的性质，s[v]-pre[v] 便是子节点中比自己小的点的权值的和。  有木有发现，其实连进出的时间戳都没有记录！只是在进出栈时就把ans计算出来了。    另外比较坑的就是如果用 递归写法会耗费很多堆栈，不得已改用非递归写法。    上代码：   #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #define N 201010 using namespace std; stack\u0026lt;int\u0026gt; st; struct NODE { int v,next; } a[N],e[N]; int tr[N],pre[N],s[N],b[N]; int n,em,root,tt;\nvoid update(int x) { while ( x\u0026lt;=n) { tr[x] += 1; x += x \u0026amp; -x; } }\nint gs(int x) { int s = 0; while (x\u0026gt;0) { s += tr[x]; x -= x \u0026amp; -x; } return s; }\nvoid joint(int a1,int a2){ e[++em].v = a2; e[em].next = a[a1].next; a[a1].next = em; }\nint main() { while ( ~scanf(\u0026quot;%d%d\u0026rdquo;,\u0026amp;n,\u0026amp;root)) { if ( !n \u0026amp;\u0026amp; !root ) break; for ( int i(1); i\u0026lt;=n; i++) tr[i] = a[i].next = b[i] = pre[i]= 0; em = 0; tt = 0;\n for ( int i(1); i\u0026amp;lt;n; i++) { int a1,a2; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;amp;a1,\u0026amp;amp;a2); joint(a1,a2); joint(a2,a1); } while (!st.empty()) st.pop(); // dfs st.push(root); while (!st.empty()) { int v = st.top(); if ( !b[v] ){ b[v] = 1; pre[v] = gs(v); update(v); for ( int p(a[v].next); p; p=e[p].next) { if ( !b[e[p].v] ) { int u = e[p].v; st.push(u); } } } if ( st.top() == v ) { s[v] = gs(v-1) - pre[v]; st.pop(); } } for ( int i(1); i\u0026amp;lt;n; i++) printf(\u0026quot;%d \u0026quot;,s[i]); printf(\u0026quot;%d\\n\u0026quot;,s[n]); } return 0;  }   \n      ","date":1396274398,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1396274398,"objectID":"cc9b9be920c8b3a8ff6d463e10ea4bf2","permalink":"/post/csdn/hdu-3887-counting-offspring-dfs%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8-%E9%9D%9E%E9%80%92%E5%BD%92/","publishdate":"2014-03-31T21:59:58+08:00","relpermalink":"/post/csdn/hdu-3887-counting-offspring-dfs%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8-%E9%9D%9E%E9%80%92%E5%BD%92/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目链接 一天时间做了两道 dfs序 的题， 都是 WA 不停，最后一道改成 100W的数组，一道改成双向边就AC了","tags":["HDU"],"title":"HDU 3887 Counting Offspring dfs序的运用 | 非递归","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目链接   dfs序 说来很简单，却从来没有想到过。必须得深刻反省一下到底自己学了些啥。    题目大意是给你一棵树，动态统计某个子树的节点权值和。  同上一道题，裸算法。     利用dfs把一个树应设在一个序列上，方法是对每一次进栈出栈加一个时间戳，在这之间的点都是它的子节点。  然后就变成了动态统计区间和的问题了，  据说线段树会超。。  但是这种简单的求和问题，树状数组绝对是不二之选，用不着去折腾线段树了。    #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #define N 210100 struct NODE { int v,next; } a[N],st[N]; int h[N],t[N],P1[N],P2[N]; int tt,n,m,stn; void dfs(int v) { P1[v]=++tt; for ( int p = a[v].next; p; p=st[p].next ) dfs(st[p].v); P2[v]=tt; return; }\ninline int l(int i) { return i \u0026amp; -i; }\nvoid update(int x,int k) { while (x\u0026lt;=n) { t[x] += k; x += l(x); } }\nint gs(int x) { int s =0; while ( x) { s += t[x]; x -= l(x); } return s; }\nint main() { scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;n); for ( int i(1); i\u0026lt;n; i++) { int a1,a2; scanf(\u0026quot;%d%d\u0026rdquo;,\u0026amp;a1,\u0026amp;a2); st[++stn].v = a2; st[stn].next = a[a1].next; a[a1].next = stn; } dfs(1); for ( int i(1); i\u0026lt;=n; i++) h[i]=1,update(P1[i],1); for ( scanf(\u0026quot;%d\\n\u0026rdquo;,\u0026amp;m); m\u0026ndash;;) { char ch; int x; scanf(\u0026quot;%c%d\\n\u0026rdquo;,\u0026amp;ch,\u0026amp;x); if ( ch == \u0026lsquo;C\u0026rsquo; ) { if ( h[x] ) update(P1[x],-1); else update(P1[x],1); h[x] = 1-h[x]; } else printf(\u0026quot;%d\\n\u0026rdquo;,gs(P2[x])-gs(P1[x]-1)); } return 0; }   \n   ","date":1396230984,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1396230984,"objectID":"437a4343afa44eec54b5fa2146be74eb","permalink":"/post/csdn/poj-3321-apple-tree-dfs%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8/","publishdate":"2014-03-31T09:56:24+08:00","relpermalink":"/post/csdn/poj-3321-apple-tree-dfs%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目链接 dfs序 说来很简单，却从来没有想到过。必须得深刻反省一下到底自己学了些啥。 题目大意是给你一棵","tags":["POJ","Algorithm","ACM"],"title":"POJ 3321 Apple Tree dfs序的应用","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目链接   题目很长，其实就是字符串匹配。  所以，权当练习 KMP  #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #define MB 10101 #define MA 1000100 char a[MA],b[MB]; int next[MB]; void prekmp(char* b) { next[0]=-1; int j=-1; for ( int i(1); b[i]; i++) { while ( j!=-1 \u0026amp;\u0026amp; b[i]!=b[j+1]) j=next[j]; if ( b[i]==b[j+1] ) j++; next[i]=j; } }\nint kmp(char *a,char *b) { int j=-1,ans=0; for ( int i(0); a[i]; i++) { while ( j!=-1 \u0026amp;\u0026amp; a[i]!=b[j+1] ) j=next[j]; if (a[i]==b[j+1]) j++; if (!b[j+1]) { ans++; j=next[j]; } } return ans; }\nint main() { int T; freopen(\u0026ldquo;in.txt\u0026rdquo;,\u0026ldquo;r\u0026rdquo;,stdin); for (scanf(\u0026quot;%d\\n\u0026rdquo;,\u0026amp;T); T\u0026ndash;;) { scanf(\u0026quot;%s\\n%s\\n\u0026rdquo;,b,a); memset(next,0,sizeof(0)); prekmp(b); printf(\u0026quot;%d\\n\u0026rdquo;,kmp(a,b)); } return 0; }   \n     ","date":1396229687,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1396229687,"objectID":"7e614614984dec566dd670ce41c31b9a","permalink":"/post/csdn/poj-3461-oulipo-kmp%E7%BB%83%E4%B9%A0/","publishdate":"2014-03-31T09:34:47+08:00","relpermalink":"/post/csdn/poj-3461-oulipo-kmp%E7%BB%83%E4%B9%A0/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目链接 题目很长，其实就是字符串匹配。 所以，权当练习 KMP #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #define MB 10101 #define MA 1000100 char a[MA],b[MB]; int next[MB]; void prekmp(char* b) { next[0]=-1; int j=-1; for (","tags":["POJ","Algorithm","ACM"],"title":"POJ 3461 Oulipo KMP练习","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  原文链接   如果你是一名前端er,又想在移动设备上开发出自己的应用，那怎么实现呢？幸好，webkit内核的浏览器能帮助我们完成这一切。接触 webkit webApp的开发已经有一段时间了，现把一些技巧分享给大家 ：1. viewport：也就是可视区域。对于桌面浏览器，我们都很清楚viewport是什么，就是出去了所有工具栏、状态栏、滚动条等等之后用于看网页的区域，这是真正有效的区域。由于移动设备屏幕宽度不同于传统web,因此我们需要改变viewport;实际上我们可以操作的属性有4 个：  width - // viewport 的宽度 （范围从200 到10,000，默认为980 像素） height - // viewport 的高度 （范围从223 到10,000） initial-scale - // 初始的缩放比例 （范围从\u0026gt;0 到10）\nminimum-scale - // 允许用户缩放到的最小比例 maximum-scale - // 允许用户缩放到的最大比例\nuser-scalable - // 用户是否可以手动缩 (no,yes) \n   那么到底这些设置如何让Safari 知道？其实很简单，就一个meta，形如：  \u0026lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"\u0026gt; //编码 \u0026lt;meta id=\"viewport\" name=\"viewport\" content=\"width=320; initial-scale=1.0;maximum-scale=1.0; user-scalable=no;\"/\u0026gt; \u0026lt;meta name=”apple-mobile-web-app-capable” content=”yes” /\u0026gt; // 离线应用的另一个技巧 \u0026lt;meta name=”apple-mobile-web-app-status-bar-style” content=black” /\u0026gt; // 隐藏状态栏 \u0026lt;meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\" /\u0026gt; //指定的iphone中safari顶端的状态条的样式 \u0026lt;meta content=\"telephone=no\" name=\"format-detection\" /\u0026gt; //告诉设备忽略将页面中的数字识别为电话号码 \u0026lt;meta name=\"Author\" contect=\"Mr.He\"/ \u0026gt;   在设置了initial-scale=1 之后，我们终于可以以1:1 的比例进行页面设计了。关于viewport，还有一个很重要的概念是：iphone 的safari 浏览器完全没有滚动条，而且不是简单的“隐藏滚动条”，是根本没有这个功能。iphone 的safari 浏览器实际上从一开始就完整显示了这个网页，然后用viewport 查看其中的一部分。当你用手指拖动时，其实拖的不是页面，而是viewport。浏览器行为的改变不止是滚动条，交互事件也跟普通桌面不一样。(请参考：指尖的下JS 系列文章)     2. link:  \u0026lt;link rel=”apple-touch-startup-image” href=”startup.png” /\u0026gt; // 设置开始页面图片 \u0026lt;link rel=”apple-touch-icon” href=”iphon_tetris_icon.png”/\u0026gt; // 在设置书签的时候可以显示好看的图标 \u0026lt;link rel=\"stylesheet\" media=\"all and (orientation:portrait)\" href=\"portrait.css\"\u0026gt; // 肖像模式样式 \u0026lt;link rel=\"stylesheet\" media=\"all and (orientation:landscape)\" href=\"landscape.css\" // 风景模式样式 //竖屏时使用的样式 \u0026lt;style media=\u0026quot;all and (orientation:portrait)\u0026rdquo; type=\u0026quot;text/css\u0026rdquo;\u0026gt; #landscape { display: none; } \u0026lt;/style\u0026gt;\n//横屏时使用的样式 \u0026lt;style media=\u0026quot;all and (orientation:landscape)\u0026rdquo; type=\u0026quot;text/css\u0026rdquo;\u0026gt; #portrait { display: none; } \u0026lt;/style\u0026gt;   \n 3. 事件 ： (请参考：指尖的下JS 系列文章)   // 手势事件 touchstart //当手指接触屏幕时触发 touchmove //当已经接触屏幕的手指开始移动后触发 touchend //当手指离开屏幕时触发 touchcancel // 触摸事件 gesturestart //当两个手指接触屏幕时触发 gesturechange //当两个手指接触屏幕后开始移动时触发 gestureend\n// 屏幕旋转事件\nonorientationchange\n// 检测触摸屏幕的手指何时改变方向 orientationchange\n// touch事件支持的相关属性 touches targetTouches changedTouches clientX　// X coordinate of touch relative to the viewport (excludes scroll offset) clientY　// Y coordinate of touch relative to the viewport (excludes scroll offset) screenX　// Relative to the screen screenY // Relative to the screen pageX　// Relative to the full page (includes scrolling) pageY　// Relative to the full page (includes scrolling) target　// Node the touch event originated from identifier　// An identifying number, unique to each touch event  4. 屏幕旋转事件：onorientationchange  添加屏幕旋转事件侦听，可随时发现屏幕旋转状态（左旋、右旋还是没旋）。例子：  \n// 判断屏幕是否旋转 function orientationChange() { switch(window.orientation) { case 0: alert(\"肖像模式 0,screen-width: \" + screen.width + \"; screen-height:\" + screen.height); break; case -90: alert(\"左旋 -90,screen-width: \" + screen.width + \"; screen-height:\" + screen.height); break; case 90: alert(\"右旋 90,screen-width: \" + screen.width + \"; screen-height:\" + screen.height); break; case 180: alert(\"风景模式 180,screen-width: \" + screen.width + \"; screen-height:\" + screen.height); break; };\u0026lt;br\u0026gt;}; // 添加事件监听 addEventListener('load', function(){ orientationChange(); window.onorientationchange = orientationChange; });  5. 隐藏地址栏 \u0026amp; 处理事件的时候，防止滚动条出现：   // 隐藏地址栏 \u0026amp; 处理事件的时候 ，防止滚动条出现 addEventListener('load', function(){ setTimeout(function(){ window.scrollTo(0, 1); }, 100); });  6. 双手指滑动事件：\n// 双手指滑动事件 addEventListener('load',　function(){ window.onmousewheel = twoFingerScroll;}, false // 兼容各浏览器，表示在冒泡阶段调用事件处理程序 (true 捕获阶段) ); function twoFingerScroll(ev) { var delta =ev.wheelDelta/120; //对 delta 值进行判断(比如正负) ，而后执行相应操作 return true; };   7. 判断是否为iPhone：  // 判断是否为 iPhone ： function isAppleMobile() { return (navigator.platform.indexOf('iPad') != -1); };     8. localStorage:  例子 ：（注意数据名称 n 要用引号引起来）    var v = localStorage.getItem('n') ? localStorage.getItem('n') : \"\"; // 如果名称是 n 的数据存在 ，则将其读出 ，赋予变量 v 。  localStorage.setItem('n', v); // 写入名称为 n、值为 v 的数据  localStorage.removeItem('n'); // 删除名称为 n 的数据    9. 使用特殊链接：  如果你关闭自动识别后 ，又希望某些电话号码能够链接到 iPhone 的拨号功能 ，那么可以通过这样来声明电话链接 ,    \u0026lt;a href=\"tel:12345654321\"\u0026gt;打电话给我\u0026lt;/a\u0026gt;  \u0026lt;a href=\"sms:12345654321\"\u0026gt;发短信\u0026lt;/a\u0026gt;  或用于单元格：  \u0026lt;td onclick=\"location.href='tel:122'\"\u0026gt;    10. 自动大写与自动修正  要关闭这两项功能，可以通过autocapitalize 与autocorrect 这两个选项：    \u0026lt;input type=\"text\" autocapitalize=\"off\" autocorrect=\"off\" /\u0026gt;    11. WebKit CSS:  ①“盒模型”的具体描述性质的包围盒块内容，包括边界，填充等等。    -webkit-border-bottom-left-radius: radius;  -webkit-border-top-left-radius: horizontal_radius vertical_radius;  -webkit-border-radius: radius; //容器圆角  -webkit-box-sizing: sizing_model; 边框常量值：border-box/content-box  -webkit-box-shadow: hoff voff blur color; //容器阴影（参数分别为：水平X 方向偏移量；垂直Y 方向偏移量；高斯模糊半径值；阴影颜色值）  -webkit-margin-bottom-collapse: collapse_behavior; 常量值：collapse/discard/separate  -webkit-margin-start: width;  -webkit-padding-start: width;  -webkit-border-image: url(borderimg.gif) 25 25 25 25 round/stretch round/stretch;  -webkit-appearance: push-button; //内置的CSS 表现，暂时只支持push-button  ②“视觉格式化模型”描述性质，确定了位置和大小的块元素。    direction: rtl  unicode-bidi: bidi-override; 常量：bidi-override/embed/normal  ③“视觉效果”描述属性，调整的视觉效果块内容，包括溢出行为，调整行为，能见度，动画，变换，和过渡。    clip: rect(10px, 5px, 10px, 5px)  resize: auto; 常量：auto/both/horizontal/none/vertical  visibility: visible; 常量: collapse/hidden/visible  -webkit-transition: opacity 1s linear; 动画效果 ease/linear/ease-in/ease-out/ease-in-out  -webkit-backface-visibility: visibler; 常量：visible(默认值)/hidden  -webkit-box-reflect: right 1px; 镜向反转  -webkit-box-reflect: below 4px -webkit-gradient(linear, left top, left bottom,  from(transparent), color-stop(0.5, transparent), to(white));  -webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)));; //CSS 遮罩/蒙板效果  -webkit-mask-attachment: fixed; 常量：fixed/scroll  -webkit-perspective: value; 常量：none(默认)  -webkit-perspective-origin: left top;  -webkit-transform: rotate(5deg);  -webkit-transform-style: preserve-3d; 常量：flat/preserve-3d; (2D 与3D)  ④“生成的内容，自动编号，并列出”描述属性，允许您更改内容的一个组成部分，创建自动编号的章节和标题，和操纵的风格清单的内容。    content: “Item” counter(section) ” “;  This resets the counter.  First section  \u0026gt;two section  three section  counter-increment: section 1;  counter-reset: section;  ⑤“分页媒体”描述性能与外观的属性，控制印刷版本的网页，如分页符的行为。    page-break-after: auto; 常量：always/auto/avoid/left/right  page-break-before: auto; 常量：always/auto/avoid/left/right  page-break-inside: auto; 常量：auto/avoid  ⑥“颜色和背景”描述属性控制背景下的块级元素和颜色的文本内容的组成部分。    -webkit-background-clip: content; 常量：border/content/padding/text  -webkit-background-origin: padding; 常量：border/content/padding/text  -webkit-background-size: 55px; 常量：length/length_x/length_y  ⑦ “字型”的具体描述性质的文字字体的选择范围内的一个因素。报告还描述属性用于下载字体定义。    unicode-range: U+00-FF, U+980-9FF;  ⑧“文本”描述属性的特定文字样式，间距和自动滚屏。    text-shadow: #00FFFC 10px 10px 5px;  text-transform: capitalize; 常量：capitalize/lowercase/none/uppercase  word-wrap: break-word; 常量：break-word/normal  -webkit-marquee: right large infinite normal 10s; 常量：direction(方向) increment(迭代次数) repetition(重复) style(样式) speed(速度);  -webkit-marquee-direction: ahead/auto/backwards/down/forwards/left/reverse/right/up  -webkit-marquee-incrementt: 1-n/infinite(无穷次)  -webkit-marquee-speed: fast/normal/slow  -webkit-marquee-style: alternate/none/scroll/slide  -webkit-text-fill-color: #ff6600; 常量：capitalize, lowercase, none, uppercase  -webkit-text-security: circle; 常量：circle/disc/none/square  -webkit-text-size-adjust: none; 常量:auto/none;  -webkit-text-stroke: 15px #fff;  -webkit-line-break: after-white-space; 常量：normal/after-white-space  -webkit-appearance: caps-lock-indicator;  -webkit-nbsp-mode: space; 常量： normal/space  -webkit-rtl-ordering: logical; 常量：visual/logical  -webkit-user-drag: element; 常量：element/auto/none  -webkit-user-modify: read- only; 常量：read-write-plaintext-only/read-write/read-only  -webkit-user-select: text; 常量：text/auto/none  ⑨“表格”描述的布局和设计性能表的具体内容。    -webkit-border-horizontal-spacing: 2px;  -webkit-border-vertical-spacing: 2px;  -webkit-column-break-after: right; 常量：always/auto/avoid/left/right  -webkit-column-break-before: right; 常量：always/auto/avoid/left/right  –webkit-column-break-inside: logical; 常量：avoid/auto  -webkit-column-count: 3; //分栏  -webkit-column-rule: 1px solid #fff;  style:dashed,dotted,double,groove,hidden,inset,none,outset,ridge,solid  ⑩“用户界面”描述属性，涉及到用户界面元素在浏览器中，如滚动文字区，滚动条，等等。报告还描述属性，范围以外的网页内容，如光标的标注样式和显示当您按住触摸触摸  目标，如在iPhone上的链接。    -webkit-box-align: baseline,center,end,start,stretch 常量：baseline/center/end/start/stretch  -webkit-box-direction: normal;常量：normal/reverse  -webkit-box-flex: flex_valuet  -webkit-box-flex-group: group_number  -webkit-box-lines: multiple; 常量：multiple/single  -webkit-box-ordinal-group: group_number  -webkit-box-orient: block-axis; 常量：block-axis/horizontal/inline-axis/vertical/orientation  –webkit-box-pack: alignment; 常量：center/end/justify/start    12. 动画过渡  这是 Webkit 中最具创新力的特性：使用过渡函数定义动画。    -webkit-animation: title infinite ease-in-out 3s;  animation 有这几个属性：  -webkit-animation-name： //属性名，就是我们定义的keyframes  -webkit-animation-duration：3s //持续时间  -webkit-animation-timing-function： //过渡类型：ease/ linear(线性) /ease-in(慢到快)/ease-out(快到慢) /ease-in-out(慢到快再到慢) /cubic-bezier  -webkit-animation-delay：10ms //动画延迟(默认0)  -webkit-animation-iteration-count： //循环次数(默认1)，infinite 为无限  -webkit-animation-direction： //动画方式：normal(默认 正向播放)； alternate(交替方向，第偶数次正向播放，第奇数次反向播放)  这些同样是可以简写的。但真正让我觉的很爽的是keyframes，它能定义一个动画的转变过程供调用，过程为0%到100%或from(0%)到to(100%)。简单点说，只要你有想法，你想让元素在这个过程中以什么样的方式改变都是很简单的。    -webkit-transform: 类型（缩放scale/旋转rotate/倾斜skew/位移translate）  scale(num,num) 放大倍率。scaleX 和 scaleY(3)，可以简写为：scale(* , *)  rotate(*deg) 转动角度。rotateX 和 rotateY，可以简写为：rotate(* , *)  Skew(*deg) 倾斜角度。skewX 和skewY，可简写为：skew(* , *)  translate(*,*) 坐标移动。translateX 和translateY，可简写为：translate(* , *)。  实现模拟弹出消息框（Alert）的例子：  ①定义过渡（在\u0026lt;style type=\"text/css\"\u0026gt;段中描述keyframes）：    @-webkit-keyframes DivZoom  {  0% { -webkit-transform: scale(0.01) }  60% { -webkit-transform: scale(1.05) }  80% { -webkit-transform: scale(0.95) }  100% { -webkit-transform: scale(1.00) }  }  .sZoom { -webkit-animation: DivZoom 0.5s ease-in-out }  （很容易看懂，将元素从缩小的0.01 倍--很小但不能为0 倍，放大到1.05 倍，再缩小到0.95倍，最后到1 倍即正常大小。整个过渡过程事件为0.5 秒，动画方式为ease-in-out，即慢到快再到慢，默认只进行1 次过渡。这正是大家经常看到的 iPhone 弹出的提示信息的动画效果！）  ②定义元素（在\u0026lt;body\u0026gt;段中）：    \u0026lt;div id=\"layerH\" style=\"-webkit-border-radius:12px; border:2px solid #FFF;-webkit-box-shadow: 0px 2px 4px #888;position: absolute; left: 24px; top: 106px;  width: 256px; height: 268px; padding-left: 8px; padding-right: 8px;color: #FFFFFF; text-shadow: 1px 1px 1px #000; text-align: center;background-color: RGBA(32,48,96,0.9);  background-image:url('BG-Msg.png'); background-repeat:no-repeat;  z-index: 1; visibility: hidden; \"\u0026gt;  \u0026lt;p\u0026gt;\u0026lt;span style=\"font-size: 16pt; font-weight: bold\"\u0026gt;使用说明\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt;  \u0026lt;hr noshade size=\"1\"\u0026gt;  \u0026lt;div id=\"HelpText\" style=\"height: 120px\"\u0026gt;说明文字\u0026lt;/div\u0026gt;  \u0026lt;hr noshade size=\"1\"\u0026gt;  \u0026lt;form name=\"formV\" method=\"POST\"\u0026gt;  \u0026lt;input type=\"button\" value=\"确认\" name=\"B1\"  style=\"width: 100%; height: 40px; font-size: 14pt; ont-weight: bold;  color: #FFFFFF; text-shadow: 0px -1px 1px #000;\"  onclick=\" layerH.style.visibility='hidden'\"\u0026gt;  \u0026lt;/form\u0026gt;  \u0026lt;/div\u0026gt;  ③启动动画（在 javascript 定义的函数中）    function pHelp()  {  layerH.style.visibility = 'visible'  layerH.style.cssText = \"-webkit-animation-delay: \" + Math.random() + \"ms\"  layerH.className = 'sZoom'  }  (这个启动函数就很好理解了。但是为什么要使用-webkit-animation-delay 这句呢？因为当一个元素过渡显示完成后，若其样式没有变化，下一次将无法进行过渡动画显示。我们巧妙的利用其动画延迟时间定义，使其有所变化，就避免了上述问题。其中使用随机数函数Math.random()，产生一个大于0 小于1 的随机数。当然，延迟零点几毫秒，用户是不会察觉的。)    补充：  1. 锁定 viewport    ontouchmove=\"event.preventDefault()\" //锁定viewport，任何屏幕操作不移动用户界面（弹出键盘除外）。  2. 被点击元素的外观变化，可以使用样式来设定：    -webkit-tap-highlight-color: 颜色  3. 侦测iPhone/iPod  开发特定设备的移动网站，首先要做的就是设备侦测了。下面是使用Javascript侦测iPhone/iPod的UA，然后转向到专属的URL。    if((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPod/i))) {  if (document.cookie.indexOf(\"iphone_redirect=false\") == -1) {  window.location = \"http://m.example.com\";  }  }  虽然Javascript是可以在水果设备上运行的，但是用户还是可以禁用。它也会造成客户端刷新和额外的数据传输，所以下面是服务器端侦测和转向：    if(strstr($_SERVER['HTTP_USER_AGENT'],'iPhone') || strstr($_SERVER['HTTP_USER_AGENT'],'iPod')) {  header('Location: http://yoursite.com/iphone');  exit();  }  4. 阻止旋转屏幕时自动调整字体大小    html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 {-webkit-text-size-adjust:none;}  5. iPhone才识别的CSS  如果不想设备侦测，可以用CSS媒体查询来专为iPhone/iPod定义样式。    @media screen and (max-device-width: 480px) {}  6. 缩小图片  网站的大图通常宽度都超过480像素，如果用前面的代码限制了缩放，这些图片在iPhone版显示显然会超过屏幕。好在iPhone机能还够，我们可以用CSS让iPhone自动将大图片缩小显示。    @media screen and (max-device-width: 480px){  img{max-width:100%;height:auto;}  }  7. 模拟:hover伪类  因为iPhone并没有鼠标指针，所以没有hover事件。那么CSS :hover伪类就没用了。但是iPhone有Touch事件，onTouchStart 类似 onMouseOver，onTouchEnd 类似 onMouseOut。所以我们可以用它来模拟hover。使用Javascript：    var myLinks = document.getElementsByTagName('a');  for(var i = 0; i \u0026lt; myLinks.length; i++){  myLinks[i].addEventListener(’touchstart’, function(){this.className = “hover”;}, false);  myLinks[i].addEventListener(’touchend’, function(){this.className = “”;}, false);  }  然后用CSS增加hover效果：    a:hover, a.hover { /* 你的hover效果 */ }   这样设计一个链接，感觉可以更像按钮。并且，这个模拟可以用在任何元素上。    原文地址：http://www.cnblogs.com/pifoo/archive/2011/05/28/webkit-webapp.html  ","date":1396067371,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1396067371,"objectID":"7a7fcec71a35ce18ff34ec24f558efc6","permalink":"/post/csdn/webkit-webapp-%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/","publishdate":"2014-03-29T12:29:31+08:00","relpermalink":"/post/csdn/webkit-webapp-%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 原文链接 如果你是一名前端er,又想在移动设备上开发出自己的应用，那怎么实现呢？幸好，webkit内核","tags":["webkit"],"title":"webkit webApp 开发技术要点总结","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  算法的力量    李开复 2006年5月          算法是计算机科学领域最重要的基石之一，但却受到了国内一些程序员的冷落。许多学生看到一些公司在招聘时要求的编程语言五花八门，就产生了一种误解，认为学计算机就是学各种编程语言，或者认为，学习最新的语言、技术、标准就是最好的铺路方法。其实，大家被这些公司误导了。编程语言虽然该学，但是学习计算机算法和理论更重要，因为计算机语言和开发平台日新月异，但万变不离其宗的是那些算法和理论，例如数据结构、算法、编译原理、计算机体系结构、关系型数据库原理等等。在“开复学生网”上，有位同学生动地把这些基础课程比拟为“内功”，把新的语言、技术、标准比拟为“外功”。整天赶时髦的人最后只懂得招式，没有功力，是不可能成为高手的。      算法与我         当我在1980年转入计算机科学系时，还没有多少人的专业方向是计算机科学。有许多其他系的人嘲笑我们说：“知道为什么只有你们系要加一个‘科学’，而没有‘物理科学系’或‘化学科学系’吗？因为人家是真的科学,不需要画蛇添足，而你们自己心虚，生怕不‘科学’，才这样欲盖弥彰。” 其实，这点他们彻底弄错了。真正学懂计算机的人（不只是“编程匠”）都对数学有相当的造诣，既能用科学家的严谨思维来求证，也能用工程师的务实手段来解决问题——而这种思维和手段的最佳演绎就是“算法”。      记得我读博时写的Othello对弈软件获得了世界冠军。当时，得第二名的人认为我是靠侥幸才打赢他，不服气地问我的程序平均每秒能搜索多少步棋，当他发现我的软件在搜索效率上比他快60多倍时，才彻底服输。为什么在同样的机器上，我可以多做60倍的工作呢？这是因为我用了一个最新的算法，能够把一个指数函数转换成四个近似的表，只要用常数时间就可得到近似的答案。在这个例子中，是否用对算法才是能否赢得世界冠军的关键。      还记得1988年贝尔实验室副总裁亲自来访问我的学校，目的就是为了想了解为什么他们的语音识别系统比我开发的慢几十倍，而且，在扩大至大词汇系统后，速度差异更有几百倍之多。他们虽然买了几台超级计算机，勉强让系统跑了起来，但这么贵的计算资源让他们的产品部门很反感，因为“昂贵”的技术是没有应用前景的。在与他们探讨的过程中，我惊讶地发现一个O(n*m)的动态规划（dynamic programming）居然被他们做成了O(n*n*m)。更惊讶的是，他们还为此发表了不少文章，甚至为自己的算法起了一个很特别的名字，并将算法提名到一个科学会议里，希望能得到大奖。当时，贝尔实验室的研究员当然绝顶聪明，但他们全都是学数学、物理或电机出身，从未学过计算机科学或算法，才犯了这么基本的错误。我想那些人以后再也不会嘲笑学计算机科学的人了吧!     网络时代的算法       有人也许会说：“今天计算机这么快，算法还重要吗?”其实永远不会有太快的计算机，因为我们总会想出新的应用。虽然在摩尔定律的作用下，计算机的计算能力每年都在飞快增长，价格也在不断下降。可我们不要忘记，需要处理的信息量更是呈指数级的增长。现在每人每天都会创造出大量数据（照片，视频，语音，文本等等）。日益先进的记录和存储手段使我们每个人的信息量都在爆炸式的增长。互联网的信息流量和日志容量也在飞快增长。在科学研究方面，随着研究手段的进步，数据量更是达到了前所未有的程度。无论是三维图形、海量数据处理、机器学习、语音识别，都需要极大的计算量。在网络时代，越来越多的挑战需要靠卓越的算法来解决。      再举另一个网络时代的例子。在互联网和手机搜索上，如果要找附近的咖啡店，那么搜索引擎该怎么处理这个请求呢?      最简单的办法就是把整个城市的咖啡馆都找出来,然后计算出它们的所在位置与你之间的距离,再进行排序,然后返回最近的结果。但该如何计算距离呢？图论里有不少算法可以解决这个问题。      这么做也许是最直观的，但绝对不是最迅速的。如果一个城市只有为数不多的咖啡馆,那这么做应该没什么问题,反正计算量不大。但如果一个城市里有很多咖啡馆,又有很多用户都需要类似的搜索,那么服务器所承受的压力就大多了。在这种情况下,我们该怎样优化算法呢?      首先，我们可以把整个城市的咖啡馆做一次“预处理”。比如，把一个城市分成若干个“格子(grid)”,然后根据用户所在的位置把他放到某一个格子里，只对格子里的咖啡馆进行距离排序。      问题又来了，如果格子大小一样，那么绝大多数结果都可能出现在市中心的一个格子里，而郊区的格子里只有极少的结果。在这种情况下，我们应该把市中心多分出几个格子。更进一步，格子应该是一个“树结构”，最顶层是一个大格——整个城市，然后逐层下降，格子越来越小，这样有利于用户进行精确搜索——如果在最底层的格子里搜索结果不多，用户可以逐级上升，放大搜索范围。      上述算法对咖啡馆的例子很实用，但是它具有通用性吗？答案是否定的。把咖啡馆抽象一下，它是一个“点”，如果要搜索一个“面”该怎么办呢？比如，用户想去一个水库玩，而一个水库有好几个入口，那么哪一个离用户最近呢？这个时候，上述“树结构”就要改成“r-tree”,因为树中间的每一个节点都是一个范围，一个有边界的范围（参考：http://www.cs.umd.edu/~hjs/rtrees/index.html）。      通过这个小例子，我们看到，应用程序的要求千变万化，很多时候需要把一个复杂的问题分解成若干简单的小问题，然后再选用合适的算法和数据结构。     并行算法：Google的核心优势       上面的例子在Google里就要算是小case了！每天Google的网站要处理十亿个以上的搜索，GMail要储存几千万用户的2G邮箱，Google Earth要让数十万用户同时在整个地球上遨游，并将合适的图片经过互联网提交给每个用户。如果没有好的算法，这些应用都无法成为现实。       在这些的应用中，哪怕是最基本的问题都会给传统的计算带来很大的挑战。例如，每天都有十亿以上的用户访问Google的网站，使用Google的服务，也产生很多很多的日志（Log）。因为Log每分每秒都在飞速增加，我们必须有聪明的办法来进行处理。我曾经在面试中问过关于如何对log进行一些分析处理的问题，有很多面试者的回答虽然在逻辑上正确，但在实际应用中是几乎不可行的。按照他们的算法，即便用上几万台机器，我们的处理速度都跟不上数据产生的速度。      那么Google是如何解决这些问题的呢？      首先，在网络时代，就算有最好的算法，也要能在并行计算的环境下执行。在Google的数据中心，我们使用的是超大的并行计算机。但传统的并行算法运行时，效率会在增加机器数量后迅速降低，也就是说，十台机器如果有五倍的效果，增加到一千台时也许就只有几十倍的效果。这种事倍功半的代价是没有哪家公司可以负担得起的。而且，在许多并行算法中，只要一个结点犯错误，所有计算都会前功尽弃。      那么Google是如何开发出既有效率又能容错的并行计算的呢？      Google最资深的计算机科学家Jeff Dean认识到， Google 所需的绝大部分数据处理都可以归结为一个简单的并行算法：Map and Reduce（http://labs.google.com/papers/mapreduce.html）。 这个算法能够在很多种计算中达到相当高的效率，而且是可扩展的（也就是说，一千台机器就算不能达到一千倍的效果，至少也可以达到几百倍的效果）。Map and Reduce的另外一大特色是它可以利用大批廉价的机器组成功能强大的server farm。最后，它的容错性能异常出色，就算一个server farm里面的机器down掉一半，整个farm依然能够运行。正是因为这个天才的认识,才有了Map and Reduce算法。借助该算法，Google几乎能无限地增加计算量，与日新月异的互联网应用一同成长。     算法并不局限于计算机和网络       举一个计算机领域外的例子：在高能物理研究方面，很多实验每秒钟都产生几个TB的数据量。但因为处理能力和存储能力的不足，科学家不得不把绝大部分未经处理的数据丢弃掉。可大家要知道，新元素的信息很有可能就藏在我们来不及处理的数据里面。同样的，在其他任何领域里，算法都可以改变人类的生活。例如人类基因的研究，就可能因为算法而发明新的医疗方式。在国家安全领域，有效的算法可能避免下一个911的发生。在气象方面，算法可以更好地预测未来天灾的发生，以拯救生命。      所以，如果你把计算机的发展放到应用和数据飞速增长的大环境下，你一定会发现，算法的重要性不是在日益减小，而是在日益加强。             给程序员的七个建议     （1）练内功。不要只花功夫学习各种流行的编程语言和工具，以及某些公司招聘广告上要求的科目。要把数据结构、算法、数据库、操作系统原理、计算机体系结构、计算机网络，离散数学等基础课程学好。大家不妨试试高德纳所著The Art of Computer Programming里的题目，如果你能够解决其中的大部分题目，就说明你在算法方面有一定的功力了。   （2）多实战。通过编程的实战积累经验、巩固知识。很多中国大学毕业生缺乏编程和调试经验；学习C语言，考试过关就算学会了；课题项目中，只要程序能够编译，运行，并且输入输出满足要求就算了事。这些做法是不行的。写程序的时候，大家必须多想想如何把程序写得更加精炼、高效、高质量。建议大家争取在大学四年中积累编写十万行代码的经验。我们必须明白的是：好程序员是写出来的，不是学出来的。   （3）求实干。不要轻视任何实际工作，比如一些看似简单的编码或测试。要不懈追求对细节一丝不苟的实干作风与敬业精神。我发现不少程序员对于知识的掌握很肤浅，不求甚解，没有好奇心，不会刨根问底。比如，学会了C++，是否了解一个对象在编译后，在汇编代码中是如何被初始化的？这个对象的各个成员在内存中是如何存放的？当一个成员函数被调用时，编译器在汇编代码中加入了哪些额外的动作？虚函数的调用是如何实现的? 这些东西恐怕在编程语言或编译原理中都没有详细提到，只有通过踏实的实干才能真正掌握。   （4）重视数学学习。数学是思维的体操，数学无处不在。学计算机至少要学习离散数学、概率论、布尔代数、集合论和数理逻辑。这些知识并不难，但是对你未来的工作帮助会很大。 尤其当你对一些“数学密集型”的领域如视频、图像处理等有兴趣时，这些知识将成为你手中的利器。   （5）培养团队精神，学会与人合作。今天的软件工程早已经不是一个人可以单独操作的，而必须靠团队合作才能成功。不懂得合作的人是不能成大器的。大家要多去寻找可以与人一起做项目的机会。   （6）激励创新意识，培养好奇心，不要死记硬背。没有掌握某种算法技术的根本原理，就不会有应变和创新的能力。想成为一位好程序员（其实从事任何一个行业都是如此），重要的是要养成钻研，好奇，创新，动手，合作的优秀习惯，不满足于填鸭，不满足于考试交差，不满足于表象。这不是学几门课能够一蹴而就的。   （7）有策略地“打工”。在不影响学业的前提下，寻找真正有意义的暑期工作或兼职。去找一个重视技术的公司，在一个好的“老板”指导下完成真正会被用户使用的程序。不要急于去一个要你做“头”而独挡一面的地方，因为向别人学习才是你的目的。找工作也是一样，不要只看待遇和职衔，要挑一个你能够学习的环境，一个愿意培养员工的企业，一个重视你的专业的公司。最后，还要挑一个好老板。   希望大家都能把握机会，养成好的学习习惯，把算法学精学透；希望大家都能有一个美好的未来！       ","date":1387715096,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1387715096,"objectID":"1d3d9ccec06c8317e8afae60b3866b4e","permalink":"/post/csdn/%E6%9D%8E%E5%BC%80%E5%A4%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%AE%8C%E6%95%B4%E7%89%88/","publishdate":"2013-12-22T20:24:56+08:00","relpermalink":"/post/csdn/%E6%9D%8E%E5%BC%80%E5%A4%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%AE%8C%E6%95%B4%E7%89%88/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 算法的力量 李开复 2006年5月 算法是计算机科学领域最重要的基石之一，但却受到了国内一些程序员的冷落。","tags":[],"title":"李开复：算法的力量 （完整版）","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n     坑爹的电信网，服务器访问不上了。  大家先将就一下吧。    基础班      时间  课件  详情  主讲    10.26  第零讲  ACM介绍    张慧仁    10.31  第一讲  输入输出   数据类型、条件语句 || 判断日期合法  张慧仁     第二讲  循环语句   for、while || 图案输出、素数  李天瑞    11.09  第三讲  数组  Fibonacci、冒泡排序、逆序对  雷鑫     第四讲  二维数组  杨辉三角     11.23  第五讲  字符串   gets | memset strxxx *3 | sscanf sprintf  徐华杰    11.30  第六讲  函数递归  结构体  罗昭    12.07  第七讲  贪心算法   算法复杂度  李才林    12.21  第八讲  一些补充   知识点的回顾 | 张慧仁的扯淡   李嘻     提高班       时间  课程（课件下载）  详情  主讲    11.03  第一讲  搜索   DFS BFS  丁春生    11.10  第二讲  图论基础   图的概念 最小生成树 最短路径 并查集  郭朋华    11.24  第三讲  线段树    敖綦    11.24  第四讲  树状数组   树状数组的结构 特点 建立 树状数组与线段树的关系  徐华杰              ","date":1387640911,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1387640911,"objectID":"3bb8850e3dbfa1ca4a8eea7f74c02c50","permalink":"/post/csdn/2013~2014-%E7%AC%AC%E4%B8%80%E5%AD%A6%E6%9C%9F%E8%AF%BE%E4%BB%B6%E6%95%B4%E7%90%86/","publishdate":"2013-12-21T23:48:31+08:00","relpermalink":"/post/csdn/2013~2014-%E7%AC%AC%E4%B8%80%E5%AD%A6%E6%9C%9F%E8%AF%BE%E4%BB%B6%E6%95%B4%E7%90%86/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 坑爹的电信网，服务器访问不上了。 大家先将就一下吧。 基础班 时间 课件 详情 主讲 10.26 第零讲 ACM介绍 张慧仁 10.31 第","tags":["2013"],"title":"2013~2014 第一学期课件整理","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n     先声明 不是搭建教程。。  重做了个系统要重新搭环境，结果原来的很多站点的东西都没了，害我辛辛苦苦折腾了好久，于是今天整理一下。    go下载    Golangtc下载  这个貌似比官网快  环境变量已有 GOROOT （windows默认会装在 C:\\Go 不想装在C盘又不想改配置的可以用 mklink ）  一般还需要 GOPATH  需要把 PATH 加上 %GOROOT%\\bin;%GOPATH%\\bin;   msysgit （Linux直接从仓库下）    https://code.google.com/p/msysgit/downloads/list   我用的git bash ,所以没有配置 环境变量    gocode    go get github.com/nsf/gocode     确保 %GOPATH%\\bin 已添加到环境变量    MarGo    这个有点坑，谢大的书上推荐的 github.com/DisposaBoy/Margo ，但是上去根本找不到，但是在 /nineo 下却看到这样一句话：   experiment to see if i can implement all the gosublime 9o functionality in go, and thus margo    啥也不说了。。于是重新找了个，也不知道一不一样。     go get github.com/slene/margo    mgo    这个东西一样下不到，我在xushiwei空间里面找到了。。单独下载到自己的地方吧。   https://github.com/xushiwei/mgo/tree/master/src    确保你的 mongoDB\\bin 已配好环境变量     Goclipse    在 eclipse -\u0026gt; Help -\u0026gt; Install New Software 地址栏输入 http://goclipse.googlecode.com/svn/trunk/goclipse-update-site/ 就可以自动安装了。  同ADT一样，装好之后要配置一下环境。    GoSublime    在插件管理器可直接安装（木有插件管理器？看看 这里  ）  然后就是 Sublime 控制台的滚动条问题，目前无解。。     需要其他的pkg，可以去 http://gowalker.org/  | http://godoc.org/  搜索，至于搜到的能不能用看造化了。  突然觉得 Go 环境的配置蛮复杂的，比它再复杂的应该就是给外置设备烧录的了吧，显然没啥可比性。       ","date":1386208911,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1386208911,"objectID":"1f542c19382e274693cf2bc7a0d23834","permalink":"/post/csdn/%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8Bgo%E7%8E%AF%E5%A2%83%E9%9C%80%E8%A6%81%E7%9A%84%E4%B8%9C%E8%A5%BF%E6%B0%B4%E5%B8%96~/","publishdate":"2013-12-05T10:01:51+08:00","relpermalink":"/post/csdn/%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8Bgo%E7%8E%AF%E5%A2%83%E9%9C%80%E8%A6%81%E7%9A%84%E4%B8%9C%E8%A5%BF%E6%B0%B4%E5%B8%96~/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 先声明 不是搭建教程。。 重做了个系统要重新搭环境，结果原来的很多站点的东西都没了，害我辛辛苦苦折腾了好","tags":[],"title":"整理一下Go环境需要的东西（水帖~）","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目          The Clocks   IOI'94 - Day 2   Consider nine clocks arranged in a 3x3 array thusly:  |-------| |-------| |-------| | | | | | | | |---O | |---O | | O | | | | | | | |-------| |-------| |-------| A B C |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| | | | | | | | O | | O | | O | | | | | | | | | | |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| D E F\n|\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| | | | | | | | O | | O\u0026mdash;| | O | | | | | | | | | |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| G H I  The goal is to find a minimal sequence of moves to return all the dials to 12 o\u0026rsquo;clock. Nine different ways to turn the dials on the clocks are supplied via a table below; each way is called a move. Select for each move a number 1 through 9 which will cause the dials of the affected clocks (see next table) to be turned 90 degrees clockwise.    Move   Affected clocks    1  ABDE    2  ABC    3  BCEF    4  ADG    5  BDEFH    6  CFI    7  DEGH    8  GHI    9  EFHI     Example  Each number represents a time accoring to following table:  9 9 12 9 12 12 9 12 12 12 12 12 12 12 12 6 6 6 5 -\u0026gt; 9 9 9 8-\u0026gt; 9 9 9 4 -\u0026gt; 12 9 9 9-\u0026gt; 12 12 12 6 3 6 6 6 6 9 9 9 12 9 9 12 12 12  [But this might or might not be the `correct\u0026rsquo; answer; see below.] PROGRAM NAME: clocks  INPUT FORMAT     Lines 1-3:   Three lines of three space-separated numbers; each number represents the start time of one clock, 3, 6, 9, or 12. The ordering of the numbers corresponds to the first example above.     SAMPLE INPUT (file clocks.in)  9 9 12 6 6 6 6 3 6  OUTPUT FORMAT  A single line that contains a space separated list of the shortest sequence of moves (designated by numbers) which returns all the clocks to 12:00. If there is more than one solution, print the one which gives the lowest number when the moves are concatenated (e.g., 5 2 4 6 \u0026lt; 9 3 1 1). SAMPLE OUTPUT (file clocks.out)  4 5 8 9   \n     思路   这份题解，算是一边coding一边写出来的，一是好久没码过了，更重要的是这个题目很复杂。。   第一想到的方法就是枚举所有表，或者叫搜索。不管叫啥，反正都不现实，4^9 = 2^18 ,貌似也不错~      但是既然想得瑟，就说一下应该怎么搞。   枚举题目优化的思路都有一点，枚举的各个变量之间能否用一定的关系式推出来。   这个题目里，很显然，如果表A可以通过操作1 2进行，如果操作1执行了1次，那表A离12点还差几次就必须把操作2也进行几次。      先列一下钟表与矩阵的关系图：   Ci = C[i] / 3;   clocks operates 1 1 2 4\t( C1 + p1 + p2 + p4 ) % 4 == 0 2 1 2 3 5\t( C2 + p1 + p2 + p3 + p5 ) % 4 == 0 3 2 3 6\t... 4 1 4 5 7 ... 5 1 3 5 7 9\t... 6 3 5 6 9 7 4 7 8 8\t5 7 8 9 9 6 8 9    把上面的关系式反过来，就能在已知 c[i] 通过枚举部分 pi 求出其它 pi      我枚举的是123三个操作，然后剩下6个操作就可以就确定了。      代码   /* ID:zhrln1 PROG:clocks LANG:C++ */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int c[11]; int cal(int a, int b, int c){ int t = - a - b - c; while ( t \u0026lt; 0 ) t += 4; return t; } int cal(int a, int b, int c, int d){ int t = - a - b - c - d; while ( t \u0026lt; 0 ) t += 4; return t; } int main(){ freopen(\"clocks.in\",\"r\",stdin); freopen(\"clocks.out\",\"w\",stdout); for (int i(1);i\u0026lt;=9;i++) { cin \u0026gt;\u0026gt; c[i]; c[i] /= 3; } int p[11]; bool found = false; for ( p[1] = 0; p[1] \u0026lt; 4; p[1]++ ){ for ( p[2] = 0; p[2] \u0026lt; 4; p[2]++ ){ for ( p[3] = 0; p[3] \u0026lt; 4; p[3]++ ){ p[4] = cal(c[1], p[1], p[2]); p[5] = cal(c[2], p[1], p[2], p[3]); p[6] = cal(c[3], p[2], p[3]); p[7] = cal(c[4], p[1], p[4], p[5]); p[8] = cal(c[7], p[4], p[7]); p[9] = cal(c[9], p[6], p[8]); if (((c[5] + p[1] + p[3] + p[5] + p[7] + p[9]) % 4 == 0) \u0026amp;\u0026amp; ((c[8] + p[5] + p[7] + p[8] + p[9] ) % 4 == 0) \u0026amp;\u0026amp; ((c[6] + p[3] + p[5] + p[6] + p[9] ) % 4 == 0 )){ found = 1; break; } if ( found ) break; } if ( found ) break; } if ( found ) break; } int i = 1; while ( p[i] == 0 ) i++; printf(\"%d\",i); p[i--]--; while ( ++i \u0026lt;= 9 ) while ( p[i]-- ) printf(\" %d\",i); printf(\"\\n\"); return 0; }     ","date":1385627821,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1385627821,"objectID":"7d386d5e81094d8702167fc234d2e6f4","permalink":"/post/csdn/usaco-section-1.4.3-the-clocks/","publishdate":"2013-11-28T16:37:01+08:00","relpermalink":"/post/csdn/usaco-section-1.4.3-the-clocks/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目 The Clocks IOI'94 - Day 2 Consider nine clocks arranged in a 3x3 array thusly: |-------| |-------| |-------| | | | | | | | |---O | |---O | | O | | | | | | | |-------| |-------| |-------| A B C |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| |","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.4.3 The Clocks","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目链接： http://poj.org/problem?id=3041   看起来像个 DP 神马的。竟然是二分图匹配。。  看着啊，行与行之间相互独立，一个行可以就炸掉很多列。（列的道理一样），如果替换一些字。  点与点之间相互独立，一个点就可以炸掉很多边。  so，可以把行列看成一个点，把一个炸弹看成一条边，然后题目就转换城了最小点击覆盖（即最大匹配）。    尼玛，鬼能想到这样的思路。。。  这个题的思路就是上面说的，每一个炸弹（x，y）看做一条边，两个端点就是它的行列x 和 y。任意炸掉x y期中一个点都可以把可以把这条边炸掉。跟题目一样了。  就这么神奇。。    代码：  #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; const int N = 555; int n, m, g[N][N], chk[N], match[N];\nint dfs(int v){ int t; for ( int i = 1; i \u0026lt;= n; i++){ if ( g[i][v] \u0026amp;\u0026amp; !chk[i] ){ chk[i] = 1; t = match[i]; match[i] = v; if ( t == -1 || dfs(t) ) return 1; match[i] = t; } } return 0; }\nint main(){ while ( ~scanf(\u0026quot;%d%d\u0026rdquo;, \u0026amp;n ,\u0026amp;m) ){ memset(g, 0, sizeof(g)); while ( m\u0026ndash; ){ int a, b; scanf(\u0026quot;%d%d\u0026rdquo;, \u0026amp;a, \u0026amp;b); g[a][b] = 1; } int ans = 0; memset(match, 255, sizeof(match)); for ( int i = 1; i \u0026lt;= n; i++){ memset( chk, 0, sizeof(chk)); ans += dfs(i); } printf(\u0026quot;%d\\n\u0026rdquo;, ans); } return 0; }   \n      ","date":1384503798,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1384503798,"objectID":"87cc497e09ed8477111d79fb08995664","permalink":"/post/csdn/poj-3041-asteroids-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/","publishdate":"2013-11-15T16:23:18+08:00","relpermalink":"/post/csdn/poj-3041-asteroids-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目链接： http://poj.org/problem?id=3041 看起来像个 DP 神马的。竟然是二分图匹配。。 看着啊，行与行之间相互独立，一个行可以就炸掉很多","tags":["POJ","Algorithm","ACM"],"title":"POJ 3041 Asteroids 匈牙利算法 二分图最大匹配","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n 国际程序设计大赛一等奖作品这个程序(omni.com)是97年的Mekka ’97 4K Intro比赛的一等奖作品，整个程序全长4095字节，其中包含133字节的自解压程序(类RAR压缩)，未解压的程序长4782字节。三维场景包含144个立方体，367个面，362个点，15个不同的64*64的纹理……   据说当时是直接用机器码写出来的，而不是由高级语言编译形成的。   实在太震撼了。   1）把下面的代码粘贴到记事本里面，另存为 1.txt 文档。   2）在命令行窗口下(在开始→运行→cmd)，进入文档所存盘符，输入debug\u0026lt;1.txt，就出现标准的三维空间动画和音乐   虽然它不是最精美的，但是当你得知它只有 4K 时，并且是在1997年写出来的，会不会立刻疯掉呢？   实在太震撼了。   图灵、冯·诺伊曼、比尔盖茨等等，这些技术天才，是那么地令我向往。或许就是这种憧憬引领着我，一步步走进技术的世界。想到我的一生都可以在这个世界翱翔，做自己喜欢做的事，就觉得这是无上的幸福……    附上完整的代码：    e100 33 f6 bf 0 20 b5 10 f3 a5 8c c8 5 0 2 50 68 13 1 cb e 1f be a1 1 bf 0 1 e11b 6 57 b8 11 1 bb 21 13 89 7 4b 4b 48 79 f9 ad 86 e0 8b c8 bd ff ff e8 20 e134 0 3d 0 1 74 1a 7f 3 aa eb f3 2d ff 0 50 e8 f 0 5a f7 d8 8b d8 26 8a 1 aa e14f 4a 75 f9 eb de cb 57 bb 21 13 8b c1 40 f7 27 f7 f5 8b fb ba 11 1 4f 4f 4a e168 39 5 7f f9 52 8b c5 f7 25 f7 37 2b c8 95 f7 65 2 f7 37 95 2b e8 fe e fe e181 10 79 6 c6 6 fe 10 7 46 d0 14 d1 d1 d1 e5 79 ec 5a b8 11 1 ff 7 4b 4b 48 e19b 3b d0 75 f7 5f c3 83 f7 83 a6 5d 59 82 cd b2 8 42 46 9 57 a9 c5 ca aa 1b e1b4 4f 52 b4 92 3f ab 6e 9e a8 1d c6 3 fc e 6a e7 ae bb 5f 7b 10 b8 b4 f7 8 e1cd e2 bf 36 4e 39 9d 79 29 3f a f9 36 52 16 fb 5 e8 e5 a6 c2 e9 b0 43 d3 a3 e1e6 cf d3 fd fd cb d1 4c 5e e0 63 58 86 bb 3e 9 c1 20 bc cc 91 a3 47 81 70 b3 e1ff d6 1a 9e c2 c9 12 e7 4e ad f4 5f e3 30 e9 9 39 d7 e8 f9 f4 d2 44 e8 d7 22 e218 be e2 ce 88 25 cf 30 4a a8 29 ae 3f 47 c6 2d 85 e9 73 54 13 b e6 e0 34 65 e231 e2 50 8a 89 18 5f ce 70 99 3 5f 42 bf eb 7 ae d0 ca 5 22 8d 22 a5 b7 f0 e24a 90 81 bc 7a bc dc 5 db c0 6a 2 e5 57 38 be 60 cb ac ba a5 3b 9d f1 77 38 e263 a6 84 d1 3c af 49 d8 6a 45 a2 76 60 21 12 c0 c2 44 f2 5e bb e5 37 a9 2b e27b ec 4a 8c 4c f2 f7 a9 58 71 2b ba 6d d6 6a e5 60 46 e0 da e5 b9 90 e5 a3 e293 f7 7f 31 60 58 f0 c4 88 10 4e 3c a3 ee 4e 11 55 8f a 92 eb db ad 7a 9c f e2ac db 5a 28 96 da 87 ae 91 91 2d e3 5e ea df 6 95 71 67 71 40 ce d1 2e 31 6d e2c5 c1 9c d8 6a 76 9b 4a e8 36 44 d6 76 d 30 5 ff d4 1b ac 1f 32 65 31 bf 55 e2de 26 b a4 55 e1 5d 5e 16 ed 97 48 6c 77 fb 81 86 e f9 18 bd d4 f4 8b de 1d e2f7 ba d 47 75 3 89 4b 3e dc 27 86 1c d0 17 89 48 d1 a6 8d d4 2b 54 4e 8f b0 e310 2 e1 6b 1a 75 78 ea 21 91 13 c0 cf 78 a0 ab f3 35 c6 b4 c8 90 8d d7 45 e7 e329 c 5b a4 ba 52 10 64 f5 4a 50 b7 ec 46 22 15 23 84 30 81 5c df 61 5a 8f 67 e342 c4 63 57 6d f7 26 92 a3 1f e5 3 a5 0 54 41 8 48 7c 26 90 33 82 9c 91 b0 e35b ab 78 5d df 99 e0 b9 fc 5 36 ac d9 49 91 ab 20 a2 63 48 89 ce 5c 60 64 f0 e374 63 d9 a8 38 3b d3 e6 4c 8c 23 34 4e 20 51 93 5e 6d b4 7a 22 9b 4c f2 d3 e38c c4 f8 3 6f 47 40 f4 f8 45 9b 83 f3 83 6 31 d0 0 17 82 83 dc 67 f9 62 77 e3a5 90 3b d9 ec f3 55 96 b8 d9 db 79 55 f1 e5 8c 5e f2 e5 2e b0 b 6e e2 81 25 e3be 93 8e b5 dd 5b 46 f9 af ed 6 12 cf c9 1d f0 f7 3b 16 2d c6 58 73 8d e9 5f e3d7 fd 5a b6 a1 94 4d 1a 8 ff eb b7 6 80 c7 86 83 b6 b9 fd 1c e0 c c3 2e a0 e3f0 2f b 3e 3 6b 29 e1 27 85 1c ea 6d df b3 a3 ed 65 4a 9a 59 3b 54 e 4b ae e409 9e 27 f0 4d 3b c 4c 46 b7 e5 57 1b 1f 1f bb 80 86 f5 b7 ef 73 52 bf 2c c7 e422 ed a b7 81 2 f3 90 3e ee cc 6c eb f 38 1 6c 68 b1 d 45 78 b2 f f6 83 b0 e43c c4 33 df b1 d1 91 98 1e 81 a5 e2 59 9f f4 8c b6 72 8 a7 8c f6 e a3 b2 1f e455 d9 d3 23 f0 7c 5e 5f 68 61 8b 45 da 1d 91 ec 8d 4e ea 1a 38 85 94 aa ac e46d f2 4 f6 c4 e5 92 8e 9a 4e 83 e1 73 e8 cf 2a 5c 2b 7e f1 30 2 8a e6 28 1a e486 3b ce bc 96 aa 7f eb 87 cd 8b 96 2d 9 59 7a a0 1a 43 62 9a 9e 4f ff 8e d9 e49f ce d6 a4 70 79 cd 65 fa 2e 92 14 29 f7 6c 74 4b 49 60 80 bb ff 41 bb 2d e4b7 60 33 3f 98 77 9a 1 ee a6 a3 da bc ba e9 f3 72 f4 7c c3 59 2 a6 44 a4 c8 e4d0 c8 54 93 ce bd 69 bb b9 43 21 2c c4 ea 4a 5c 3f 75 60 f2 b4 91 ca 9 82 e3 e4e9 a e9 a6 20 b9 76 50 ed 47 e9 fe 6d 41 34 13 2f 28 2f 4e f4 da e 3c 78 6c e502 b1 79 87 45 98 a4 d4 c3 b3 29 c2 4a 8b ed a6 54 e2 1b 31 62 60 ff 2c 1d e51a 21 0 15 b2 4e 5c c 2 d 83 fa a2 f3 8a 5 12 72 4a c7 44 7c 91 d4 be b a f2 e535 70 52 fb b4 a2 df 89 de ff c4 96 73 c9 c ed d3 c9 8e 5c dc 8e d1 3b de 8c e54e 53 a2 8b f9 e9 91 dd d6 df 6e 74 d1 dd 34 60 8f 9e 32 7f 3b ec 79 a3 83 e566 45 78 b4 2f 1c 50 7b 7a 97 b0 9d 2d c dd 8a 26 cd 7d 8c 4c 5a 8a 4c f9 a4 e57f 11 f9 2c 6c 92 e9 b5 cb 56 89 8c be f6 64 fa 25 43 fa 6f e2 c8 3a 18 a8 e597 f0 e9 f4 c2 86 e6 2b 44 67 4a b9 34 9 ed 5f 33 42 62 d4 8a 1e 5b 31 67 cd e5b0 3d 71 6d 83 fd 36 20 69 ea 1 c3 e6 e6 de 99 aa 7 11 5b 59 8a 1f 43 83 52 e5c9 ea 5d 8c 6a 69 c7 3 eb 4e 3b 88 a5 5f b1 6e 27 5f 3 5c 28 c 9b 6c c3 f8 e5e2 e5 b9 d6 11 d6 8b fa 5c 8 c7 1 eb 45 db f3 6c 9f 16 46 61 51 ed df f bb e5fb c0 c4 1e 64 68 98 4 79 30 94 72 df d4 cd 1f 7f 72 c6 82 2e 79 47 4e 8c 4b e614 a2 c7 e2 36 df 76 fd a4 b6 4e db 96 40 3b 8b b5 d4 85 64 c6 0 2c ad 9d 27 e62d 14 99 82 4b bc 9 fa 94 b5 db 7c 98 eb b 13 a7 b0 79 1d 7e c5 45 aa 20 49 e646 be ff 9d 64 0 5d c ec 6 5 ad f2 38 6b ed 7a d6 b2 c7 2e 6a a6 12 4b ff 55 e660 20 3b a 77 f b9 0 9d 57 4a ad ce a4 d3 ff 1 4f fb 53 54 88 f 1 ed 4b 56 e67a 15 c8 dc 28 bf f2 72 d4 10 1f 99 42 69 9e 78 e2 47 82 93 31 d0 2d be 9f e692 93 93 9a 1b 80 c0 10 c 53 78 a0 26 2a 96 4f 74 4b 16 c7 9c 8d ad ac fb 16 e6ab 15 c6 fd c9 a4 14 48 62 47 20 c9 41 ed 61 f8 9b f8 ff ba 39 50 65 87 ee e6c3 bd ce 95 c0 fb a5 7e d8 cd 27 fd 2c 74 3 c1 1b 89 b9 51 d5 e3 da ef 9e 6 e6dc f0 aa a9 a7 fb 87 4c 5d cd ff 65 36 8c 73 6f 9 c6 78 9a b6 77 db df 81 68 e6f5 3b b8 ae 5d e1 af d4 e6 66 8c d6 a4 83 9f 37 3c 1 dc a2 a6 57 c2 20 1b 90 e70e 75 df cd a5 62 a5 36 79 fb 35 8a 9b b0 a0 a5 c3 37 6f 80 72 bc 52 30 8d e726 9f 7a 64 d3 7 41 45 d8 68 97 f2 aa 1c a1 6c 7c 9d 32 7d ad 15 b1 53 e3 33 e73f 8a ed e9 49 d4 cf dc 96 22 37 36 11 9d 7f f0 4d e0 62 31 b1 c7 69 c4 79 e757 ac 20 1 e8 3c 6a 8c 32 cb 52 63 36 68 f4 10 2b 9c 21 4f df 5d 60 92 39 91 e770 e2 f9 c9 7d ca 48 3 3f 21 dd 6c f 23 2e 61 3a 9f ba c3 f9 4e 7 ea ed ef e789 71 4a 72 3a ed 23 3d 77 b5 ed d5 1d f6 a4 99 fa ef 98 dd 2 98 80 b6 7c a3 e7a2 62 96 7b 8e bf 7b 81 9f 9a ce 3f 12 40 2e 25 db 84 16 dd 2e 86 f f4 b2 7e e7bb 5e b4 14 6a f3 29 b1 a4 57 d5 a8 17 6f 87 a4 74 5b 9b 17 79 f1 ec 33 c8 e7d3 f0 1d b2 7e a8 4d 95 7f 5f 9 d5 1a 5a 45 f4 41 c6 d 3f eb 66 2a c0 e8 5b e7ec 3c bd 50 ad f1 53 9d 2e 45 9a d8 7d 2c 17 a8 6e 15 48 13 39 53 ed 3d 78 e804 ad f 3a 65 a3 3e 2e fa ca 7 94 4a 1f b4 d8 7e 47 8a 8e de e7 7e 34 c1 69 e81d 7f 6a aa 66 58 18 31 24 72 13 22 34 8a 56 36 87 df c2 d 8e 3f 71 a2 5f 25 e836 8b 8d 4 78 fd c9 45 d1 55 79 c1 9f 13 84 1b c8 5 db 95 d0 7c 64 96 20 51 e84f c4 e0 5e ee 47 8a 11 ac fb 9 e0 bb 40 db 86 84 12 93 b9 c9 f2 9c 63 47 c9 e868 eb ad 1 3e fa 6d 3f a 64 5b 58 56 27 f ca 5d e0 30 bc 3e 10 5d ec 17 28 e881 85 5 51 8e 95 a3 94 3a a8 f1 96 f2 f 29 5c 97 dc 47 db 9d 6c 63 e8 e7 f0 e89a e4 a 70 f8 f1 47 54 d3 2d 32 7c ef bb 9a b4 1b 0 2b d6 dd e7 30 b a2 75 e8b3 c7 f5 d0 31 d7 d2 8a b0 ac 1c 6d 60 3a f7 c2 db 1e 6d 7 f6 8f 35 88 e5 7f e8cc 3c 26 81 34 a0 32 a3 25 18 6e 73 b2 a0 f1 cb 86 61 e7 65 8b 76 98 19 6f e8e4 c0 62 9b a3 cc 18 5e 40 12 97 2b d0 15 79 de 19 ea df 7a 59 2f b5 d7 39 e8fc 52 e2 6 f1 3 a0 a5 d9 1b 88 93 4d 30 c8 2d f5 db 55 ea 85 6f a 3f dc bd e915 57 15 6a a3 a3 3e 8e ad 2d da a0 ca 75 7c 57 8b c5 cb b 1d 2c 8e c6 96 2e e92e 6d 59 83 7d 64 72 ca 80 2e 6 a4 ff f6 f2 d5 1e 7 4 ba 34 6e 9 86 25 aa 4e e948 e0 7f f5 32 47 3e 7c 43 d8 28 c4 1c 11 1d bd 33 3 b5 ca 13 43 34 2 b1 a0 e961 57 ed 9d 3c 23 d4 45 b2 6e 81 6e af 3e 67 90 be 59 a5 45 34 53 46 85 d1 e979 25 ee 7d cb a4 db 12 c3 aa 17 61 9a fb 66 40 76 fe 3a 69 96 c0 91 14 a7 e991 5d cc 9f f6 73 59 ee b8 55 97 20 26 ff 99 ec 72 41 b5 27 21 6e ae 8a d0 e9a9 e4 d3 da 6f c4 53 c5 f8 b3 a7 a1 5d 66 93 d8 b1 89 40 23 92 c0 90 fb cb e9c1 e7 6b 4e 51 0 5d 57 f7 cd 1 e2 88 bf 44 9f ef c4 33 ce fa 46 46 a1 86 b e9da 7a 84 66 66 b9 2 ec 10 c6 a1 d4 c1 18 33 b1 d1 2 18 ad 2f 53 e4 b9 33 59 e9f3 be 3c af 80 4c 8a d5 76 c 3b a7 e2 97 94 15 75 4d 17 d5 97 cf f9 4a d0 6e ea0c bb 27 20 fc f1 f5 9 a8 df 4d b6 5d f0 1d 69 3b 76 35 82 a4 f3 56 64 39 5b ea25 6b b3 7 e7 5 8e 82 11 22 a8 1a db c8 3e 67 4a 3 7e 72 51 d6 3d 1a 1c f6 ea3e b8 da 4b 18 8a 15 9d d0 a4 84 96 3e cd 3 f9 3a 30 f3 fb 8f 6e 2 73 eb 52 ea57 93 95 cf dc 6f 48 fb ab d2 a9 70 b4 e2 23 8d 72 86 a8 fa 78 98 1d c5 fe ea6f 8a 51 88 2b b7 58 b0 ca ae 40 8a 33 32 75 1 6 c0 d4 b7 da 2a a7 bb ad f7 ea88 48 98 5a bc d3 d1 e6 16 97 c3 80 ab 73 ac 32 11 41 1f d 5d aa 0 dc d9 6e eaa1 fc 30 6 ef 11 60 27 a2 5f eb 5f b9 35 8 23 4 be 10 c0 85 3e 55 b3 82 fd eaba f7 c3 24 9f 2d 83 94 32 36 de ff 7c 87 7f 4a 80 7 2 23 cf a4 52 eb 3e 19 ead3 a0 b4 a 94 1a 40 58 d9 16 6d c0 64 c4 69 ed 60 46 65 cb df 58 38 0 51 c3 eaec ad a0 37 e4 cf ab f7 6c 24 7d 9 48 65 4a 9f 91 ad 1c 79 a4 a1 78 55 c e8 eb05 44 5b d ef 51 bd ea 2d a7 42 57 ab 3a 4f 2 b 3 19 6a 4d 72 76 5c 97 0 6c eb1f c5 5d bc dd e7 81 cf 8d 34 38 50 3c 98 58 cc 41 aa 99 90 af fe 4e 96 77 eb37 ed 54 18 ce 2c d1 5d 34 cb 79 50 ff 28 96 44 e0 51 64 6 a8 b7 6e 8c 62 c4 eb50 66 95 81 4f 8c f6 26 ba ea 5d d2 79 b1 e4 e9 29 fc a fd b3 85 8c e6 52 dd eb69 33 bd 5d c7 39 ef 6 ef 9e a6 6a 61 9c 9f d5 54 b4 fa a1 d4 10 9b ff 7e 33 eb82 11 52 99 c7 26 6e a1 36 8a ad ee 48 7a 2c 7f d5 b7 27 8a 6b 37 c 71 39 85 eb9b 9c ba a8 a 17 b9 d0 51 56 95 c2 3b 5 a7 31 c5 8b 5c 95 6e 4c 89 6f 17 ef ebb4 d4 5a a 77 65 e1 49 b2 e8 72 ac 3c f0 6b 71 fa 3 c7 ca fc ad f9 55 22 ec ebcd 58 2f 1c fa 29 cf 73 b4 ad 51 5c f8 66 70 59 5d 70 3e d1 3f c4 eb ec f1 ebe5 7 78 6a 93 67 9f 44 fc cb 5b 95 ff 74 c0 b7 42 77 26 c9 aa 8c ed 39 a2 db ebfe 9c b3 eb 3d 4a 1e 9b 89 e4 d8 a8 27 74 ef a3 ed a5 24 5d bb ab d0 fe a1 ec16 29 ab df 75 a a6 23 0 cc f1 14 72 9b 1a 55 7e e5 d1 da 98 dc c4 cf ab 34 ec2f ba 8d de 4a 59 6 13 dd d8 44 3c e bb 56 95 ae 97 e2 3b 49 e5 9a 6b a2 53 ec48 c1 33 35 24 1b 33 17 c3 8a 8c 12 3d 3d 4e 5b 75 22 30 67 4f a0 5d 3a 78 ec60 88 a 11 35 7 b1 77 42 32 a8 c3 bb 20 fb 98 5 d6 ac e7 3a 63 35 90 93 9e ec79 44 24 2e 1b d7 8c aa 29 53 4d d9 ab eb e6 1 56 c4 fd 54 a3 bd 14 5b b0 8f ec92 ce be 23 24 93 c4 48 18 a3 e7 4 5 4b 78 cc 79 dd 3 56 a4 ed dd 5f 98 41 ecab 1b 68 4c c1 bb 41 c2 1e 3e 94 8e ef 28 1e b 76 e 4f 36 b1 c 6e e2 18 17 ecc4 20 fc 35 40 1f e4 6d a4 18 bb bc d5 9e ea 85 86 af af 63 d4 13 66 92 c4 ecdc 2b 69 84 ca 23 2b d3 66 81 6b 81 73 26 4 85 36 21 4c 49 44 75 64 39 16 3c ecf5 ed e0 6d 44 75 45 30 43 68 c0 78 fc d0 17 b eb 81 3e c3 ba 1b f 4d ae c5 ed0e 55 1f c 39 12 5d 8 65 f1 34 59 de dd 98 56 17 43 38 66 49 9a eb db c1 87 ed27 51 38 cc b7 5f 98 fd 43 be 2d bb 74 f3 f8 f2 36 3d a4 34 a5 7e d2 26 cc ed3f 84 1f ea 56 f0 80 18 69 4d 88 41 fc 56 fd 41 3b 1e e 9 27 4f f6 3b 62 4e ed58 5a 1b 2a 4e 85 8c b2 4f 79 ef 59 4e e 73 3d bd c4 ca 60 e7 4a 47 90 b5 8 ed71 2a f0 4e dc ba 66 ae 48 2b 31 73 a2 11 c 32 ff 54 14 77 6b d6 58 4b bf ee ed8a f6 6a bc dd 1 88 d da a9 f 81 24 c5 f8 72 9a db d5 c8 2a 80 a9 16 d7 c6 eda3 b1 91 c0 a9 95 40 b5 b3 a8 2a 28 c6 92 16 ab 54 7d f8 93 5f 3a 17 c8 45 edbb a9 f0 e0 71 23 76 53 38 a5 a1 cc d4 f1 f2 3c 2b 46 43 a1 d5 ba e d7 19 7a edd4 c2 e1 8f 67 1d d 98 9d a1 79 9d 1b 20 7f 4d e7 bf f9 ff fe aa 28 ab 8f c eded 4d 50 33 e3 26 fc 3c 3 3a 2b 26 12 f7 1 8f ee 97 4c e6 6 2b d9 1f a1 4a ee06 77 44 d4 8b b7 3e 5e 2d 18 c3 54 68 99 a8 8d 92 96 9e 9d ab 33 38 ff b8 ee1e ee 78 c6 7b b5 84 95 d3 6 27 ae 5d 27 38 a 38 8e f0 1 a5 96 4b d7 9b 42 ee37 e5 6f 57 75 4c e9 78 2d 5b ec b6 d2 29 e2 a8 92 95 9c 65 2a 3e bf 8d e0 ee4f bf b3 ac c8 e 7e 13 af 88 26 7d 48 5a c7 39 29 36 d2 90 e8 3b 3 d0 61 1a ee68 d2 e8 a8 f ba 8e a1 9f df 12 ab 54 7 23 98 de 62 af 4c 7e d4 fb 6b 2 6e ee81 40 40 37 b7 73 f2 d8 81 be 29 d2 99 c0 73 25 1a 3c 92 75 6e bd d7 79 79 ee99 4 14 c0 4e 99 57 66 93 74 ec b0 29 7c df 61 b0 3 3a d1 c3 fa a4 f7 f 9f eeb2 d3 f 0 b9 2a 5a 3a c5 88 25 b8 b9 cc 82 3 57 3a e1 7b 51 75 70 a6 74 1a eecb ca cb 3 18 68 ca 77 fe 1b ad cd 68 7f 36 85 fc b7 4f a0 11 da 69 fa 79 87 eee4 d6 b9 21 dd 3e 70 db dc 84 d4 6e d1 20 4 af f6 32 a2 8e d 54 25 fe 7 54 eefd e 7a 74 4b a0 4b f7 f4 e8 74 22 e9 98 70 fb 25 2e f4 64 57 75 28 85 45 53 ef16 3a 2e e2 3c 54 36 e9 29 6 67 59 43 10 7e c1 49 cd 5e f9 97 a 58 5f 8a 11 ef2f 4f 3d 9a e2 2b 22 58 fa be fc 69 91 7a 8c 3f 77 9f c9 3b 54 26 23 93 b3 ef47 85 de ae f5 bd c5 47 4c c4 cd 5e ad bc 8f ba 31 f6 e4 70 fb 6e a7 96 d5 ef5f ad 10 80 39 43 97 4f 10 cc 1b 8f 8d cd 4c 63 4 d8 1e 85 70 41 6c a8 eb df ef78 7f 36 c5 60 a7 12 9 16 73 fe 75 3a 2d 40 29 7d aa a 5c 2 29 23 0 a6 e5 6b ef92 24 6d 9b 20 e5 7 cb 40 b0 38 59 9c a7 69 6a 70 d3 38 ef e2 b2 11 3e ea 2a efab f9 2b 2e 43 1d 65 cf d6 1b ef 83 5a 5f e6 c5 62 16 ca 5e 4c a6 39 e4 53 efc3 2d 23 d2 5e 7e 15 54 8a 8 b7 3d bb 88 59 b9 9e a2 7c 42 1f a2 77 3c 5b 9 efdc 6d fa 8f 21 46 1a 3e ed ce 49 56 1d 29 2d 70 3 a7 6f 75 ac 1 87 ff 27 86 eff5 73 49 28 85 2d 97 7a 84 e 37 3d 86 10 21 4c e2 74 62 6b 51 70 8f 15 72 f3 e100e 81 b2 a9 9d 8a 63 ad 1b d5 aa 8a dc 96 3c e7 47 16 51 fc 87 50 9 b7 60 e1026 29 33 52 fb b0 df 70 c5 65 4a 60 3b c d7 a8 29 47 51 f7 8a 77 f3 99 3f e103e 38 16 60 de 68 27 b2 24 7 62 a2 fd 40 86 b2 75 c3 3c 2f 3d fa 9 d9 a9 9a e1057 71 3c ce 46 94 0 f9 bc 46 7f b8 2e 85 7f 7d d3 8d ea b4 63 81 59 10 bb e106f 57 d0 b6 ab e1 83 74 1e 25 d5 73 78 18 b1 60 62 c f4 76 8d 17 d5 ed 23 e1087 23 e4 f6 32 64 5a 61 9 63 f6 92 57 d5 29 40 d6 3b ba 63 72 18 0 25 1b 7 e10a0 ee 7f 25 4a fa 6 74 19 46 e3 e8 89 7a c6 56 54 a7 43 13 4e bf 97 a5 6f e10b8 99 2f ac 33 4d fa 58 3a 5a a a4 1a 74 62 c8 4f 3b 78 9 d7 ee 7e ee 2d 69 e10d1 30 40 ea 47 82 3b 85 8e 3 23 8f 74 4e 8 35 ab 74 4 1 57 d5 85 b1 6b 1e e10ea f4 7d 1e d2 1e b3 fe f3 12 10 32 39 51 48 2d 6f e5 d3 a3 8c 8 8 g rcx fff n1.com w q   \n  ","date":1383130214,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1383130214,"objectID":"71e9342c1220ac3aa81bfc3f5346fa9e","permalink":"/post/csdn/%E5%9B%BD%E9%99%85%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%E4%B8%80%E7%AD%89%E5%A5%96%E4%BD%9C%E5%93%81%E6%AC%A3%E8%B5%8F/","publishdate":"2013-10-30T18:50:14+08:00","relpermalink":"/post/csdn/%E5%9B%BD%E9%99%85%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%E4%B8%80%E7%AD%89%E5%A5%96%E4%BD%9C%E5%93%81%E6%AC%A3%E8%B5%8F/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 国际程序设计大赛一等奖作品这个程序(omni.com)是97年的Mekka ’97 4K Intro比赛的一","tags":[],"title":"国际程序设计大赛一等奖作品欣赏","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n     有些东西，死活都记不住。。       安装 ufw  sudo apt-get install ufw    启用 ufw  sudo ufw enable    全局限制访问  sudo ufw default deny    打开端口  sudo ufw allow 22    开放/禁止 IP 访问  sudo ufw allow from 10.0.0.162 sudo ufw deny from 10.0.0.162        ","date":1383024488,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1383024488,"objectID":"dbb50d076686b1717297e285306b01bb","permalink":"/post/csdn/ufw-%E7%9B%B8%E5%85%B3/","publishdate":"2013-10-29T13:28:08+08:00","relpermalink":"/post/csdn/ufw-%E7%9B%B8%E5%85%B3/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 有些东西，死活都记不住。。 安装 ufw sudo apt-get install ufw 启用 ufw sudo ufw enable 全局限制访问 sudo ufw default deny 打开端口 sudo ufw allow 22 开放/禁止 IP","tags":["ufw"],"title":"ufw 相关","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n   安装好 LAMP 环境   方法： http://blog.csdn.net/kzzhr/article/details/12755671   下载 HUSTOJ   HUSTOJ 主页 http://code.google.com/p/hustoj/   我下载了 安装包 install.rxxxx.tar.gz  上传至服务器  #scp -r /home/foo/isntall foo@xxx.xx.xxx.xxx:/var/www   安装中的那些事儿～   install/README 中有详细的安装教程。所以这里只说一些其中的注意事项    由于 ubuntu 10.04 以上的机器中服务启动需要用 service NAME BEHAVE 。所以开启judge服务需要用 service juded start   安装好之后会默认以 root+root 连接数据库，然后下来该下数据库配置，改的时候注意web和core的配置都要改。  web端：/var/www/JudgeOnline/include/db_info.inc.php  core端：/home/judge/etc/judge.conf  配置解析见 https://code.google.com/p/hustoj/wiki/Configuration          ","date":1381859200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1381859200,"objectID":"ee3879e8795b1187db6a8163203372cf","permalink":"/post/csdn/ubuntu-%E5%AE%89%E8%A3%85-hustoj/","publishdate":"2013-10-16T01:46:40+08:00","relpermalink":"/post/csdn/ubuntu-%E5%AE%89%E8%A3%85-hustoj/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 安装好 LAMP 环境 方法： http://blog.csdn.net/kzzhr/article/details/12755671 下载 HUSTOJ HUSTOJ 主页 http://code.google.com/p/hustoj/ 我下载了 安装包 install.rxxxx.tar.gz 上传至服务器 #scp -r /home/foo/isntall foo@xxx.xx.xxx.xxx:/var/www 安装中的那些事儿～ install/README 中有详细的","tags":["HUSTOJ","Algorithm","ACM"],"title":"ubuntu 安装 HUSTOJ","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  用了无数次的XAMPP，终于自己搭一次了。。。。      安装 Linux    我装的是ubuntu。。    安装 Apache2   apt-get install apache2 装好之后，apache 的配置目录是 /etc/apache2 ，localhost 的目录是 /var/www/   打开浏览器看到 it works 说明装好了。    安装 Mysql   apt-get install mysql-server-5.5 mysql-client-5.5 注意安装过程中要设置root账户密码，     安装 php 和 Apache php5 模块   apt-get install php5 php5-mysql libapache2-mod-php5 装好之后重启apache可以加载上php服务   /etc/init.d/apache2 restart // ubuntu 10.04 以上的用户请看下面  注意：ubuntu 10.04 以后修改了启动方式，对于服务的开启也不能去使用 init.d 了。需要用 service apache2 restart 。其他服务类似。    接下来，把首页的 index.html 改成 index.php 里面随便加一句 \u0026lt;?php echo \"ok!\"; ?\u0026gt; 。打开localhost能显示说明安装成功。     安装 phpMyAdmin   apt-get install phpmyadmin 注意一下安装目录在 /usr/share/phpmyadmin/ ，需要链接到 站点目录下   sudo ln -s /usr/share/phpmyadmin /var/www 进入 localhost/phpmyadmin/ 即可进入     参考资料： http://wiki.linuxdeepin.com/index.php?title=LAMP%E6%9C%8D%E5%8A%A1    ","date":1381842796,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1381842796,"objectID":"7754ed845a90d5e1bcf0642b332f925c","permalink":"/post/csdn/lamp-%E7%9A%84%E6%90%AD%E5%BB%BA/","publishdate":"2013-10-15T21:13:16+08:00","relpermalink":"/post/csdn/lamp-%E7%9A%84%E6%90%AD%E5%BB%BA/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 用了无数次的XAMPP，终于自己搭一次了。。。。 安装 Linux 我装的是ubuntu。。 安装 Apache2 apt-get install apache2 装好之后，","tags":["LAMP"],"title":"LAMP 的搭建","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  昨天诸事不顺，看来还是可以攒点人品。   先说说比赛过程吧（这个比较有价值但很容易忘记）    继续昨天的诸事不顺，进了考场，显示器跟键盘侧位一尺多，叫我怎么敲代码！？更可恶的，我们队的信封呢？？找了半天隔壁队伍告诉我说志愿者给拿走了。我去找负责人，半天不理我最后说没拿，“旁边队伍说你们拿走了”、“没拿没拿\"。一堆人围观，一个挺年轻的老师（其实连工作证都没有不知道是干嘛的）问是不是120队，然后跑去拿了过来。。虽然芝麻大的事，但按照我的脾气这种事情你服务不好就是很讨厌，心情不爽。      破oj登了看不到题目显示private，蛋疼，过了半天上面漂字重新登陆，进去都开了三分钟了！（这个时候一血已经被拿了）。ABC一人看一道，突然觉得状态不佳，我拿的A题描述才看完春哥就给了我C题直接码，A之，第六名。下来应该是JG吧，现在都记不住题目了，反正很水，就是模拟之类的吧，我记得貌似还只有一组测试数据。出三题，十几名的样子。      春哥看完了那个潮涨潮落的淹桥题，100000*100000不行，突然想到对于每次涨潮只需淹掉一段连续的区间。想都没想就树状数组了，其中因为 lower_bound 不会用，耽误了好一会，貌似这个时候就有人出5题了。。赛前看到了HIT的课件发现这个函数实在好用，只是从没用过，完全把省赛当练兵场了。最后突然发现要更新一段区间，树状数组目测无力了。哭了，都半个多小时了在这个题上。绝望。刷榜单已经有5题了，郁闷，加上本身心情不好，略怒。拿出算法术突然突然找见了一段 “区间插入单点查询” 的模版，完全看不懂的代码但感觉可用。copy之，A了第四题，这个时候排名记得都滚下去了。这个时候学长还都是三题，原以为这个区间操作鑫固会拿线段树做，结果到最后也没有做。      下来图论，最短路径哈哈，闭着眼睛都能写出来。春哥想多了出了一大堆数据，最后一组数据我的程序跑出的结果跟春哥的答案竟然不一样！凭借对自己的信心觉得应该交一下，交了过了。A出5道题，10名出头吧，差一点一等记得是。这个时候还不到12点，三小时内A出五道题，很不容易了，热身赛都没有的成绩。剩下俩小时至少搞一道吧。出6题，二等一定拿上了。可以拼一下一等的7道。      结果证明后面那两小时就是虚过去的，随便磨蹭了一下，写了个头文件就12点快半了。写完WA了。发现DP方程错了。改不对。再改，不对。慌了。还有一个小时，（封浜了）。A题吧，打印了那个代码他俩看我开始码A题，A题有点像USACO上那个在一串乱码中找出最长回文串。不过加了点容差能力。码了十分钟发现方法搞错了，重码，半个小时就过去了。样例都过不了。。。伤心。      剩下20分钟发现了DP的问题，我当成背包了于是先枚举30种东西再枚举容量，后来发现丢掉了 先*后+ 的情况。于是调换了两层循环。先枚举1~100000；样例都不对。慌了都。再改，又WA，前后WA了四五次。慌了烦了。淡定淡定淡定淡定淡定，“别着急慢慢来”是跟乾哥合作以来乾哥对我说的最多的话，我脾气大，对什么都挑三拣四的，一有一点点不顺心就会非常愤怒。乾哥心宽，什么都看的开，很镇定。淡定了一下，突然觉得把“+*”重复几遍就可以解决先*后+ 的问题，循环十遍超时，改成五遍A掉了！1:57.就剩三分钟 了搞出一道题，6道题，应该可以保二等了。      再说说对接下来的打算吧。    比较意外的是拿到了区域赛资格，本来觉得不会有就没怎么认真准备高级算法，这次机会下来了还是想去拼一拼。一个月内把乱七八糟的DP 看一看，高阶线段树和树状数组、网络流。看起来不是很多，只是太难了。跟队友商量一下大致安排，备战区域赛。   还有一块略纠结的事情就是关于 Go 的学习，已经耽误很久了。每次想学一个东西都要磨磨蹭蹭很久最后找一块时间才发现原来如此简单。如果没有区域赛一定有充足的时间去学了。只是突然来这么一下，等区域赛完了再说吧。。  另外一个大头就是招新的事情，一方面今年成绩不咋地，对于那些有实力但更倾向于成绩的人可以会有点不感冒。  关于培训，说实话，去年的培训真的很不像样子。匆忙低效。今年我的想法是慢慢来，最好可以跟教练要下教室，踏踏实实的带大家从码代码做起一点一滴的走。去年上学期一节课带过语法没有数据结构，直接开算法，大家根本接受不了。我觉得这学期对大一的搞两三周语法，然后过数据结构。对去年参加过培训的大二直接讲数据结构，但都不开算法。到明年继续开数据结构连带树上和图上的算法。真正进入校队后再培训算法，暑假的安排还是觉得应该培训。看过其它学校的培训，大多数还是靠那一个暑假的学习。另外讲课的人选，今年缺人手，老队员作为省赛主力一旦离开就会产生很大的空缺。（我一直觉得让新队员去自己交流学习很靠不住，没有传承，没有留下一套稳定的培训机制，只能是碰上一届是一届）。今年进来的开始慢慢准备了，我想在开课值钱做一些适当的试讲，总之希望讲课的效果达到最好。关于宣传，很多事情还不太明            ","date":1381771635,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1381771635,"objectID":"b5a422440cf11e7cc28cf0a482bb48b5","permalink":"/post/csdn/%E9%9D%9E%E6%8A%80%E6%9C%AF%E8%B4%B4%E8%AE%B0%E6%B9%96%E5%8D%97%E7%9C%81%E7%AC%AC%E4%B9%9D%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/","publishdate":"2013-10-15T01:27:15+08:00","relpermalink":"/post/csdn/%E9%9D%9E%E6%8A%80%E6%9C%AF%E8%B4%B4%E8%AE%B0%E6%B9%96%E5%8D%97%E7%9C%81%E7%AC%AC%E4%B9%9D%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 昨天诸事不顺，看来还是可以攒点人品。 先说说比赛过程吧（这个比较有价值但很容易忘记） 继续昨天的诸事不顺","tags":[],"title":"【非技术贴】记湖南省第九届程序设计大赛","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n     维护一个单调队列，对于每一个新的元素：  如果大于队尾元素，补在后面；  否则替换掉最小的大于它的数，这里用二分查找，因此时间复杂度为logn    演示一下：  1 3 7 5 9 4 8  1  1 3  1 3 7  1 3 5  1 3 5 9  1 3 4 9  1 3 4 8   #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int a[1111],n,k,m; int main(){ cin \u0026gt;\u0026gt; n; for (int i(1);i\u0026lt;=n;i++){ cin \u0026gt;\u0026gt; k; if ( k\u0026gt;a[m] ) a[++m]=k; else a[upper_bound(a+1,a+m,k)-a] = k;\t} cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; return 0; }          ","date":1380726718,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1380726718,"objectID":"0867a2061645f1387f1bcf49938c03dc","permalink":"/post/csdn/longest-ordered-subsequence-onlogn%E8%A7%A3%E6%B3%95-stl/","publishdate":"2013-10-02T23:11:58+08:00","relpermalink":"/post/csdn/longest-ordered-subsequence-onlogn%E8%A7%A3%E6%B3%95-stl/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 维护一个单调队列，对于每一个新的元素： 如果大于队尾元素，补在后面； 否则替换掉最小的大于它的数，这里用","tags":["Longest"],"title":"Longest Ordered Subsequence   O(nlogn)解法 STL","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  一、提交格式代码   import java.util.*; public class Main{ public static void main(String[] args){ Scanner cin = new Scanner(System.in)); } }  二、输入    cin.hasNext() 或 cin.hasNextInt() 或 cin.hasNextDouble() // 判断是否有下一个输入可以用 int n = cin.nextInt(); String s = cin.next(); double t = cin.nextDouble(); String s = cin.nextLine();   三、浮点控制   DecimalFormat g = new DecimalFormat(\"0.00\"); double a = 123.45678; System.out.println(g.format(a)); // 输出 123.46   四、高精度    import java.math.*; // 需要引入math库 BigInteger a = BigInteger.valueOf(1000000); BigInteger b = BigInteger.valueOf(10000); System.out.println(a.add(b)); System.out.println(a.subtract(b));\tSystem.out.println(a.multiply(b)); System.out.println(a.divide(b));\tSystem.out.println(a.mod(b)); System.out.println(a.compareTo(b));\t// 返回值 -1,0,1   五、字符串    s.substring(a,b);  包含 s[a]不包含 s[b] , 共 b-a 个字符 String a = \"0123456789\"; System.out.println(a.substring(2,5)); // 输出 234  六、数组    int[] a = new int[123]; Arrays.fill(a,123);\tSystem.out.println(a[3]); // 输出 123  一个例题    Very Simple Arithmetic     题目大意：给你一个简单的式子求出对应的结果。我发现这完全就是为了练习java而做的题目。。     import java.util.*; import java.math.*; public class Main{ public static void main(String[] args){ Scanner cin = new Scanner(System.in); while ( cin.hasNextBigDecimal() ){ BigDecimal a = cin.nextBigDecimal(); String op = cin.next(); BigDecimal b = cin.nextBigDecimal(); if ( op.equals(\"+\") ){ System.out.println(a.add(b)); }else if ( op.equals(\"-\") ){ System.out.println(a.subtract(b)); }else if ( op.equals(\"*\") ){ System.out.println(a.multiply(b)); }else if ( op.equals(\"/\") ){ int c = cin.nextInt(); BigDecimal res[] = a.divideAndRemainder(b); System.out.println(res[0]+\" \"+res[1]+\" \"+a.divide(b,c,BigDecimal.ROUND_HALF_UP).toPlainString()); } } } }          ","date":1380113099,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1380113099,"objectID":"00346e98dee5854155b0050c29df7c45","permalink":"/post/csdn/java-for-acm-%E5%B0%8F%E7%BB%93/","publishdate":"2013-09-25T20:44:59+08:00","relpermalink":"/post/csdn/java-for-acm-%E5%B0%8F%E7%BB%93/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 一、提交格式代码 import java.util.*; public class Main{ public static void main(String[] args){ Scanner cin = new Scanner(System.in)); } } 二、输入 cin.hasNext() 或 cin.hasNextInt() 或 cin.hasNextDouble() // 判断是否有下一个输入可以用 int n","tags":["Java"],"title":"Java for ACM 小结","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  以前就开始看刘汝佳的白皮书了，不过眼高手低，没有码过，发现问题好多。于是开始敲一敲。  题意：   空间有n个点，分成n/2对，使得所有点集的两点之间的距离之和最小。        d(s) = min{ d(s-i-j) } i,j 属于 s      PS：只有20个点，每个点可以取可以不取，所以用20位的二进制数来表示每个状态。      要注意的是，i,j 是不需要一个一个都枚举的，会有重复。比如1234会有12+34，又会有34+12造成浪费。如果是123456就会浪费更多。可以假设最小的1是当前取得，那么只要 找 12,13,14,15,16 。      #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; typedef struct{ int x,y,z; }NODE; NODE g[22]; int n,k; double d[1\u0026lt;\u0026lt;22]; double dis(int i,int j){ NODE a(g[i]), b(g[j]); return sqrt(((double)(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z))); } int main(){ cin \u0026gt;\u0026gt; n; for (int i(0);i\u0026lt;n;i++) cin \u0026gt;\u0026gt; g[i].x \u0026gt;\u0026gt; g[i].y \u0026gt;\u0026gt; g[i].z; for ( int i(1);i\u0026lt;(1\u0026lt;\u0026lt;n);i++){ d[i] = 1e10; int k; for (k=0;k\u0026lt;n;k++) if ( i \u0026amp; (1\u0026lt;\u0026lt;k) ) break; for (int j(k+1);j\u0026lt;n;j++) if (i \u0026amp; (1\u0026lt;\u0026lt;j)) d[i] = min(d[i],dis(k,j)+d[i^(1\u0026lt;\u0026lt;j)^(1\u0026lt;\u0026lt;k)]); } cout \u0026lt;\u0026lt; d[(1\u0026lt;\u0026lt;n)-1] \u0026lt;\u0026lt; endl; return 0; }         ","date":1379825629,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1379825629,"objectID":"2a2c7550e642f334060946904fd256b7","permalink":"/post/csdn/%E7%82%B9%E9%9B%86%E9%85%8D%E5%AF%B9%E9%97%AE%E9%A2%98-%E9%9B%86%E5%90%88dp-%E6%8C%89%E4%BD%8Ddp/","publishdate":"2013-09-22T12:53:49+08:00","relpermalink":"/post/csdn/%E7%82%B9%E9%9B%86%E9%85%8D%E5%AF%B9%E9%97%AE%E9%A2%98-%E9%9B%86%E5%90%88dp-%E6%8C%89%E4%BD%8Ddp/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 以前就开始看刘汝佳的白皮书了，不过眼高手低，没有码过，发现问题好多。于是开始敲一敲。 题意： 空间有n个","tags":[],"title":"点集配对问题   集合DP 按位DP","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n 很早前写的那篇线段树专辑至今一直是本博客阅读点击量最大的一片文章,当时觉得挺自豪的,还去pku打广告,但是现在我自己都不太好意思去看那篇文章了,觉得当时的代码风格实在是太丑了,很多线段树的初学者可能就是看着这篇文章来练习的,如果不小心被我培养出了这么糟糕的风格,实在是过意不去,正好过几天又要给集训队讲解线段树,所以决定把这些题目重新写一遍,顺便把近年我接触到的一些新题更新上去~;并且学习了splay等更高级的数据结构后对线段树的体会有更深了一层,线段树的写法也就比以前飘逸,简洁且方便多了.   在代码前先介绍一些我的线段树风格:   maxn是题目给的最大区间,而节点数要开4倍,确切的来说节点数要开大于maxn的最小2x的两倍  lson和rson分辨表示结点的左儿子和右儿子,由于每次传参数的时候都固定是这几个变量,所以可以用预定于比较方便的表示  以前的写法是另外开两个个数组记录每个结点所表示的区间,其实这个区间不必保存,一边算一边传下去就行,只需要写函数的时候多两个参数,结合lson和rson的预定义可以很方便  PushUP(int rt)是把当前结点的信息更新到父结点  PushDown(int rt)是把当前结点的信息更新给儿子结点  rt表示当前子树的根(root),也就是当前所在的结点  整理这些题目后我觉得线段树的题目整体上可以分成以下四个部分:   单点更新:最最基础的线段树,只更新叶子节点,然后把信息用PushUP(int r)这个函数更新上来  hdu1166 敌兵布阵 http://acm.hdu.edu.cn/showproblem.php?pid=1166   题意:O(-1)  思路:O(-1)  线段树功能:update:单点增减 query:区间求和    #include \u0026lt;cstdio\u0026gt; #define lson l , m , rt \u0026lt;\u0026lt; 1 #define rson m + 1 , r , rt \u0026lt;\u0026lt; 1 | 1 const int maxn = 55555; int sum[maxn\u0026lt;\u0026lt;2]; void PushUP(int rt) { sum[rt] = sum[rt\u0026lt;\u0026lt;1] + sum[rt\u0026lt;\u0026lt;1|1]; } void build(int l,int r,int rt) { if (l == r) { scanf(\"%d\",\u0026amp;sum[rt]); return ; } int m = (l + r) \u0026gt;\u0026gt; 1; build(lson); build(rson); PushUP(rt); } void update(int p,int add,int l,int r,int rt) { if (l == r) { sum[rt] += add; return ; } int m = (l + r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= m) update(p , add , lson); else update(p , add , rson); PushUP(rt); } int query(int L,int R,int l,int r,int rt) { if (L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R) { return sum[rt]; } int m = (l + r) \u0026gt;\u0026gt; 1; int ret = 0; if (L \u0026lt;= m) ret += query(L , R , lson); if (R \u0026gt; m) ret += query(L , R , rson); return ret; } int main() { int T , n; scanf(\"%d\",\u0026amp;T); for (int cas = 1 ; cas \u0026lt;= T ; cas ++) { printf(\"Case %d:\\n\",cas); scanf(\"%d\",\u0026amp;n); build(1 , n , 1); char op[10]; while (scanf(\"%s\",op)) { if (op[0] == 'E') break; int a , b; scanf(\"%d%d\",\u0026amp;a,\u0026amp;b); if (op[0] == 'Q') printf(\"%d\\n\",query(a , b , 1 , n , 1)); else if (op[0] == 'S') update(a , -b , 1 , n , 1); else update(a , b , 1 , n , 1); } } return 0; }     hdu1754 I Hate It  http://acm.hdu.edu.cn/showproblem.php?pid=1754   题意:O(-1)  思路:O(-1)  线段树功能:update:单点替换 query:区间最值   #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; #define lson l , m , rt \u0026lt;\u0026lt; 1 #define rson m + 1 , r , rt \u0026lt;\u0026lt; 1 | 1 const int maxn = 222222; int MAX[maxn\u0026lt;\u0026lt;2]; void PushUP(int rt) { MAX[rt] = max(MAX[rt\u0026lt;\u0026lt;1] , MAX[rt\u0026lt;\u0026lt;1|1]); } void build(int l,int r,int rt) { if (l == r) { scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;MAX[rt]); return ; } int m = (l + r) \u0026gt;\u0026gt; 1; build(lson); build(rson); PushUP(rt); } void update(int p,int sc,int l,int r,int rt) { if (l == r) { MAX[rt] = sc; return ; } int m = (l + r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= m) update(p , sc , lson); else update(p , sc , rson); PushUP(rt); } int query(int L,int R,int l,int r,int rt) { if (L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R) { return MAX[rt]; } int m = (l + r) \u0026gt;\u0026gt; 1; int ret = 0; if (L \u0026lt;= m) ret = max(ret , query(L , R , lson)); if (R \u0026gt; m) ret = max(ret , query(L , R , rson)); return ret; } int main() { int n , m; while (~scanf(\u0026quot;%d%d\u0026rdquo;,\u0026amp;n,\u0026amp;m)) { build(1 , n , 1); while (m \u0026ndash;) { char op[2]; int a , b; scanf(\u0026quot;%s%d%d\u0026rdquo;,op,\u0026amp;a,\u0026amp;b); if (op[0] == \u0026lsquo;Q\u0026rsquo;) printf(\u0026quot;%d\\n\u0026rdquo;,query(a , b , 1 , n , 1)); else update(a , b , 1 , n , 1); } } return 0; }\n  ","date":1377963470,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1377963470,"objectID":"9ac4f8cfa12e6bbe5668d9b2d32606ca","permalink":"/post/csdn/notonlysuccess-%E7%BA%BF%E6%AE%B5%E6%A0%91-%E9%AB%98%E4%BA%BA%E6%8E%A8%E8%8D%90/","publishdate":"2013-08-31T23:37:50+08:00","relpermalink":"/post/csdn/notonlysuccess-%E7%BA%BF%E6%AE%B5%E6%A0%91-%E9%AB%98%E4%BA%BA%E6%8E%A8%E8%8D%90/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 很早前写的那篇线段树专辑至今一直是本博客阅读点击量最大的一片文章,当时觉得挺自豪的,还去pku打广告","tags":["notonlysuccess"],"title":"notonlysuccess 线段树 高人推荐","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  思路   看上去是个线段树，不过每个元素都移动，树结构本身无法实现这个功能，只能一个一个的修改，但是里面的技巧还是有的。学长的代码都上百行了，贴一帖我的60行代码，细节上有点优化处理。   代码   #include \u0026lt;cstdio\u0026gt; #define N 101010 struct rec{ int l,r,v; }t[N*5]; int n,m,a[N],p[30]; int minn(int a,int b){ if (a\u0026lt;b) return a; return b; } void build(int root, int l, int r){ t[root].l = l; t[root].r = r; if ( l==r ) { t[root].v = a[l]; return ; } int mid = (l+r)/2; build(root*2,l,mid); build(root*2+1,mid+1,r); t[root].v = minn(t[root*2].v,t[root*2+1].v); } void update(int root, int x){ if ( t[root].l == x \u0026amp;\u0026amp; t[root].r == x ) { t[root].v = a[x]; return ; } int mid = (t[root].l+t[root].r)/2; if ( mid \u0026lt; x ) update(root*2+1,x); else update(root*2,x); t[root].v = minn(t[root*2].v,t[root*2+1].v); } int getv(int root,int l,int r){ if ( t[root].l == l \u0026amp;\u0026amp; t[root].r == r ) { return t[root].v; } int mid = (t[root].l+t[root].r)/2; if ( l\u0026gt;mid ) return getv(root*2+1,l,r); if ( r\u0026lt;=mid) return getv(root*2,l,r); return minn(getv(root*2,l,mid),getv(root*2+1,mid+1,r)); } int main(){ scanf(\"%d%d\",\u0026amp;n,\u0026amp;m); for (int i(1);i\u0026lt;=n;i++){ scanf(\"%d\",\u0026amp;a[i]); }scanf(\"\\n\"); build(1,1,n); while (m--){ char c,c2; scanf(\"%c%c%c%c%c%c\",\u0026amp;c,\u0026amp;c2,\u0026amp;c2,\u0026amp;c2,\u0026amp;c2,\u0026amp;c2); if ( c=='q' ){ int ax,bx; scanf(\"%d,%d)\\n\",\u0026amp;ax,\u0026amp;bx); printf(\"%d\\n\",getv(1,ax,bx)); }else{ int j = 0; while ( scanf(\"%d,\",\u0026amp;p[++j])==1 ); j--; scanf(\")\\n\"); int tt=a[p[1]]; for ( int i(1);i\u0026lt;j;i++ ) a[p[i]] = a[p[i+1]]; a[p[j]] = tt; for ( int i(1);i\u0026lt;=j;i++) update(1,p[i]); } } return 0; }   题目       Problem K: RMQ with Shifts  Time Limit:  1 Sec Memory Limit:  128 MB  Submit:  12 Solved:  5  [ Submit  ][ Status  ][ Web Board  ] [ Edit  ]   Description   In the traditional RMQ (Range Minimum Query) problem, we have a static array A. Then for each query (L, R) (L\u0026lt;=R), we report the minimum value among A[L], A[L+1], …, A[R]. Note that the indices start from 1, i.e. the left-most element is A[1].   In this problem, the array A is no longer static: we need to support another operation shift(i1, i2, i3, …, ik) (i1\u0026lt;i2\u0026lt;...\u0026lt;ik, k\u0026gt;1): we do a left “circular shift” of A[i1], A[i2], …, A[ik].   For example, if A={6, 2, 4, 8, 5, 1, 4}, then shift(2, 4, 5, 7) yields {6, 8, 4, 5, 4, 1, 2}. After that, shift(1,2) yields {8, 6, 4, 5, 4, 1, 2}.     Input   There will be only one test case, beginning with two integers n, q (1\u0026lt;=n\u0026lt;=100,000, 1\u0026lt;=q\u0026lt;=120,000), the number of integers in array A, and the number of operations. The next line contains n positive integers not greater than 100,000, the initial elements in array A. Each of the next q lines contains an operation. Each operation is formatted as a string having no more than 30 characters, with no space characters inside. All operations are guaranteed to be valid. Warning: The dataset is large, better to use faster I/O methods.    Output   For each query, print the minimum value (rather than index) in the requested range.    Sample Input  7 56 2 4 8 5 1 4query(3,7)shift(2,4,5,7)query(1,4)shift(1,2)query(2,2)    Sample Output  146    HINT     [ Submit  ][ Status  ][ Web Board  ]    한국어  中文  فارسی  English  ไทย   Anything about the Problems, Please Contact Admin: admin   All Copyright Reserved 2010-2013 HUSTOJ  TEAM  GPL2.0   2003-2013 HUSTOJ Project  TEAM       ","date":1377101462,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1377101462,"objectID":"63b4f8d0caf9bff0b53154d8b4f8c8c5","permalink":"/post/csdn/rmq-with-shifts-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%9F%BA%E5%9F%BA%E7%A1%80/","publishdate":"2013-08-22T00:11:02+08:00","relpermalink":"/post/csdn/rmq-with-shifts-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%9F%BA%E5%9F%BA%E7%A1%80/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 思路 看上去是个线段树，不过每个元素都移动，树结构本身无法实现这个功能，只能一个一个的修改，但是里面的","tags":["RMQ"],"title":"RMQ with Shifts 线段树基基础","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目： http://acm.hit.edu.cn/hoj/problem/view?id=2651   很简单的二分枚举，  要注意的是   1、一共是 f+1 个人（包括他自己）    2、精度问题。。被吭了好久，我把面积*e5 按道理应该可以了不知道为什么总是WA，改成e6后AC了。    # include \u0026lt;iostream\u0026gt; # include \u0026lt;cstdio\u0026gt; # include \u0026lt;cmath\u0026gt; # define PI acos(-1) using namespace std; long long c[11111],s,l,r,mid,ans; int N,n,f; int judge(){ int num = 0; for (int i(1);i\u0026lt;=n;i++){ num += c[i]/mid; } return num\u0026gt;f; } int main(){ cin \u0026gt;\u0026gt; N; while (N--){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; f; long long s=0,ans=0; for (int i(1);i\u0026lt;=n;i++) { cin \u0026gt;\u0026gt; c[i]; c[i] = c[i]*c[i]*PI*1000000; s += c[i]; } for (l=0,r=s;l\u0026lt;=r;){ mid = (l+r)/2; if (judge()){ l=mid+1; ans=mid; }else{ r=mid-1; } } printf(\"%.4lf\\n\",(double)ans/1000000); } return 0; }     ","date":1372323389,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1372323389,"objectID":"6b52d30a92d7bc9467f9448fce574abf","permalink":"/post/csdn/hoj-2651-pie/","publishdate":"2013-06-27T16:56:29+08:00","relpermalink":"/post/csdn/hoj-2651-pie/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目： http://acm.hit.edu.cn/hoj/problem/view?id=2651 很简单的二分枚举， 要注意的是 1、一共是 f+1 个人（包括他自己） 2、精度问题。。被吭了好久，我把面","tags":["HOJ","Algorithm","ACM"],"title":"HOJ 2651 PIE","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目： http://acm.hdu.edu.cn/showproblem.php?pid=4152   队长大人给某菜鸟赛出的题，但是却让我傻了半天。  裸暴力，由于数据弱，我直接用了位运算标记，其实这个题目用位运算一点优势都没有。  # include \u0026lt;cstdio\u0026gt; # include \u0026lt;cstring\u0026gt; int d[20]= {1},a[22][22],c[22],fn[22],n,m; int yes() { for (int i(1); i\u0026lt;=n; i++) { if (c[i]\u0026lt;fn[i]) return 0; } return 1; } int main() { for (int i(1); i\u0026lt;=18; i++) d[i]=d[i-1]*2; while (scanf(\"%d\",\u0026amp;n)!=EOF) { for (int i(1); i\u0026lt;=n; i++) scanf(\"%d\",\u0026amp;fn[i]); scanf(\"%d\",\u0026amp;m); for (int i(1); i\u0026lt;=m; i++) { for (int j(1); j\u0026lt;=n; j++) { scanf(\"%d\",\u0026amp;a[i][j]); } } int ans=0,ansi=0; for (int i(d[m+1]-1); i\u0026gt;=0; i--) { memset(c,0,sizeof(c)); int num = 0; for (int j(1); j\u0026lt;=m; j++) { if (i\u0026amp;d[j-1]) { num++; for (int k(1); k\u0026lt;=n; k++) c[k] += a[j][k]; } } if (yes() \u0026amp;\u0026amp; num \u0026gt;= ans) { ans = num; ansi = i; } } printf(\"%d\",ans); for (int i(0); i\u0026lt;m; i++) { if (ansi \u0026amp; d[i]) printf(\" %d\",i+1); } printf(\"\\n\"); } return 0; }     ","date":1372271925,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1372271925,"objectID":"b48e7473548667479c1eb4778c7d9ebd","permalink":"/post/csdn/hdoj-4152-zzys-dilemma/","publishdate":"2013-06-27T02:38:45+08:00","relpermalink":"/post/csdn/hdoj-4152-zzys-dilemma/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目： http://acm.hdu.edu.cn/showproblem.php?pid=4152 队长大人给某菜鸟赛出的题，但是却让我傻了半天。 裸暴力，由于数据弱，我直接用了位运算标记，其实","tags":["HDOJ","Algorithm","ACM"],"title":"HDOJ 4152 ZZY’s Dilemma","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目： http://openoj.awaysoft.com:8080/judge/problem/viewProblem.action?id=14179   三分入门题目  三分：  区间上求凸（凹）点时，把区间ad分为 abcd  其中 b = ( a+d) / 2 ;    c = ( b + d) / 2;  比较b和c哪个更好，依次类推。    #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; double H,h,d,x,l,r,ans; double hid(double x){\t// x 表示人到墙的距离 return (h*d-H*x)/(d-x)+x; } int main(){ int N; cin \u0026gt;\u0026gt; N; while (N--){ cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; h \u0026gt;\u0026gt; d; ans = 0; for (l=0,r=(d*h)/H;l+0.0001\u0026lt;r;){ double mid = (l+r)/2; double mid2 = (mid+r)/2; if (hid(mid) \u0026gt;= hid(mid2)){ r = mid2; }else { l = mid; } } printf(\"%.3lf\\n\",hid(l)); } return 0; }   ","date":1372271679,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1372271679,"objectID":"4ba25b790d868dd218abf9ab7d6d86b0","permalink":"/post/csdn/zoj-3203-light-bulb/","publishdate":"2013-06-27T02:34:39+08:00","relpermalink":"/post/csdn/zoj-3203-light-bulb/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目： http://openoj.awaysoft.com:8080/judge/problem/viewProblem.action?id=14179 三分入门题目 三分： 区间上求凸（凹）点时，把区间ad分为 abcd 其中 b = ( a+d) / 2 ; c = ( b + d) / 2; 比","tags":["ZOJ","Algorithm","ACM"],"title":"ZOJ 3203 Light Bulb","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n 原题：《 WWDC2013，苹果向世界宣战 》，觉得有些太大了就撤掉了，直到第二天36Kr的报道也使用类似措辞，才又挂回这里你懂得。 很多人顽强地看完了WWDC，开始了惯有的各种吐槽。虽然我开始看的时候状态也差不多吧，尤其是看到第一个“产品”就是Finder Tabs，说实话，我个人不是很喜欢这个东西，以前在linux下就开始使用了但是感觉并不是多么的便捷。况且Finder本身可以打开一个智能窗口，这个功能很强大，很喜欢，让我目前没有看到tabs有什么重大的意义。 最开始同大家的感觉一样，苹果发布了一堆“无聊”但却是还有点用的东西。但是看到后面就有些不明白了，苹果到底要做什么， 1.首先，这是一个减法的时代，你苹果却开始做加法了，吃饱了撑的么？ 2.就算做加法，怎么竟加一些跟你的“核心竞争力”不沾边的东西？ 很多人的解释是苹果没落了。但是我看着看着却觉得脊梁骨发凉了：苹果这盘棋，怎一个大字了得，全然厚黑之道。（这是昨晚的一条状态。对错先不论）。”厚黑“，看起来和科技界完全不沾边的词第一个跑到了我的脑海里。 如果去仔细看一下这几次苹果的发布会以及媒体的报道，就会发现有一类共同的句子：“某某君，你还好吗？”、“苹果又革（割字或许更好）了谁的命”、“苹果又整合（注意是整合不是集成）了某个服务了”。看到这里，大家又会说，这有什么稀奇的，在中国这种不是太多了吗。就像多年前3Q大战时大家开的玩笑，吃肉长大的狗，不会啃骨头，等肉没了的时候只能狗咬狗了。这样也可以顶一下苹果没落的理由。但是我们想一下，它咬的是谁呢？ 它没有像某某公司一样去把它的竞争对手Android搞掉，相反，他下手的目标是那些跟IOS一起成长起来的开发者们。 开发者，到底是个什么角色？当年苹果设计了全新的操作系统，作为新平台，相比于其它成熟的平台，自然是百业待兴。而对苹果这样连不给人看的电路板都要画的好看的公司来说，让他去设计每一个小功能估计早都累死了。（你傻呀，哪个操作系统不是平台呢？）但是苹果的平台它是一个非常封闭的平台，苹果的控制管理很强。当然我们称之为良性生态圈。所以大家都很乐意为OS开发，同样也造就了一批magic。在其它的平台上，也会由于个人开发者的强大而做出很炫的产品，但是在OS系列上可以产生一大批杰出的作品，这与苹果的引导是分不开的。这样以来，苹果可以专注于系统层面，开发者可以把这个系统打扮的非常精美。看！多和谐！ 大概就是这个时候，开放平台崛起（当然 facebook 也功不可没吧）。做论坛的搞开放平台，做微博的搞开放平台，做音乐的搞开放平台，做桌面的当然更要做开放平台了，做游戏的，恩，你懂得。 开放平台如日中天，极客一词也广为传播。极客们带着自己的梦想，激情，同乔帮主一道改变世界，一起做kings and the queens（多和谐！）。可当苹果的系统层面搞得差不多时（或者说只是开始加强对应用的控制力度），再回过头看看那些 the magic we made，傻眼了。这不是老子辛辛苦苦做的吗？怎么直接被你苹果拿走了？抗议！抗议？哪凉快哪呆着去。 这个时候，那些自以为开放平台做的好的才发现，两个开放平台，根本不是一个性质。你总觉得，开放平台，这是大家一起在一块田上耕作，收成嘛，当然自己拿自己的。但其实，这只是苹果生态圈的一半，另一半呢？在另一半，大家都是苹果这个大地主的佃农。乔大地主自己有点事情，于是找你们帮它耕作，等他那边忙活完了，有时间管这边了，好，你们回家洗洗睡吧。 他行吗？其实，前面说它是良性生态圈的前面还有一句话，这是一个完全受他控制的一块地盘。如果在android下，好家伙，有几个人用的原生android？android开源，让那些禽兽们给糟蹋的四分五裂，google也管不着。但是IOS不一样，人家可以随便编个理由就让你不能上架了（这份痛大家都懂）。更别说之后怎么搞你了。 他敢吗？事实已经很明了了，一个个失眠的产品。我们说苹果地图，虽然最开始出了点小瑕疵，但是这次的回归，感觉还不错吧。因为才发出来，没有引发什么太大的问题。但是即便有了问题，苹果可以很轻松地搞定，也没有人会在意那些。在地图上，google都被动刀子了，而且没有引发争议，其它的小家伙，苹果会怕你们吗？果粉们会真的舍不得你们吗？拿我自己说吧，如果我用的非苹果产品，当我看到如此“垃圾”随处可捡的功能，我只会吐，这破功能人家早有了。苹果不行了啊。但是如果我用的苹果产品，我会觉得，这个功能不错啊。哇！终于来了！当你用上一款苹果产品时，除非特别痛的地方，你根本不会去跟其它的比来比去的。因为这俩系统有些本质上的不同。 （苹果要亲手拆掉自己的生态圈？）当然不是全拆，但是会缩减。苹果，到底是做什么的呢？它的核心竞争力到底在哪里呢？以前你可能会说，卖电脑的。现在，你也许会说，卖手机的。苹果做了哪些产品，你可能会说，设计了一款手机，设计了一款系统。靠IOS成长的起来的第三方公司会说，他打造了一个产业生态圈。把一个很弱智的功能，很容易实现的功能，自己就不做，非留给你们开发者去做。（前面这些话不是我说的，大概是乔布斯死后一些第三方应用公司为表感激而说的）。我的理解，既然他当年可以由于某种原因留给你去做，那么今天他就可以不需要理由把你做的给直接拿走。站在天上丢馅饼？你觉得乔帮主会这么干吗？乔布斯要做的， 就是为人们打造一款完美的产品，一套可以改变人们工作生活学习方式的服务。这套服务，不是一个硬件，不是一个操作系统，不是一堆应用，而是他们的总和。苹果决不会像MS一样，自己只做一个系统，做一套漂亮的SDK，然后你们靠你们去繁荣市场吧。 那苹果会整合哪些产品呢？游戏，我觉得苹果不会做，至少暂时不会去涉猎太多，不过你也不能排除苹果突然有些好点子就整合几个游戏的可能。但是办公方面，应该还是挺明显的吧，我们在windows下会有三方公司定制“装机必备软件”，这些基本的工作上要用的东西，苹果都会去整合。今天在mail上加一个vip，明天或许就出来一个sparrow了也不是没可能。但不得不说，这点对用户是真的很方便的。（facebook它可能一时不会自己去搞，但一定会在自己通讯工具里慢慢渗透。youtube呢？我觉得它会考虑把视频资料整合一下发出来的，Apple TV 也需要资源的。这个有点像做地图，因为现在都有专门的数据公司了，你只需要拿过来加上自己的特色就是了。这些东西虽然很小但是加上却很棒）。这样下来，媒体，它可能不会去做，社交，说不准，这样的话，貌似它什么都敢做了。。。 回到大家很关心的问题，这些变化太无聊了，没有划时代的感觉，其实很简单，如果天天都是划时代，那还叫划时代吗？如果我们再回过头把苹果历次的发布会放到一起，除了在iPhone发布会上给你颠覆的感觉，其它的，也都是一些缝缝补补。当然大多数情况也都会有一款杀手级的应用问世。或许这一年，地图让苹果煞费了苦心。也可能大家都去设计那个不明觉厉的MAC Pro了。 这样说来，苹果召开发布会的初衷，是告诉大家，从前所有的不满，我们都在努力的改善，以后将为大家提供更方便的服务。（请大家坚定地支持我们，但为什么这次Cook上台时没有听到那一串3ks呢）。在果粉心中，新版的系统满足了他们的一些需求，这就够了。至于android有没有什么功能，哪个第三方被跪了。Who cares？现在的这些手势啦，UI设计啦，都是这些生态圈里创造出来的。以后，苹果可以把你们全整合了，你们全喝西北风去吧。果粉用着舒服，这就够了。 那么，如果苹果以这样的心态去面对用户和开发者。开发者会不会离它而去呢？至少暂时不会，因为离了他，有些想法还真的难以实现了。那以后android成长起来呢？好吧，Google这个有史以来最奇葩的公司，谁也不知道Android以后会是什么样子。至少当苹果的服务越来越完善，越来越贴心，当苹果的便捷深入人心的时候，Google想再超越就会越难。 有这样一种说法：一流公司做标准，二流公司做服务。而苹果告诉我们，二逼公司从来没有标准，最多就是招点兵马帮忙砸了别人的标准。然后来完善自己的服务。用户才不会管你标准不标准的，我们要的，是服务。 MyPalace： www.dashfoot.tk   ","date":1371263287,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1371263287,"objectID":"59b59365c7fc5020415e2da480251ff3","permalink":"/post/csdn/wwdc%E8%8B%B9%E6%9E%9C%E7%9A%84%E9%87%8E%E5%BF%83/","publishdate":"2013-06-15T10:28:07+08:00","relpermalink":"/post/csdn/wwdc%E8%8B%B9%E6%9E%9C%E7%9A%84%E9%87%8E%E5%BF%83/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 原题：《 WWDC2013，苹果向世界宣战 》，觉得有些太大了就撤掉了，直到第二天36Kr的报道也使用类","tags":["WWDC"],"title":"WWDC，苹果的野心","type":"post"},{"authors":null,"categories":["typecho"],"content":"很多人顽强地看完了WWDC，开始了惯有的各种吐槽。虽然我开始看的时候状态也差不多吧，尤其是看到第一个“产品”就是Finder Tabs，说实话，我个人不是很喜欢这个东西，以前在linux下就开始使用了但是感觉并不是多么的便捷。况且Finder本身可以打开一个智能窗口，这个功能很强大，很喜欢，让我目前没有看到tabs有什么重大的意义。\nApple要干嘛 最开始同大家的感觉一样，Apple发布了一堆“无聊”但却是还有点用的东西。但是看到后面就有些不明白了，Apple到底要做什么，\n1.首先，这是一个减法的时代，你Apple却开始做加法了，吃饱了撑的么？\n2.就算做加法，怎么竟加一些跟你的“核心竞争力”不沾边的东西？\n很多人的解释是Apple没落了。但是我看着看着却觉得脊梁骨发凉了：Apple这盘棋，怎一个大字了得，全然厚黑之道。（这是昨晚的一条状态。对错先不论）。”厚黑“，看起来和科技界完全不沾边的词第一个跑到了我的脑海里。\n如果去仔细看一下这几次Apple的发布会以及媒体的报道，就会发现有一类共同的句子：“某某君，你还好吗？”、“Apple又革（割字或许更好）了谁的命”、“Apple又整合（注意是整合不是集成）了某个服务了”。看到这里，大家又会说，这有什么稀奇的，在中国这种不是太多了吗。就像多年前3Q大战时大家开的玩笑，吃肉长大的狗，不会啃骨头，等肉没了的时候只能狗咬狗了。这样也可以顶一下Apple没落的理由。但是我们想一下，它咬的是谁呢？\nApple的一些恩恩怨怨 开发者 它没有像某某公司一样去把它的竞争对手Android搞掉，相反，他下手的目标是那些跟IOS一起成长起来的开发者们。\n开发者，到底是个什么角色？当年Apple设计了全新的操作系统，作为新平台，相比于其它成熟的平台，自然是百业待兴。而对Apple这样连不给人看的电路板都要画的好看的公司来说，让他去设计每一个小功能估计早都累死了。（你傻呀，哪个操作系统不是平台呢？）但是Apple的平台它是一个非常封闭的平台，Apple的控制管理很强。当然我们称之为良性生态圈。所以大家都很乐意为OS开发，同样也造就了一批magic。在其它的平台上，也会由于个人开发者的强大而做出很炫的产品，但是在OS系列上可以产生一大批杰出的作品，这与Apple的引导是分不开的。这样以来，Apple可以专注于系统层面，开发者可以把这个系统打扮的非常精美。看！多和谐！\n开放平台 大概就是这个时候，开放平台崛起（当然 facebook 也功不可没吧）。做论坛的搞开放平台，做微博的搞开放平台，做音乐的搞开放平台，做桌面的当然更要做开放平台了，做游戏的，恩，你懂得。 开放平台如日中天，极客一词也广为传播。极客们带着自己的梦想，激情，同乔帮主一道改变世界，一起做kings and the queens（多和谐！）。可当Apple的系统层面搞得差不多时（或者说只是开始加强对应用的控制力度），再回过头看看那些 the magic we made，傻眼了。这不是老子辛辛苦苦做的吗？怎么直接被你Apple拿走了？抗议！抗议？哪凉快哪呆着去。\n这个时候，那些自以为开放平台做的好的才发现，两个开放平台，根本不是一个性质。你总觉得，开放平台，这是大家一起在一块田上耕作，收成嘛，当然自己拿自己的。但其实，这只是Apple生态圈的一半，另一半呢？在另一半，大家都是Apple这个大地主的佃农。乔大地主自己有点事情，于是找你们帮它耕作，等他那边忙活完了，有时间管这边了，好，你们回家洗洗睡吧。\n他行吗？其实，前面说它是良性生态圈的前面还有一句话，这是一个完全受他控制的一块地盘。如果在android下，好家伙，有几个人用的原生android？android开源，让那些禽兽们给糟蹋的四分五裂，google也管不着。但是IOS不一样，人家可以随便编个理由就让你不能上架了（这份痛大家都懂）。更别说之后怎么搞你了。\n他敢吗？事实已经很明了了，一个个失眠的产品。我们说Apple地图，虽然最开始出了点小瑕疵，但是这次的回归，感觉还不错吧。因为才发出来，没有引发什么太大的问题。但是即便有了问题，Apple可以很轻松地搞定，也没有人会在意那些。在地图上，google都被动刀子了，而且没有引发争议，其它的小家伙，Apple会怕你们吗？果粉们会真的舍不得你们吗？拿我自己说吧，如果我用的非Apple产品，当我看到如此“垃圾”随处可捡的功能，我只会吐，这破功能人家早有了。Apple不行了啊。但是如果我用的Apple产品，我会觉得，这个功能不错啊。哇！终于来了！当你用上一款Apple产品时，除非特别痛的地方，你根本不会去跟其它的比来比去的。因为这俩系统有些本质上的不同。\n大一统 （Apple要亲手拆掉自己的生态圈？）当然不是全拆，但是会缩减。Apple，到底是做什么的呢？它的核心竞争力到底在哪里呢？以前你可能会说，卖电脑的。现在，你也许会说，卖手机的。Apple做了哪些产品，你可能会说，设计了一款手机，设计了一款系统。靠IOS成长的起来的第三方公司会说，他打造了一个产业生态圈。把一个很弱智的功能，很容易实现的功能，自己就不做，非留给你们开发者去做。（前面这些话不是我说的，大概是乔布斯死后一些第三方应用公司为表感激而说的）。我的理解，既然他当年可以由于某种原因留给你去做，那么今天他就可以不需要理由把你做的给直接拿走。站在天上丢馅饼？你觉得乔帮主会这么干吗？乔布斯要做的， 就是为人们打造一款完美的产品，一套可以改变人们工作生活学习方式的服务。这套服务，不是一个硬件，不是一个操作系统，不是一堆应用，而是他们的总和。Apple决不会像MS一样，自己只做一个系统，做一套漂亮的SDK，然后你们靠你们去繁荣市场吧。\n那Apple会整合哪些产品呢？游戏，我觉得Apple不会做，至少暂时不会去涉猎太多，不过你也不能排除Apple突然有些好点子就整合几个游戏的可能。但是办公方面，应该还是挺明显的吧，我们在windows下会有三方公司定制“装机必备软件”，这些基本的工作上要用的东西，Apple都会去整合。今天在mail上加一个vip，明天或许就出来一个sparrow了也不是没可能。但不得不说，这点对用户是真的很方便的。（facebook它可能一时不会自己去搞，但一定会在自己通讯工具里慢慢渗透。youtube呢？我觉得它会考虑把视频资料整合一下发出来的，Apple TV 也需要资源的。这个有点像做地图，因为现在都有专门的数据公司了，你只需要拿过来加上自己的特色就是了。这些东西虽然很小但是加上却很棒）。这样下来，媒体，它可能不会去做，社交，说不准，这样的话，貌似它什么都敢做了。。。\n其它的一些想法 创新不足？ 回到大家很关心的问题，这些变化太无聊了，没有划时代的感觉，其实很简单，如果天天都是划时代，那还叫划时代吗？如果我们再回过头把Apple历次的发布会放到一起，除了在iPhone发布会上给你颠覆的感觉，其它的，也都是一些缝缝补补。当然大多数情况也都会有一款杀手级的应用问世。或许这一年，地图让Apple煞费了苦心。也可能大家都去设计那个不明觉厉的MAC Pro了。\n这样说来，Apple召开发布会的初衷，是告诉大家，从前所有的不满，我们都在努力的改善，以后将为大家提供更方便的服务。（请大家坚定地支持我们，但为什么这次Cook上台时没有听到那一串3ks呢）。在果粉心中，新版的系统满足了他们的一些需求，这就够了。至于android有没有什么功能，哪个第三方被跪了。Who cares？现在的这些手势啦，UI设计啦，都是这些生态圈里创造出来的。以后，Apple可以把你们全整合了，你们全喝西北风去吧。果粉用着舒服，这就够了。\n品牌形象 那么，如果Apple以这样的心态去面对用户和开发者。开发者会不会离它而去呢？至少暂时不会，因为离了他，有些想法还真的难以实现了。那以后android成长起来呢？好吧，Google这个有史以来最奇葩的公司，谁也不知道Android以后会是什么样子。至少当Apple的服务越来越完善，越来越贴心，当Apple的便捷深入人心的时候，Google想再超越就会越难。\n最后 有这样一种说法：一流公司做标准，二流公司做服务。而Apple告诉我们，二逼公司从来没有标准，最多就是招点兵马帮忙砸了别人的标准。然后来完善自己的服务。用户才不会管你标准不标准的，我们要的，是服务。\n","date":1370861100,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1370861100,"objectID":"8b105f31978957b074e1fb0a730fa23f","permalink":"/post/typecho/77-wwdc-apples-ambition/","publishdate":"2013-06-10T18:45:00+08:00","relpermalink":"/post/typecho/77-wwdc-apples-ambition/","section":"post","summary":"很多人顽强地看完了WWDC，开始了惯有的各种吐槽。虽然我开始看的时候状态也差不多吧，尤其是看到第一个“产品”就是Finder Tabs，说实话，我个人不是很喜欢这个东西，以前在linux下就开始使用了但是感觉并不是多么的便捷。况且Finder本身可以打开一个智能窗口，这个功能很强大，很喜欢，让我目前没有看到tabs有什么重大的意义。\n","tags":["互联网"],"title":"WWDC, Apple's Ambition","type":"post"},{"authors":null,"categories":["typecho"],"content":"高考前后，RP掉到渣，电脑也各种犯毛病。无意中看到了一份比较不错的黑苹果安装视频教程，反正机子也各种毛病，破罐子摔摔看，看能不能摔出什么宝贝出来。\n那时候还没有关于ProBook 4421s 的教程，很多人说这机子不能装！后来用工具测试果然显示不行.\n那时候还不知道懒人版是什么东西只觉得自己好牛逼的，下载的都是原版自己提取自己配置到最后得知内核不兼容。\n那时候还有些怀疑软件真的把硬件瘫痪掉，于是后来。。你懂得。\n最开始就跟教程一步一步来，提取镜像，把两个小盘参数改成AF，写入磁盘，写跪了无数次，后来发现参数不用改，不用格式化，只要有个盘符能看到就行。光把镜像写入磁盘可能就折腾了有三天，直到半年后这个问题有时候还会犯。\n镜像写好之后，下来又是一个非常头疼的问题，引导。最开始用Chameleon，替换wowpc。但是跪了，一直说是找不到某某mbr，据说是变色龙版本的问题，换，其实坛子的变色龙就两个版本，换来换去最后不知道换到哪个时给进去了。这个时候距离接触黑苹果已经一周了。连安装界面都没有进入。\n不要想多了只是进去变色龙了，选择install后看到一个大大的苹果logo，内心无比激动。 ———————————————————————————— 写到这里时，小引一口水，洒了一键盘，拔电源，抠电池，于是乎上面写的东西全丢了。。 ————————————————————————————- 正当我看到那个logo激动时，重启了。如上所说,在换了各种版本后，最后还是悲催地收场了。 一个暑假的十天时间，就这样充实地过去了。\n刚进入大学，都会有那么一段时间去忙活各种蛋疼的事情。一直到了11月份，又开始折腾了，这次折腾的力度加大了，其实也没什么力度，就是一天重启的次数多了，windows搞崩的频率快了。好在当时已经混进实验室，win和linux故障都可以找军哥搞定。没有什么“后顾”之忧。又折腾了一星期，那一星期大部分的时间就是拿一本书坐在电脑前面，电脑重启再重启，如果突然崩了重启不了了就放下书开始修复。。\n直到看到了一份虚拟机安装黑苹果的教程，看起来很简单，有得一试。在一个精简版的gnome下开virtualbox各种捣腾，把第一次跑起来了黑苹果，因为这个精简版的gnome进入桌面后，内存一共只被占了300M，因此在使用上并没有太多的影响。后来感觉在我的虚拟机下，比久经某人糟蹋的几乎同等配置的macbook pro跑的还流畅。虚拟机下一切还好，声音网络都不用操心，但是，显卡不行。只有1024*768的一个分辨率，装tools也搞不起。反正就在虚拟机里瞎玩玩吧。\n这个时候距离接触黑苹果已经过去快半年了，除了在虚拟机里自娱自乐、好丢人。不说了。。说点好的，差不多这个时候，开始学习在linux下生存，除非迫不得已不去开windows。时间又这样过去了几个月。。\n那天逛远景时，突然发现就在去年我在一次一次重启时，有几个跟我同机子的大牛也再研究了。靠着几个老师写的文章，在我放弃的时候搞出来了“完美运行”！更加令我佩服的是，我看这哥们搞黑苹果的发贴记录，足足搞了一年半！付出才有回报啊。相比之下自己花的时间累计不足一个月，能搞出来才有问题呢.\n这位大牛搞出来之后把他用的资源都发出来了，方法略有差别，用的懒人版的Lion，我发现根本不需要MD直接用DiskGenius把磁盘参数改成07就可以在win下访问最后再改回AF即可。于是很顺利地第一次脱离虚拟机进入了黑苹果，那会激动不吃饭，也睡不着。但实际上，在黑苹果中，装系统只是第一步，驱动才是大问题。而且这个时候没有声音、没有网、没有显卡驱动、甚至连笔记本键盘都不能用。\n虽然这次很顺利地装好了系统（大概花了一整天吧）。但是驱动又卡了我一个星期，装驱动提示安装完毕但总是没有任何效果。后来发现Kext Wizard必须在mac下解压，终于能装了，结果，装一个驱动，死机，运气好的话不会死掉但一重启就启动不了了。又折腾了一星期，没有结果。最悲剧的事情是，硬盘跪了，丢了好多资料。无奈之下买了一个1T的移动硬盘，花了我500大洋，全是折腾惹的祸。可问题还在，什么都搞不好，不仅windows一直跪，还把linux引导丢了又得修复grub。。而就在这个时候帮小玉的白苹果重装了下系统，一路连一个磕绊都没有，一下午就搞定了。再看看自己折腾了半年多的黑苹果，唉。。心碎了。\n这个事情又压了几个月，直到上周，不知道哪根筋抽了又要装mac，还没下手，想到一个很烦的问题，一装mac，引导就丢，修复呢，要修复win和linux，也就是说需要一个PE，还得一个live USB。一个U盘不够啊！而且，因为在这个过程中，一天可能要装几次，就要修复好几次，而每次修复都要重修烧U盘！有些怕了。\n看着别人都用上mac于心不忍啊。说真的，作为一个用户来讲，MAC+IOS的体验，是win+Android根本没法比的。从用户的角度讲，以前那些嫌苹果这个那个的完全站不住脚。再敬乔帮主。可最近事务繁忙怎么办，咬咬牙，这周末两天，什么都不做，全心研究黑苹果。严格来说是从今天早上开始搞驱动的。开始一遍一遍的爬楼（看不懂哇）。下了一堆子完全没碰过的工具，不同版本的。下午把声卡安好了，永远的fly away、跑起来。于是又没吃饭。\n从下午到晚上，开始自己修改EDID，自己提取ROM，到晚上八点，安装显卡前，拍了一张照片，发到人人，不知道重启之后还会不会看到桌面，这些刚修改的东西以后怎么处理。\n幸运地，还没等这条照片完全发出去，电脑进入了登录界面，账户头像，那么圆，那么精致！难道装好了？进去后，看到了透明的任务栏！哈哈这么简单啊！一天而已嘛！老子搞定了！大餐走起！~\n吃饭前让它自己下载java6，苹果自己改的java6，好坑爹。回来的时候，your computer must be restart…..凡是折腾过黑苹果的都明白，再也熟悉不过的画面。装系统没跪，装驱动没跪，结果死在了java上！还是java6！泪奔了。。\n重启后，才发现，虚惊一场，只是装java想让你重启一下而已。。\n","date":1370088900,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1370088900,"objectID":"0d2587bda868f23ccdb3ece483cbade9","permalink":"/post/typecho/54-hp-4421s-%E5%95%83%E5%88%B0%E9%BB%91%E8%8B%B9%E6%9E%9C/","publishdate":"2013-06-01T20:15:00+08:00","relpermalink":"/post/typecho/54-hp-4421s-%E5%95%83%E5%88%B0%E9%BB%91%E8%8B%B9%E6%9E%9C/","section":"post","summary":"高考前后，RP掉到渣，电脑也各种犯毛病。无意中看到了一份比较不错的黑苹果安装视频教程，反正机子也各种毛病，破罐子摔摔看，看能不能摔出什么宝贝出来。\n那时候还没有关于ProBook 4421s 的教程，很多人说这机子不能装！后来用工具测试果然显示不行.\n那时候还不知道懒人版是什么东西只觉得自己好牛逼的，下载的都是原版自己提取自己配置到最后得知内核不兼容。\n","tags":["IT技术堆","Mac"],"title":"HP 4421s 啃到黑苹果","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目       题目描述 Description  给你N个数，有两种操作：  1：给区间[a,b]的所有数增加X  2：询问区间[a,b]的数的和。   输入描述 Input Description  第一行一个正整数n，接下来n行n个整数，再接下来一个正整数Q，每行表示操作的个数，如果第一个数是1，后接3个正整数，表示在区间[a,b]内每个数增加X,如果是2，表示操作2询问区间[a,b]的和是多少。   输出描述 Output Description  对于每个询问输出一行一个答案   样例输入 Sample Input  3  1  2  3  2  1 2 3 2  2 2 3   样例输出 Sample Output  9   数据范围及提示 Data Size \u0026amp; Hint  1\u0026lt;=n\u0026lt;=200000  1\u0026lt;=q\u0026lt;=200000       地址： http://wikioi.com/problem/1082/   思路（见代码注释）   代码   # include \u0026lt;cstdio\u0026gt; # include \u0026lt;iostream\u0026gt; # define N 5000000 using namespace std; struct node{ int l,r; long long sum,inc;\t// sum记录以该节点为根的树的和，inc表示该节点所统治的每个叶子节点都增加的值 }; node st[N]; int a[N]; void build(int v,int l,int r){\t// 本段代码 同 数列操作1 st[v].l=l; st[v].r=r; if (st[v].l==st[v].r){ st[v].sum=a[l]; return ; } int mid = (l+r)/2; build(v2,l,mid); build(v2+1,mid+1,r); st[v].sum=st[v2].sum + st[v2+1].sum; }\nvoid insert(int v,int l,int r,long long c){ // 插入 st[v].sum+=c*(r-l+1);\tif (l==st[v].l \u0026amp;\u0026amp; r==st[v].r){\t// 如果正好需要这段，更新inc值，跳出 st[v].inc+=c; return ; } int mid = (st[v].l+st[v].r)/2; // 向下更新 if (r\u0026lt;=mid) insert(v*2,l,r,c); else if (l\u0026gt;mid) insert(v*2+1,l,r,c); else { insert(v*2,l,mid,c); insert(v*2+1,mid+1,r,c); } }\nlong long getsum(int v,int l,int r){\t// 求和 if (l==st[v].l \u0026amp;\u0026amp; r==st[v].r) return st[v].sum;\t// 找到，返回 int mid = (st[v].l + st[v].r)/2; if (r\u0026lt;=mid) return getsum(v2,l,r) + st[v].inc(r-l+1);\t// 如果还需要向下寻找，回溯的时候务必加上 该节点的inc值 else if (l\u0026gt;mid) return getsum(v2+1,l,r) + st[v].inc(r-l+1); else return getsum(v2,l,mid) + getsum(v2+1,mid+1,r) + st[v].inc*(r-l+1); }\nint main(){ freopen(\u0026ldquo;1082.in\u0026rdquo;,\u0026ldquo;r\u0026rdquo;,stdin); int n; scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;n); for (int i(1);i\u0026lt;=n;i++) { scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;a[i]); } build(1,1,n); int m,t,l,r,c; for (scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;m);m;m\u0026ndash;){ scanf(\u0026quot;%d%d%d\u0026rdquo;,\u0026amp;t,\u0026amp;l,\u0026amp;r); if (t \u0026amp; 1){ scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;c); insert(1,l,r,c); }else { //printf(\u0026quot;%d\\n\u0026rdquo;,getsum(1,l,r)); cout \u0026lt;\u0026lt; getsum(1,l,r) \u0026lt;\u0026lt; endl; } } return 0; }   \n  ","date":1369798148,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369798148,"objectID":"8bd39be10320dc79db2fe2fce1ef6187","permalink":"/post/csdn/%E5%8C%BA%E9%97%B4%E6%8F%92%E5%85%A5%E6%B1%82%E5%92%8C-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8%E4%BA%8C/","publishdate":"2013-05-29T11:29:08+08:00","relpermalink":"/post/csdn/%E5%8C%BA%E9%97%B4%E6%8F%92%E5%85%A5%E6%B1%82%E5%92%8C-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8%E4%BA%8C/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目 题目描述 Description 给你N个数，有两种操作： 1：给区间[a,b]的所有数增加X 2：询问区间[a,b]的数的","tags":[],"title":"区间插入求和  —  线段树入门（二）","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目       题目描述 Description  一行N个方格，开始每个格子里都有一个整数。现在动态地提出一些问题和修改：提问的形式是求某一个特定的子区间[a,b]中所有元素的和；修改的规则是指定某一个格子x，加上或者减去一个特定的值A。现在要求你能对每个提问作出正确的回答。1≤N\u0026lt;100000，,提问和修改的总数m\u0026lt;10000条。   输入描述 Input Description  输入文件第一行为一个整数N，接下来是n行n个整数，表示格子中原来的整数。接下一个正整数m，再接下来有m行，表示m个询问，第一个整数表示询问代号，询问代号1表示增加，后面的两个数x和A表示给位置X上的数值增加A，询问代号2表示区间求和，后面两个整数表示a和b，表示要求[a,b]之间的区间和。   输出描述 Output Description  共m行，每个整数   样例输入 Sample Input  6  4  5  6  2  1  3  4  1 3 5  2 1 4  1 1 9  2 2 6   样例输出 Sample Output  22  22   数据范围及提示 Data Size \u0026amp; Hint  1≤N\u0026lt;100000， m\u0026lt;10000 。       地址： http://wikioi.com/problem/1080/   思路（见代码注释）   代码   # include \u0026lt;cstdio\u0026gt; # define N 500000\t// 利用二叉树的父子节点关系来存储，因此必须保证数组开的足够大 struct node{ int l,r,v;\t// left、right、value ；左右孩子由二叉树性质计算。 }; node st[N]; int a[N]; void build(int v,int l,int r){ st[v].l = l; st[v].r = r; if (l == r) {\t// 是叶子，直接赋值，跳出 st[v].v=a[l]; return ; } int mid = (l+r)/2;\t// 不是叶子，往下扩展 build(2v,l,mid); build(2v+1,mid+1,r); st[v].v=st[v2].v+st[v2+1].v;\t// 扩展出孩子后才能计算value域 }\nvoid insert(int v,int w,int p){\t// 在以v为根的树中，寻找节点w，并把节点w的值加上p 。 格外注意 某些编程语言中insert不能作为标识符 if (w\u0026gt;=st[v].l \u0026amp;\u0026amp; w\u0026lt;=st[v].r){ st[v].v += p;\t// 父子之间为统治关系，凡是经过的节点都要更新value } if (st[v].l==st[v].r) return;\t// 找到终点，跳出 int mid = (st[v].l+st[v].r)/2; if (w\u0026lt;=mid) {\t// 判断左右孩子 insert(v2,w,p);\t}else { insert(v2+1,w,p); } }\nint getsum(int v,int l,int r){\t// 返回以v为根节点的树中，区间 [l,r] 的value域 if (st[v].l==l \u0026amp;\u0026amp; st[v].r==r){ return st[v].v;\t// 找到，返回 } int mid = (st[v].l+st[v].r)/2; if (r\u0026lt;=mid) { return getsum(v2,l,r);\t// 区间 [l,r] 在v的左枝上 }else if (l\u0026gt;mid) { return getsum(v2+1,l,r);\t// 右枝 }else {\t// 兵分两路 return getsum(v2,l,mid) + getsum(v2+1,mid+1,r); } }\nint main(void){ freopen(\u0026ldquo;1080.in\u0026rdquo;,\u0026ldquo;r\u0026rdquo;,stdin); int n; scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;n); for (int i(1);i\u0026lt;=n;i++) { scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;a[i]); } build(1,1,n); int m,t,a,b; for (scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;m);m;m\u0026ndash;){ scanf(\u0026quot;%d%d%d\u0026rdquo;,\u0026amp;t,\u0026amp;a,\u0026amp;b); if (t \u0026amp; 1) { insert(1,a,b); }else { printf(\u0026quot;%d\\n\u0026rdquo;,getsum(1,a,b)); } } return 0; }   \n     ","date":1369752130,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369752130,"objectID":"c29e553ef285c4b72944744fbbee83d1","permalink":"/post/csdn/%E6%95%B0%E5%88%97%E6%93%8D%E4%BD%9C-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/","publishdate":"2013-05-28T22:42:10+08:00","relpermalink":"/post/csdn/%E6%95%B0%E5%88%97%E6%93%8D%E4%BD%9C-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目 题目描述 Description 一行N个方格，开始每个格子里都有一个整数。现在动态地提出一些问题和修改：提问的形式是求","tags":[],"title":"数列操作  —  线段树入门","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  序言   首先，你应该可以看到这个页面跟一般的CSDN页面不相同。这也是我们本文的目的。  必须承认，很多IT人士都有自己的个性，也必须承认CSDN的简介模版深受广大同学的喜爱（之前我在wordpress放代码，后来转移CSDN了）。  方法   其实说到方法，很简单的前端而已。问题是在哪里写代码？  夜深了，精简说明：  博客 - 博客栏目 下，有一个添加自定义栏目，这个栏目可以接下来html代码。接下来的事情你们就懂了吧~  补充   关于广告   为什么没有把广告隐藏掉，两方面原因，   一是这个广告并没有那么讨厌，而且都是IT资讯，是我们需要的。    二，总感觉有些钻洞子。。不地道    大家还是尊重一下我们亲爱的CSDN吧。  我的素材   注意不能使用外链图片哦~          ","date":1369416649,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369416649,"objectID":"93e902552d2bb784ae42a253a49dc4c6","permalink":"/post/csdn/csdn%E6%A8%A1%E7%89%88%E4%BF%AE%E6%94%B9/","publishdate":"2013-05-25T01:30:49+08:00","relpermalink":"/post/csdn/csdn%E6%A8%A1%E7%89%88%E4%BF%AE%E6%94%B9/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 序言 首先，你应该可以看到这个页面跟一般的CSDN页面不相同。这也是我们本文的目的。 必须承认，很多IT","tags":["CSDN"],"title":"CSDN模版修改","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n     arduino套装，给了个5611AH的数码管。在网上找不到现成的引脚图，无奈只好自己画了。初学arduino第一天，不懂得标准，还望见谅。     图示    代码：   int a[10][10]={{0,0,0,1,1,1,1,1,1,0}, {0,0,0,0,1,1,0,0,0,0}, {0,0,0,1,1,0,1,1,0,1}, {0,0,0,1,1,1,1,0,0,1}, {0,0,0,0,1,1,0,0,1,1}, {0,0,0,1,0,1,1,0,1,1}, {0,0,0,1,0,1,1,1,1,1}, {0,0,0,1,1,1,0,0,0,0}, {0,0,0,1,1,1,1,1,1,1}, {0,0,0,1,1,1,1,0,1,1},}; void setup(){ for (int i=3;i\u0026lt;=9;i++) { pinMode(i,OUTPUT); } } void printf(int v){ for (int i=3;i\u0026lt;=9;i++){ digitalWrite(i,a[v][i]); } } void loop(){ for (int i=0;i\u0026lt;=9;i++){ printf(i); delay(400); } }   我的乱七八糟的接线        ","date":1369389151,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369389151,"objectID":"787e9f76e06f12816ee13810f037b5d1","permalink":"/post/csdn/5611ah-%E6%95%B0%E7%A0%81%E7%AE%A1-%E5%BC%95%E8%84%9A%E5%9B%BE/","publishdate":"2013-05-24T17:52:31+08:00","relpermalink":"/post/csdn/5611ah-%E6%95%B0%E7%A0%81%E7%AE%A1-%E5%BC%95%E8%84%9A%E5%9B%BE/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 arduino套装，给了个5611AH的数码管。在网上找不到现成的引脚图，无奈只好自己画了。初学ar","tags":["5611AH"],"title":"5611AH 数码管 引脚图","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目       Prime Cryptarithm     The following cryptarithm is a multiplication problem that can be solved by substituting digits from a specified set of N digits into the positions marked with *. If the set of prime digits {2,3,5,7} is selected, the cryptarithm is called a PRIME CRYPTARITHM.  * * * x * * ------- * * * \u0026lt;-- partial product 1 * * * \u0026lt;-- partial product 2 ------- * * * *  Digits can appear only in places marked by `*'. Of course, leading zeroes are not allowed.  Note that the 'partial products' are as taught in USA schools. The first partial product is the product of the final digit of the second number and the top number. The second partial product is the product of the first digit of the second number and the top number. Write a program that will find all solutions to the cryptarithm above for any subset of digits from the set {1,2,3,4,5,6,7,8,9}. PROGRAM NAME: crypt1  INPUT FORMAT     Line 1:   N, the number of digits that will be used     Line 2:   N space separated digits with which to solve the cryptarithm     SAMPLE INPUT (file crypt1.in)  5 2 3 4 6 8  OUTPUT FORMAT  A single line with the total number of unique solutions. Here is the single solution for the sample input:  2 2 2 x 2 2 ------ 4 4 4 4 4 4 --------- 4 8 8 4  SAMPLE OUTPUT (file crypt1.out)  1         思路   简单的枚举，关键在于枚举侧略，我是把第一行看成一个数，第二行看成一个数，枚举这两个数字900*90的复杂度。后面分别判断就行。   代码   /* ID:zhrln1 PROG:crypt1 LANG:C++ */ #include \u0026lt;cstdio\u0026gt; int n,b[11],k,ans; int hash(int v){ while (v){ if (!b[v%10]) return 0; v/=10; } return 1; } int main(){ freopen(\"crypt1.in\",\"r\",stdin); freopen(\"crypt1.out\",\"w\",stdout); scanf(\"%d\",\u0026amp;n); for (int i(1);i\u0026lt;=n;i++){ scanf(\"%d\",\u0026amp;k); b[k]=1; } for (int i(111);i\u0026lt;1000;i++){ if (hash(i)){ for (int j(11);j\u0026lt;100;j++){  if (i*j\u0026amp;lt;10000 \u0026amp;amp;\u0026amp;amp; i*(j/10)\u0026amp;lt;1000 \u0026amp;amp;\u0026amp;amp; i*(j%10)\u0026amp;lt;1000 \u0026amp;amp;\u0026amp;amp; hash(j) \u0026amp;amp;\u0026amp;amp; hash(i*(j%10)) \u0026amp;amp;\u0026amp;amp; hash(i*(j/10)) \u0026amp;amp;\u0026amp;amp; hash(i*j)) { ans++; // printf(\u0026quot;%d * %d = %d0 + %d = %d \\n\u0026quot;,i,j,i*(j/10),i*(j%10),i*j); } } } } printf(\u0026quot;%d\\n\u0026quot;,ans); return 0;  }  \n    ","date":1369192026,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369192026,"objectID":"a3bfa5e8bcaaf4d1f7aaca175a073bc8","permalink":"/post/csdn/usaco-section-1.3.6-prime-cryptarithm/","publishdate":"2013-05-22T11:07:06+08:00","relpermalink":"/post/csdn/usaco-section-1.3.6-prime-cryptarithm/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目 Prime Cryptarithm The following cryptarithm is a multiplication problem that can be solved by substituting digits from a specified set of N digits into the positions marked with *. If the set of prime digits {2,3,5,7} is selected, the cryptarithm is called a PRIME CRYPTARITHM. * * *","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.3.6 Prime Cryptarithm","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n   题目          Calf Flac     It is said that if you give an infinite number of cows an infinite number of heavy-duty laptops (with very large keys), that they will ultimately produce all the world's great palindromes. Your job will be to detect these bovine beauties. Ignore punctuation, whitespace, numbers, and case when testing for palindromes, but keep these extra characters around so that you can print them out as the answer; just consider the letters `A-Z' and `a-z'. Find the largest palindrome in a string no more than 20,000 characters long. The largest palindrome is guaranteed to be at most 2,000 characters long before whitespace and punctuation are removed. PROGRAM NAME: calfflac  INPUT FORMAT  A file with no more than 20,000 characters. The file has one or more lines which, when taken together, represent one long string. No line is longer than 80 characters (not counting the newline at the end).  SAMPLE INPUT (file calfflac.in)  Confucius say: Madam, I'm Adam.  OUTPUT FORMAT  The first line of the output should be the length of the longest palindrome found. The next line or lines should be the actual text of the palindrome (without any surrounding white space or punctuation but with all other characters) printed on a line (or more than one line if newlines are included in the palindromic text). If there are multiple palindromes of longest length, output the one that appears first. SAMPLE OUTPUT (file calfflac.out)  11 Madam, I'm Adam       思路    找回文串，首先想到便是枚举中间，向两头扩展。  这个题目麻烦的地方在于有很多干扰的字符，这时处理的方法有两种：  第一在最开始把那些垃圾字符放一边，最后输出的时候补上。  第二最开始不用处理，而是扩展的时候进行判断是不是合法字符。  听上去第二种简单一点，但是真正写起来第一种的优势就很明显了，因为第二种在枚举的时候要判断，扩展的时候要判断，如果是复制粘贴的代码的话一处错了还得改别处。  总之很蛋疼。我两种方法都写了，但是第一种代码短了差不多20行。下面贴的也是第一种的。   代码    /* ID: zhrln1 LANG: C++ TASK: calfflac */ #include \u0026lt;cstdio\u0026gt; char s[22222],ss[22222],ch; int l,ls,b[22222]; int trun(char c){ if (c\u0026gt;='a' \u0026amp;\u0026amp; c\u0026lt;='z') return c; if (c\u0026gt;='A' \u0026amp;\u0026amp; c\u0026lt;='Z') return c+'a'-'A'; return 0; } int main(){ freopen(\"calfflac.in\",\"r\",stdin); freopen(\"calfflac.out\",\"w\",stdout); ss[0]=s[0]='#'; while (scanf(\"%c\",\u0026amp;ch)!=EOF){ ss[++ls]=ch; if (trun(ch)) { s[++l]=trun(ch); b[l]=ls; } } int ans=1,ansi=1,j1,j2; for (int i(2);i\u0026lt;=l;i++){ for (j1=i,j2=i;j1\u0026gt;1 \u0026amp;\u0026amp; j2\u0026lt;l \u0026amp;\u0026amp; s[j1-1]==s[j2+1];j1--,j2++); if (j2-j1+1\u0026gt;ans) { ans=j2-j1+1; ansi=j1; } if (s[i]!=s[i+1]) continue; for (j1=i,j2=i+1;j1\u0026gt;1 \u0026amp;\u0026amp; j2\u0026lt;l \u0026amp;\u0026amp; s[j1-1]==s[j2+1];j1--,j2++); if (j2-j1+1\u0026gt;ans){ ans=j2-j1+1; ansi=j1; } } printf(\"%d\\n\",ans); int p=0; for (int i(b[ansi]);p\u0026lt;ans;i++){ printf(\"%c\",ss[i]); if (trun(ss[i])) p++; } printf(\"\\n\"); return 0; }      ","date":1369191787,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369191787,"objectID":"ea4aada20dbd2b454bee60e1afd86cde","permalink":"/post/csdn/usaco-section-1.3.5-calf-flac/","publishdate":"2013-05-22T11:03:07+08:00","relpermalink":"/post/csdn/usaco-section-1.3.5-calf-flac/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目 Calf Flac It is said that if you give an infinite number of cows an infinite number of heavy-duty laptops (with very large keys), that they will ultimately produce all the world's great palindromes. Your job will be to detect these bovine beauties. Ignore punctuation, whitespace, numbers, and","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.3.5 Calf Flac","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目       Barn Repair   It was a dark and stormy night that ripped the roof and gates off the stalls that hold Farmer John's cows. Happily, many of the cows were on vacation, so the barn was not completely full. The cows spend the night in stalls that are arranged adjacent to each other in a long line. Some stalls have cows in them; some do not. All stalls are the same width. Farmer John must quickly erect new boards in front of the stalls, since the doors were lost. His new lumber supplier will supply him boards of any length he wishes, but the supplier can only deliver a small number of total boards. Farmer John wishes to minimize the total length of the boards he must purchase. Given M (1 \u0026lt;= M \u0026lt;= 50), the maximum number of boards that can be purchased; S (1 \u0026lt;= S \u0026lt;= 200), the total number of stalls; C (1 \u0026lt;= C \u0026lt;= S) the number of cows in the stalls, and the C occupied stall numbers (1 \u0026lt;= stall_number \u0026lt;= S), calculate the minimum number of stalls that must be blocked in order to block all the stalls that have cows in them. Print your answer as the total number of stalls blocked. PROGRAM NAME: barn1  INPUT FORMAT     Line 1:   M, S, and C (space separated)     Lines 2-C+1:   Each line contains one integer, the number of an occupied stall.     SAMPLE INPUT (file barn1.in)  4 50 18 3 4 6 8 14 15 16 17 21 25 26 27 30 31 40 41 42 43  OUTPUT FORMAT  A single line with one integer that represents the total number of stalls blocked.  SAMPLE OUTPUT (file barn1.out)  25  [One minimum arrangement is one board covering stalls 3-8, one covering 14-21, one covering 25-31, and one covering 40-43.]          思路   非常经典的贪心算法，很多比赛的都有这道题目的变种题（把牛变成猪把人名换成自己的名字）      先来看一个很流行的方法：      相连在一起的牛棚可以看成一个区域，假设一共出现了n个区域，你可以把题目想象成把一块大板子拆成n块，即从中挖n-1的洞，要使挖出的最多，这样就很简单了，自然每次挖最大的洞。   举例说明：   -----------   1 7 9   -----------   有这样一块大板子，如果你只能挖出一块，挖最大的就是：   - -----   1 7 9   - -----   这样剩下的就是最小费用了。       这个方法设计的非常巧妙。问题是，如何证明？如何能一下子就知道反过来考虑？         不妨把算法换一种描述来看，题目M 块板子是一个限制条件，所以我们应该从这里去思考，假如只给你一块板子，那你一定是把所有的全盖上，期中必然会有很多浪费的地方，这些浪费有没有可能避免呢？这个时候给你两块板子，你就会想到两块板子避开空隙，如果有很多空隙你应该避哪个呢？当然是最大的，可以证明，避开另外任意一个缺口都不如避开最大的缺口省材料。于是第三块板子第四块板子也就明白了。      代码   /* ID:zhrln1 PROG:barn1 LANG:C++ */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n,m,s,c,a[222],b[222],l,r,sum; int cmp(int a,int b){ return a\u0026gt;b; } int main(){ freopen(\"barn1.in\",\"r\",stdin); freopen(\"barn1.out\",\"w\",stdout); scanf(\"%d%d%d\",\u0026amp;m,\u0026amp;s,\u0026amp;c); for (int i(1);i\u0026lt;=c;i++) scanf(\"%d\",\u0026amp;a[i]); sort(a+1,a+c+1); int l=a[1],r; for (int i(2);i\u0026lt;=c;i++){ r=a[i]; if (r-l\u0026gt;1){ b[++n]=r-l-1; } l=r; } sort(b+1,b+n+1,cmp); if (--m \u0026lt; n ) n=m; s=a[c]-a[1]+1; for (int i(1);i\u0026lt;=n;i++){ s-=b[i]; } printf(\"%d\\n\",s); return 0; }      ","date":1369191249,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369191249,"objectID":"d3e41bb6094005b59e9861e40e9bc79a","permalink":"/post/csdn/usaco-section-1.3.3-barn-repair/","publishdate":"2013-05-22T10:54:09+08:00","relpermalink":"/post/csdn/usaco-section-1.3.3-barn-repair/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目 Barn Repair It was a dark and stormy night that ripped the roof and gates off the stalls that hold Farmer John's cows. Happily, many of the cows were on vacation, so the barn was not completely full. The cows spend the night in stalls that are arranged","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.3.3 Barn Repair","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目       Mixing Milk   Since milk packaging is such a low margin business, it is important to keep the price of the raw product (milk) as low as possible. Help Merry Milk Makers get the milk they need in the cheapest possible manner. The Merry Milk Makers company has several farmers from which they may buy milk, and each one has a (potentially) different price at which they sell to the milk packing plant. Moreover, as a cow can only produce so much milk a day, the farmers only have so much milk to sell per day. Each day, Merry Milk Makers can purchase an integral amount of milk from each farmer, less than or equal to the farmer's limit. Given the Merry Milk Makers' daily requirement of milk, along with the cost per gallon and amount of available milk for each farmer, calculate the minimum amount of money that it takes to fulfill the Merry Milk Makers' requirements. Note: The total milk produced per day by the farmers will be sufficient to meet the demands of the Merry Milk Makers. PROGRAM NAME: milk  INPUT FORMAT     Line 1:   Two integers, N and M.  The first value, N, (0 \u0026lt;= N \u0026lt;= 2,000,000) is the amount of milk that Merry Milk Makers wants per day. The second, M, (0 \u0026lt;= M \u0026lt;= 5,000) is the number of farmers that they may buy from.     Lines 2 through M+1:   The next M lines each contain two integers, P  i  and A  i  .  P  i  (0 \u0026lt;= P  i  \u0026lt;= 1,000) is price in cents that farmer i charges.  A  i  (0 \u0026lt;= Ai \u0026lt;= 2,000,000) is the amount of milk that farmer i can sell to Merry Milk Makers per day.     SAMPLE INPUT (file milk.in)  100 5 5 20 9 40 3 10 8 80 6 30  OUTPUT FORMAT  A single line with a single integer that is the minimum price that Merry Milk Makers can get their milk at for one day. SAMPLE OUTPUT (file milk.out)  630         思路   每次当然买最便宜的啊，很简单的贪心。   代码   /* ID:zhrln1 PROG:milk LANG:C++ */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 1000000 using namespace std;\nstruct milk { int w,p; };\nmilk a[maxn+1];\nint m,n;\nbool cmp(milk a ,milk b){ return a.p \u0026lt; b.p; }\nint main(){ freopen(\u0026ldquo;milk.in\u0026rdquo;,\u0026ldquo;r\u0026rdquo;,stdin); freopen(\u0026ldquo;milk.out\u0026rdquo;,\u0026ldquo;w\u0026rdquo;,stdout); scanf(\u0026quot;%d%d\u0026rdquo;,\u0026amp;m,\u0026amp;n); for (int i=1;i\u0026lt;=n;i++){ scanf(\u0026quot;%d%d\u0026rdquo;,\u0026amp;a[i].p,\u0026amp;(a[i].w)); } sort(a+1,a+n+1,cmp); int s=m,sp=0,k; for (int i=1;s;i++){ if ((k=a[i].w)\u0026gt;s) k=s; s-=k; sp+=k*a[i].p; } printf(\u0026quot;%d\\n\u0026rdquo;,sp); return 0; }   \n ","date":1369190674,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369190674,"objectID":"723db91ed01c4d3b4dca7f098993843a","permalink":"/post/csdn/usaco-section-1.3.2-mixing-milk/","publishdate":"2013-05-22T10:44:34+08:00","relpermalink":"/post/csdn/usaco-section-1.3.2-mixing-milk/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目 Mixing Milk Since milk packaging is such a low margin business, it is important to keep the price of the raw product (milk) as low as possible. Help Merry Milk Makers get the milk they need in the cheapest possible manner. The Merry Milk Makers company has several","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.3.2 Mixing Milk","type":"post"},{"authors":null,"categories":["typecho"],"content":"这个电视最开始看，总觉得似曾相识。一拍大腿，发现全是新三国的演员。。。\n简单地说就是康熙、张飞、鲁肃、吕布、许攸、荀彧、刘备及其儿子各种叛变后重新划分天下。对于剧情不想评论太多，感觉自己想看的很多东西没有演出来。\n说一说人物 刘邦 刘邦：最开始还有刘季的痞气，到后面，已经看不出跟康熙有什么区别了。跟历代草根帝王一样，很大程度上这辈子就做一件事：用人。在前期（注意只是前期）称霸还是称王都会犹豫一下。到后面打哪个城要看看别人的意见。但是对于具体做事就不是很关心了。正如韩信所言：大王带将，韩信带兵。怎么带兵是将的事，我是统帅，我才不管你怎么折腾呢。它的学问在于，一个人，有没有用，能不能用。什么时候能用，什么时候就得处理掉。听上去，心狠手辣，仿佛众人皆棋子。不得不说，对于厚黑之道，刘邦团队表现的不亚于三国。不知如果把刘邦放在三国会是什么局面？\n  “我要命！我要什么脸啊！”\n  “他非要！”“你给了？”“他非要！”“你就给了？”“我和他说我来了。”“没给成？哈哈，没给成！没给成！没给成！”\n  “我是一家之主，我就是天，对错你都忍着。”\n  项羽 项羽：项羽一看，便是传统上我们所讲的大丈夫。一开始看到秦始皇依仗便有“男人当如是”的豪言。不愿与酒徒为伍，不愿与没有骨气的为伍。对人挺挑剔的，（反观刘邦，任人唯贤，有才无德？没事，能做事就行，大不了做完了再把你废了就是了）。让人受不了的是残暴无道，屠城杀降，这个没什么可说。令我想不透的是都说“江山梦、儿女情”，可项羽对天下却没什么兴趣，叔父整天教诲亡秦复楚这家伙真信了，千里迢迢跑到咸阳把秦灭了结果又千里迢迢地跑回来家做西楚霸王。与之对应的，项羽对虞姬的感情，没了她项羽就不活了一样。\n  “男人当如是。”\n  “国可不在，但尊严不可失，我楚人，绝不忍辱偷生！”\n  “一群躲在自己坑洞中 惶惶不可终日的窝囊废有什么时机可言。”\n  “如果可以，我想一辈子都听你弹琴……”\n  或许，人各有志，可怜范增老前辈日益唠叨 “ 一个人心有多大，天下就有多大。”\n垓下风凛冽，\r楚歌声凄切，多少离别，\r看夕阳西斜，\r踏破马蹄铁，\r恰似一钩晓月。\r张良 张良：不知道为什么，或许是自己历史知识的局限吧。剧中对张良的表现，好像自己的算盘很重，始终都在惦记着复韩。尤其是很多时候看刘邦的眼神，对刘邦的保留。给你的感觉对刘邦很不忠诚一样。或许有点像《诸葛亮死前6年与死后46年的世界》里讲的一样，英雄辈出的年代里，不同的英雄为了各自不同的梦想完成了共同的伟大的事业。\n韩信 韩信：自己是比较喜欢韩信的，但是在剧中，对韩信的表现极少。几场著名的战役都轻描淡写。我觉得作为楚汉传奇这段过程，同时又是中国谋战派代表人物，韩信怎么也该算一个重要角色吧。但是还是让人觉得作为汉朝顶梁柱，最后糟一群宫女乱棒打死甚为惋惜，感慨万千。狡兔死走狗烹。绝对是韩信结局的真实写照。演员上，段奕宏去演，总感觉有些别扭。但演的很不错的，除了在齐的个别镜头，其他的镜头让你觉得这跟章邯一样脑子只有打仗。\n英布 英布：同作为三大名将，英布的表现比韩信的还少，彭越就更不用说了。给人的感觉不如新水浒的豹子头。或许这部戏的重心想放在人物性格的刻画上吧。但既然耗费巨资，就该在画面镜头上下点功夫吧。同样结局凄凉。\n章邯 章邯：看到他，只有两个字：“军人”。最开始效忠秦朝，不涉政治。后来体恤士兵无奈归楚，既然为楚卖命，便一心谋战直至战死。无愧于“著名将领”。\n写在最后 整部片子让人感慨的除了战场的骁勇，更多的是战后众功臣的凄惨命运，张良引退、萧何、韩信、卢绾糟毒手。（留下来的只有曹参？）。让人想起春秋战国，每个生前不可一世的名臣良将，结局无一不令人悲叹。\n看完之后还是对这个局面更加了解了一些，更加明白后来汉武帝后来的晁错后来的主父偃。更加理解一个乱世的终结的多么的不容易。\n大江东去浪淘尽\r多少悲愁\r天下英雄时势造就\r风云人生为梦想奔走\r笑看成败\r曲终人散\r暮然回首\r你不在左右\r繁华过后才是寂寞的开头\r天下英雄\r大风吹 云飞扬\r谁知\r我心所向\r","date":1369045680,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369045680,"objectID":"ed2ae4cca943ef751be6aee5af6ca645","permalink":"/post/typecho/68-%E7%94%B5%E5%BD%B1%E6%A5%9A%E6%B1%89%E4%BC%A0%E5%A5%87/","publishdate":"2013-05-20T18:28:00+08:00","relpermalink":"/post/typecho/68-%E7%94%B5%E5%BD%B1%E6%A5%9A%E6%B1%89%E4%BC%A0%E5%A5%87/","section":"post","summary":"这个电视最开始看，总觉得似曾相识。一拍大腿，发现全是新三国的演员。。。\n简单地说就是康熙、张飞、鲁肃、吕布、许攸、荀彧、刘备及其儿子各种叛变后重新划分天下。对于剧情不想评论太多，感觉自己想看的很多东西没有演出来。\n","tags":["随想","影视"],"title":"电影《楚汉传奇》","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n     以下所有命令基于 ubuntu12.04 系统。centos、rhel 慎重      添加用户    useradd   adduser   自动创建目录       添加 sudoers      vim /etc/sudoers        修改主机名/机器名   # 首选修改 /etc/hostname 和 /etc/hosts 文件对应的机器名 # 然后 hostname NAME      查看端口占用    netstat -tunpl    grub修复   linux改为主引导   前日装mac时把引导毁掉了，pe修复发现只能修复win引导。linux引导还得自己再修复。  liveCD（我直接用的烧在U盘的ubuntu试用）。  进入终端  fdisk -l mount /dev/sdaX /mnt mount /dev/sdaY /mnt/boot #如果有单独boot分区 grub-install --root-directory=/mnt /dev/sda init 6  重启之后就ok了～  过程中出现了warning 。不用管，重启没有问题。     grub添加到windows下（兼顾mac）   在装linux 的时候，可以把grub安装在linux磁盘，然后在win下用easyBCD把grub添加到win下，这样在一个引导下就可以选择三个系统。     不启动桌面环境    首先在 /etc/default/grub  然后 update-grub     ErrorCode(1)    问题：E: Sub-process /usr/bin/dpkg returned an error code (1)   删除 /var/lib/dpkg/info/XXX.postinst (只删除对应的这个文件）  然后 apt-get install -f    ","date":1368969222,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1368969222,"objectID":"11531fe00776d577c36f54986de0d3b0","permalink":"/post/csdn/linux-%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/","publishdate":"2013-05-19T21:13:42+08:00","relpermalink":"/post/csdn/linux-%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 以下所有命令基于 ubuntu12.04 系统。centos、rhel 慎重 添加用户 useradd adduser 自动创建目录 添加 sudoers vim /etc/sudoers 修改主机名/机器","tags":["Linux"],"title":"Linux 系统问题整理","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; struct Point{ double x,y; Point(){}; Point(double a,double b):x(a),y(b){} friend Point operator + (Point a,Point b){ return Point(a.x+b.x,a.y+b.y); } friend Point operator - (Point a,Point b){ return Point(a.x-b.x,a.y-b.y); } friend Point operator * (Point a,double b){ return Point(a.x*b,a.y*b); } friend Point operator / (Point a,double b){ return Point(a.x/b,a.y/b); } void input(){ scanf(\"%lf%lf\",\u0026amp;x,\u0026amp;y); } }; struct line{ Point a,b; line(Point x,Point y):a(x),b(y){} }; // 点积 double dot(Point a,Point b){ return a.x*b.x+a.y*b.y; } // 叉积 double det(Point a,Point b){ return a.x*b.y-a.y*b.x; } // 判断符号 int aps(double x){ double eps = 1e-8; if (fabs(x)\u0026lt;=eps) return 0; if (x\u0026gt;0) return 1; return -1; } // 有交点 bool isCom(line a,line b){ return (bool)aps(det(a.a-a.b,b.a-b.b)); } // 同线 bool isOne(line a,line b){ if (!aps(det(a.b-a.a,b.a-a.a)) \u0026amp;\u0026amp; !(aps(det(a.b-a.a,b.b-a.a)))) return 1; return 0; } // 求交点 Point crossPoint(line a,line b){ double s1=det(a.a-b.a,b.b-b.a); double s2=det(a.b-b.a,b.b-b.a); return (a.a*s2-a.b*s1)/(s2-s1); }  调用  int main(){ int n; Point c[8]; scanf(\"%d\",\u0026amp;n); printf(\"INTERSECTING LINES OUTPUT\\n\"); while (n--){ for (int i(1);i\u0026lt;=4;i++){ c[i].input(); //printf(\" %.2lf %.2lf\\n\",c[i].x,c[i].y); } line a = line(c[1],c[2]); line b = line(c[3],c[4]); if (isOne(a,b)) printf(\"LINE\\n\"); else if (!isCom(a,b)) printf(\"NONE\\n\"); else { Point t=crossPoint(a,b); printf(\"POINT %.2f %.2f\\n\",t.x,t.y); // PS：在G++里，double以%lf读入以%f输出 } } printf(\"END OF OUTPUT\\n\"); return 0; }      ","date":1368859352,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1368859352,"objectID":"c65c42e7e72903de08757ebe7c4b582c","permalink":"/post/csdn/%E7%82%B9%E7%BA%BF%E8%AE%A1%E7%AE%97/","publishdate":"2013-05-18T14:42:32+08:00","relpermalink":"/post/csdn/%E7%82%B9%E7%BA%BF%E8%AE%A1%E7%AE%97/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; struct Point{ double x,y; Point(){}; Point(double a,double b):x(a),y(b){} friend Point operator + (Point a,Point b){ return Point(a.x+b.x,a.y+b.y); } friend Point operator - (Point a,Point b){ return Point(a.x-b.x,a.y-b.y); } friend Point operator * (Point a,double b){ return Point(a.x*b,a.y*b); } friend Point operator","tags":[],"title":"点线计算","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n 对象元素  obj = {\"name\":\"Jom\"}; document.writeln(obj.name); 数组  obj = [\"name\",\"Jom\"]; document.writeln(obj); 对象数组  obj = [{\"name\":\"Jom\"}]; document.writeln(obj[0].name);  与字符串转换  txt = \"{\\\"name\\\":\\\"Jank\\\"}\"; obj = eval(\"(\"+txt+\")\"); document.writeln(obj.name);  JSON的值：      数字（整数或浮点数）   字符串（在双引号中）   逻辑值（true 或 false）   数组（在方括号中）   对象（在花括号中）   null          ","date":1368506998,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1368506998,"objectID":"9c3f8f6f1b85e98e113d9a17f0db8202","permalink":"/post/csdn/json-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","publishdate":"2013-05-14T12:49:58+08:00","relpermalink":"/post/csdn/json-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 对象元素 obj = {\"name\":\"Jom\"}; document.writeln(obj.name); 数组 obj = [\"name\",\"Jom\"]; document.writeln(obj); 对象数组 obj = [{\"name\":\"Jom\"}]; document.writeln(obj[0].name); 与字符串转换 txt = \"{\\\"name\\\":\\\"Jank\\\"}\"; obj = eval(\"(\"+txt+\")\"); document.writeln(obj.name); JSON的值： 数字（整数或浮点","tags":["JSON"],"title":"JSON 入门笔记","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  建立请求  var xmlhttp; if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); } else {// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); } 发送请求   xmlhttp.open(\"GET\",\"kzzhr\",true); xmlhttp.send(); aa   输出内容  xmlhttp.onreadystatechange=function(){ if (xmlhttp.readyState==4 \u0026amp;\u0026amp; xmlhttp.status==200){ document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; } }  放置数组  var tap=new Array(\"ID\",\"name\",\"school\",\"grade\"); x=xmlhttp.responseXML.documentElement.getElementsByTagName(\"item\"); for (i=0;i\u0026lt;x.length;i++){ var cc= new Array(); for (j=1;j\u0026lt;tap.length;j++){ var xx = x[i].querySelector(tap[j]).firstChild.nodeValue; cc.push(xx); } mx.push(cc); }            ","date":1368424755,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1368424755,"objectID":"84cf25f4405d9776ad882da806020392","permalink":"/post/csdn/ajax-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","publishdate":"2013-05-13T13:59:15+08:00","relpermalink":"/post/csdn/ajax-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 建立请求 var xmlhttp; if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); } else {// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); } 发送请求 xmlhttp.open(\"GET\",\"kzzhr\",true); xmlhttp.send(); aa 输出内容 xmlhttp.onreadystatechange=function(){ if (xmlhttp.readyState==4 \u0026amp;\u0026amp; xmlhttp.status==200){ document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; } } 放置数","tags":["AJAX"],"title":"AJAX 入门笔记","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  软件源     linuxdeepin   不怎么入流，但是个人觉得在国内做的很用心的一个   注意linuxdeepin 用的命令是 apt-get   ####Ubuntu 源#### # This file was created by deepin software center, please do not modify manually! deb http://packages.linuxdeepin.com/ubuntu raring main restricted universe multiverse deb http://packages.linuxdeepin.com/ubuntu raring-security main restricted universe multiverse deb http://packages.linuxdeepin.com/ubuntu raring-updates main restricted universe multiverse # deb http://packages.linuxdeepin.com/ubuntu raring-proposed main restricted universe multiverse # deb http://packages.linuxdeepin.com/ubuntu raring-backports main restricted universe multiverse deb-src http://packages.linuxdeepin.com/ubuntu raring main restricted universe multiverse deb-src http://packages.linuxdeepin.com/ubuntu raring-security main restricted universe multiverse deb-src http://packages.linuxdeepin.com/ubuntu raring-updates main restricted universe multiverse # deb-src http://packages.linuxdeepin.com/ubuntu raring-proposed main restricted universe multiverse # deb-src http://packages.linuxdeepin.com/ubuntu raring-backports main restricted universe multiverse ####Linux Deepin 特有源#### deb http://packages.linuxdeepin.com/deepin raring main universe non-free deb-src http://packages.linuxdeepin.com/deepin raring main universe non-free\ndeb http://packages.linuxdeepin.com/deepin raring-updates main universe non-free deb-src http://packages.linuxdeepin.com/deepin raring-updates main universe non-free   有了这个软件源，可以下载 深度软件中心，这里有大部分在win下常用的软件，有原生的wps和搜狗输入法，也有许多集成wine的win软件，比如qq、迅雷等。     软件      办公类       wunderlist   sudo add-apt-repository ppa:fogger-app-authors/ppa sudo add-apt-repository ppa:loneowais/fogger sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install wunderlist-fogapp      中文包     kubuntu安装中文   sudo apt-get install language-pack-kde-zh language-pack-kde-zh-base language-pack-zh language-pack-zh-base      libreoffice安装中文包   sudo apt-get install libreoffice-l10n-zh-cn libreoffice-help-zh-cn        ","date":1367483495,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1367483495,"objectID":"6cc9b6b5fcbdbbbe78e17190df2dcaee","permalink":"/post/csdn/linux-%E5%B0%8F%E7%99%BD%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%95%B4%E7%90%86/","publishdate":"2013-05-02T16:31:35+08:00","relpermalink":"/post/csdn/linux-%E5%B0%8F%E7%99%BD%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%95%B4%E7%90%86/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 软件源 linuxdeepin 不怎么入流，但是个人觉得在国内做的很用心的一个 注意linuxdeepin 用的命令是 apt-get ####Ubuntu 源##","tags":["Linux"],"title":"Linux 小白软件包整理","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目   输入一个表达式，计算出它的值。运算符有 + - × / （ ）。   思路   这是我们学栈时碰到的一个问题，大体方法是利用双栈把中缀表达式转换成后缀表达式进行计算      ------------------------------------------------------------------------------------------------    1.拆分数字与运算符    ：遇到运算符截断、存储、清空。    2.转后缀表达式    ：栈A存放后缀表达式，栈B存放运算符    记 B栈顶运算符为a1,当前运算符为a2（若a2为数字直接 a2-\u0026gt;A ）    1）若 a1\u0026gt;a2，a1-\u0026gt;A，a2-\u0026gt;B    1）若 a1\u0026lt;a2，a2-\u0026gt;B；     2）若 a1\u0026gt;=a2     1.若a1\u0026gt;a2，a1-\u0026gt;A；（只要该条件满足则一直执行，使得优先级高的运算符放在A中）   2.将高级运算符都赶走后，要判断a1=a2 ?（ 即是否为()相遇）   如果为左右括号的话就把做括号弹出，否则把a2-\u0026gt;B。（注意与1的区别，一个）可以一直赶走比它高级的运算法，但是只能抵消一个左括号）      PS: a1\u0026gt;a2 表示 在此式中先算a1再算a2，a1与a2的关系在初始化中建立。     3.计算后缀表达式    :   从左往右扫描，遇到运算符则处理前两位数字    -------------------------------------------------------------------------------------------------      代码   #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; string ss; vector\u0026lt;double\u0026gt; ans; vector\u0026lt;string\u0026gt; s,A; stack\u0026lt;char\u0026gt; B; int cmp[8][8]={\t{1,1,-1,-1,-1,1}, {1,1,-1,-1,-1,1}, {1,1,1,1,-1,1}, {1,1,1,1,-1,1}, {-1,-1,-1,-1,-1,0}, {1,1,1,1,0,0}}; int gec[333]; bool isNum(char a){ switch(a){ case '+': case '-': case '*': case '/': case '(': case ')': return false; } return true; } void init(){ gec['+']=0; gec['-']=1; gec['*']=2; gec['/']=3; gec['(']=4; gec[')']=5; } void Quit(int v){ cout \u0026lt;\u0026lt; \"ERROR : \"; switch(v){ case 1: cout \u0026lt;\u0026lt; \"DIVISION BY 0\"; break; case 2: cout \u0026lt;\u0026lt; \"PARENTHESES ARE NOT EVEN\"; break; } cout \u0026lt;\u0026lt; endl; exit(0); } double gen(string s){ double tmp; sscanf(s.c_str(),\"%lf\",\u0026amp;tmp); return tmp; } void check(){ stack\u0026lt;char\u0026gt; q; for (string::size_type i(0);i!=ss.size();i++){ if (ss[i]=='(') q.push(ss[i]); if (ss[i]==')') { if (q.empty()) Quit(2); if (q.top()=='(') q.push(ss[i]); else q.pop(); } } if (q.size()) Quit(2); } void ready(){ cin \u0026gt;\u0026gt; ss; check(); ss+=')'; string str=\"\"; for (string::size_type i(0);i!=ss.size();i++){ if (isNum(ss[i])){ str+=ss[i]; }else { if (str.size()) s.push_back(str); str=ss[i]; s.push_back(str); str=\"\"; } } } void changetype(){ B.push('('); for (unsigned int i(0);i!=s.size();i++){ if (isNum(s[i][0])){ A.push_back(s[i]); }else{ char ch=s[i][0]; if (cmp[gec[B.top()]][gec[ch]]\u0026lt;0){ B.push(ch); }else if (cmp[gec[B.top()]][gec[ch]]\u0026gt;=0){ string str; while (cmp[gec[B.top()]][gec[ch]]\u0026gt;0){ str=B.top(); A.push_back(str); B.pop(); } if (cmp[gec[B.top()]][gec[ch]]==0){ B.pop(); }else{ B.push(ch); } }  } }  } void calcit(){ for (int i(0);i!=A.size();i++){ if (isNum(A[i][0])) { ans.push_back(gen(A[i])); }else{ double a1=ans[ans.size()-2]; double a2=ans[ans.size()-1]; printf(\u0026quot;%.2f%c%.2f=\u0026rdquo;,a1,A[i][0],a2); switch (A[i][0]){ case \u0026lsquo;+\u0026rsquo;: a1+=a2; break; case \u0026lsquo;-': a1-=a2; break; case \u0026lsquo;': a1=a2; break; case \u0026lsquo;/': if (!a2){ Quit(1); } a1/=a2; break; } printf(\u0026quot;%.2f\\n\u0026rdquo;,a1); ans.pop_back(); ans[ans.size()-1]=a1; } } printf(\u0026quot;%.3f\\n\u0026rdquo;,ans[0]); } int main(){ init(); ready(); changetype(); calcit(); return 0; }   \n  ","date":1367303658,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1367303658,"objectID":"778a7a5a19384c24e67372356e99d699","permalink":"/post/csdn/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97/","publishdate":"2013-04-30T14:34:18+08:00","relpermalink":"/post/csdn/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目 输入一个表达式，计算出它的值。运算符有 + - × / （ ）。 思路 这是我们学栈时碰到的一个问题，大体方法是","tags":[],"title":"表达式计算","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n    ↑ ↑ ↑ ↑ ↑ 请看目录 ↑ ↑ ↑ ↑ ↑     下载 / 安装    windows / MAC OS    官网下载，双击安装，这个都会吧～       linux   linux下安装，一种办法是从官网下载 tar.bz ，手动安装。  这里介绍用 apt-get 自动安装方法： sudo add-apt-repository ppa:webupd8team/sublime-text-2 sudo apt-get update sudo apt-get install sublime-text-dev  命令结束后，一切搞定！  看看应用列表里是不是出来个亲切的图表？（虽然这个图标一点也不亲切。。）     修改siderbar颜色          Windows    修改 主题文件： /Pristine Packages/Theme - Default.sublime-package/Default.sublime-theme           背景色        { \"class\": \"sidebar_tree\", \"row_padding\": [8, 3], \"indent\": 12, \"indent_offset\": 17, \"indent_top_level\": false, \"layer0.tint\": [30, 30, 30], \"layer0.opacity\": 1.0, \"dark_content\": false },   文字       { \"class\": \"sidebar_label\", \"color\": [150, 150, 150], \"font.bold\": false // , \"shadow_color\": [250, 250, 250], \"shadow_offset\": [0, 0] },   分割线       { \"class\": \"sidebar_container\", \"layer0.tint\": [10, 10, 10], \"layer0.opacity\": 1.0, \"layer0.draw_center\": false, \"layer0.inner_margin\": [0, 0, 1, 0], \"content_margin\": [0, 0, 1, 0] },       其实RGB颜色大家都明白，可以改成自己喜欢的样子。            PS：备份原来的东西的时候一定要把类型名改了，因为sublime会去加载所有的包。            另：感谢 亦翔百科  给予很大帮助       Linux    注意一下Sublime存放的位置就可以：/usr/lib/sublime-text-2    如果是安装包安装，一般是 /opt 下。    附： linux目录解析        MAC OS X    OS下有些麻烦，不能直接修改，需要点工具读写文件，我是在win下改好后再覆盖过来的。       安装插件     同vim一样，sublime本身不过只是一个编辑器，要想把它改装成IDE，需要安装各种插件；当然，即便你不需要插件它本身的强大也可以给你带来意想不到的惊喜！      首先搞定 插件管理器   顾名思义是用来管理插件的工具，先安上它再搞别的插件就方便了。   安装方法：   选择菜单 view-\u0026gt;show console ，这时候你就可以看到下边出现了 控制台窗口。（显示框+输入框）这里可以执行python代码   输入以下代码，就可以安装好 插件管理器（package control）了    插一句：很多地方的代码为 import urllib2,os; 这个是python2.x的代码，在python3.x里已经换成了 import urllib.request,os; 如果你是Sublime2.0及以下的版本，请自行修改代码。     import urllib.request,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib.request.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read())   接下来一定记住先重启软件！   按住ctrl+shift+p      可以去装自己喜欢的插件了    装完插件管理器，你就可以去找自己需要的插件然后安装。  有一些网站会总结一些不错的插件，你可以去试试。  当然我更希望你先看已看我写的。。  快速编码类    Emmet ：跟Zen Coding一样，但是ST3已不再支持 Zen，这个也是一样的，但是要注意先禁掉 sublime 本身的自动补全功能，在Preferens -\u0026gt; Setting-User 里添加     代码格式化     代码格式化包括各种语言的，这里列举几个：（所有的插件都可以在 Package control 里直接搜索得到）      C / C++：SublimeAStyleFormat   HTML：Tag         List：   看起来是一份不错的总结   一些必不可少的 ST 插件    20个强大的插件        配置编译环境      控制台输入（以C++为例）    原理很简单，就是在外部建立一个用来执行文件的 bat，然后调用它。注意的就是，需要用start 来打开一个新窗口，同时需要 pause 一下来看结果，其中很蛋疼的就是Sublime默认后台执行你的start，如果你的pause和start放在一个文件了pause对start %1 的文件是无效的，因此其实需要建立两个文件。注意环境变量。。。（关于什么是环境变量，三两句解释不清楚，最好自己百度一下。）  配好之后个人感觉控制台输入意义不是很大，做题的话都是从文件读入，做开发基本不需要读入。So~ 各位慎重。    MyCRun.bat  @echo off %1 echo. echo ------------------- pause exit  MyCallRun.bat  @start MyCRun %1   配置文件在 Sublime Text 3\\Packages\\C++.sublime-package 。 先备份一下。   修改里面的 C++.sublime-build 为  { \"shell_cmd\": \"g++ \\\"${file}\\\" -o \\\"${file_path}/${file_base_name}\\\"\", \"file_regex\": \"^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\", \"working_dir\": \"${file_path}\", \"selector\": \"source.c, source.c++\", \u0026quot;variants\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;Run\u0026quot;, \u0026quot;shell_cmd\u0026quot;: \u0026quot;g++ \\\u0026quot;${file}\\\u0026quot; -o \\\u0026quot;${file_path}/${file_base_name}\\\u0026quot; \u0026amp;amp;\u0026amp;amp; MyCallRun \\\u0026quot;${file_path}/${file_base_name}.exe\\\u0026quot;\u0026quot; // 其实就是这里加了个MyCallRun } ]  }   \n  C/C++    Sublime Text 3 默认配置好了 c++ 。但是需要你自己把 gcc 目录添加进环境变量        Java    Sublime Text 3 默认只运行了 javac，需要自己添加运行。    苦逼看不懂 Sublime 的命令格式，于是把 javac 改成一个自己的bat。（感觉也可以像C++那样用 \u0026amp;\u0026amp; 连起来）    在命令行可直接访问的地方建立 myJRun.bat （我直接放在 jdk/bin 下了）     @ECHO OFF cd %~dp1 ECHO Compiling %~nx1... IF EXIST %~n1.class ( DEL %~n1.class ) javac %~nx1 IF EXIST %~n1.class ( ECHO Running... ECHO ----------------------OUTPUT---------------------- java %~n1 )  注意不能使用 cls 。     修改java的编译选项（备份好原来的）。   目录：Packages/Java.sublime-package/JavaC.sublime-build   { \"shell_cmd\": \"myJRun.bat \\\"$file\\\"\", \"file_regex\": \"^(...*?):([0-9]*):?([0-9]*)\", \"selector\": \"source.java\" } 这样以后写的Java代码点 Build 就会自动运行了。   这种办法不能跨平台，再研究研究Sublime自己的方式。     Go   用 Sublime 开发 golang 的环境很简单，只需要安装一个 GoSublime 就差不多了。       Ubuntu下输入中文   参考整理 这里       需要自己编译一个文件加载运行。所以需要用到一些编译环境      步骤1：安装gtk环境      sudo apt-get install libgtk2.0-dev pkg-config  另外貌似不支持ibus，我用的 fcitx+sogou      步骤2：保存下面这个文件到 sublime_imfix.c      /* sublime-imfix.c Use LD_PRELOAD to interpose some function to fix sublime input method support for linux. By Cjacker Huang \u0026lt;jianzhong.huang at i-soft.com.cn\u0026gt; gcc -shared -o libsublime-imfix.so sublime_imfix.c pkg-config --libs --cflags gtk+-2.0 -fPIC LD_PRELOAD=./libsublime-imfix.so sublime_text */ #include \u0026lt;gtk/gtk.h\u0026gt; #include \u0026lt;gdk/gdkx.h\u0026gt; typedef GdkSegment GdkRegionBox;\nstruct _GdkRegion { long size; long numRects; GdkRegionBox *rects; GdkRegionBox extents; };\nGtkIMContext *local_context;\nvoid gdk_region_get_clipbox (const GdkRegion *region, GdkRectangle *rectangle) { g_return_if_fail (region != NULL); g_return_if_fail (rectangle != NULL);\nrectangle-\u0026gt;x = region-\u0026gt;extents.x1; rectangle-\u0026gt;y = region-\u0026gt;extents.y1; rectangle-\u0026gt;width = region-\u0026gt;extents.x2 - region-\u0026gt;extents.x1; rectangle-\u0026gt;height = region-\u0026gt;extents.y2 - region-\u0026gt;extents.y1; GdkRectangle rect; rect.x = rectangle-\u0026gt;x; rect.y = rectangle-\u0026gt;y; rect.width = 0; rect.height = rectangle-\u0026gt;height; //The caret width is 2; //Maybe sometimes we will make a mistake, but for most of the time, it should be the caret. if(rectangle-\u0026gt;width == 2 \u0026amp;\u0026amp; GTK_IS_IM_CONTEXT(local_context)) { gtk_im_context_set_cursor_location(local_context, rectangle); } }\n//this is needed, for example, if you input something in file dialog and return back the edit area //context will lost, so here we set it again.\nstatic GdkFilterReturn event_filter (GdkXEvent *xevent, GdkEvent *event, gpointer im_context) { XEvent *xev = (XEvent *)xevent; if(xev-\u0026gt;type == KeyRelease \u0026amp;\u0026amp; GTK_IS_IM_CONTEXT(im_context)) { GdkWindow * win = g_object_get_data(G_OBJECT(im_context),\u0026ldquo;window\u0026rdquo;); if(GDK_IS_WINDOW(win)) gtk_im_context_set_client_window(im_context, win); } return GDK_FILTER_CONTINUE; }\nvoid gtk_im_context_set_client_window (GtkIMContext *context, GdkWindow *window) { GtkIMContextClass *klass; g_return_if_fail (GTK_IS_IM_CONTEXT (context));大 klass = GTK_IM_CONTEXT_GET_CLASS (context); if (klass-\u0026gt;set_client_window) klass-\u0026gt;set_client_window (context, window);\nif(!GDK_IS_WINDOW (window)) return; g_object_set_data(G_OBJECT(context),\u0026ldquo;window\u0026rdquo;,window); int width = gdk_window_get_width(window); int height = gdk_window_get_height(window); if(width != 0 \u0026amp;\u0026amp; height !=0) { gtk_im_context_focus_in(context); local_context = context; } gdk_window_add_filter (window, event_filter, context); }  步骤3：编译之\n     gcc -shared -o libsublime-imfix.so sublime_imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPIC    步骤4：运行      其实到这里就可以运行了。试试   LD_PRELOAD=./libsublime-imfix.so sublime_text  应该就成功了吧，但是不能每次都这么输命令，我是这么处理的      - 把 sublime_imfix.so 放在sublime安装目录 （我的在 /opt/sublime_text/） - 在 /usr/local/bin 或者其他PATH下 新建一个文件Subl写入： LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text - 新建一个Launcher命令为 /usr/local/bin/Subl （大写只是用来区别于一般命令）   大功告成！     关于破解的那点事儿      网上关于sublime的破解方法，一搜一大堆。但是我至今都没有去破解，原因很简单，如果一个可以无限期试用的软件你都忍心破解的话。。大家同为开发人员，如果自己都去无良的搞破解，还指望谁来为软件付费？（我一个学机械的朋友如是说）                  未完待续。            ","date":1366018960,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1366018960,"objectID":"42d95688853ba0303beae662dea043d7","permalink":"/post/csdn/sublime-text-3-%E5%8F%B2%E4%B8%8A%E6%9C%80%E6%80%A7%E6%84%9F%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/","publishdate":"2013-04-15T17:42:40+08:00","relpermalink":"/post/csdn/sublime-text-3-%E5%8F%B2%E4%B8%8A%E6%9C%80%E6%80%A7%E6%84%9F%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 ↑ ↑ ↑ ↑ ↑ 请看目录 ↑ ↑ ↑ ↑ ↑ 下载 / 安装 windows / MAC OS 官网下载，双击安装，这个都会吧～ linux linux下安装，一","tags":["Sublime"],"title":"Sublime Text 3 史上最性感的编辑器","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目   http://poj.org/problem?id=1088     思路   经典的记忆化搜索：搜索+记忆化   搜索：一个一个找，能滑就滑    记忆化：优化重复的路径，记录每个点能滑的最远距离（不论从哪里滑倒这里，从这里往下滑行的最远距离是一定的）    代码   #include \u0026lt;cstdio\u0026gt; const int dx[]={0,0,1,-1}; const int dy[]={1,-1,0,0}; int n,m,a[111][111],f[111][111],max; int so(int x,int y){ if (f[x][y]) return f[x][y]; for (int i(0);i\u0026lt;4;i++){ int xx=x+dx[i]; int yy=y+dy[i]; if (a[xx][yy]\u0026gt;=a[x][y]) continue; if (so(xx,yy)+1\u0026gt;f[x][y]) f[x][y]=f[xx][yy]+1; } return f[x][y]; } int main(){ scanf(\"%d%d\",\u0026amp;n,\u0026amp;m); for (int i(1);i\u0026lt;=n;i++) a[i][0]=a[i][m+1]=11111; for (int i(1);i\u0026lt;=m;i++) a[0][i]=a[n+1][i]=11111; for (int i(1);i\u0026lt;=n;i++){ for (int j(1);j\u0026lt;=m;j++){ scanf(\"%d\",\u0026amp;a[i][j]); } } for (int i(1);i\u0026lt;=n;i++){ for (int j(1);j\u0026lt;=m;j++){ f[i][j]=so(i,j); if (f[i][j]\u0026gt;max) max=f[i][j]; } } printf(\"%d\\n\",max+1); return 0; }     ","date":1364014982,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1364014982,"objectID":"4bb5ab52b2eb58cd8691ed6df449890a","permalink":"/post/csdn/poj-1088-%E6%BB%91%E9%9B%AA/","publishdate":"2013-03-23T13:03:02+08:00","relpermalink":"/post/csdn/poj-1088-%E6%BB%91%E9%9B%AA/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目 http://poj.org/problem?id=1088 思路 经典的记忆化搜索：搜索+记忆化 搜索：一个一个找，能滑就滑 记忆化：优化重复的路径，记录每个点","tags":["POJ","Algorithm","ACM"],"title":"POJ 1088 滑雪","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目       Palindromic Squares    Rob Kolstad  Palindromes are numbers that read the same forwards as backwards. The number 12321 is a typical palindrome. Given a number base B (2 \u0026lt;= B \u0026lt;= 20 base 10), print all the integers N (1 \u0026lt;= N \u0026lt;= 300 base 10) such that the square of N is palindromic when expressed in base B; also print the value of that palindromic square. Use the letters 'A', 'B', and so on to represent the digits 10, 11, and so on. Print both the number and its square in base B.  PROGRAM NAME: palsquare   INPUT FORMAT  A single line with B, the base (specified in base 10).   SAMPLE INPUT (file palsquare.in)  10   OUTPUT FORMAT  Lines with two integers represented in base B. The first integer is the number whose square is palindromic; the second integer is the square itself.   SAMPLE OUTPUT (file palsquare.out)  1 1 2 4 3 9 11 121 22 484 26 676 101 10201 111 12321 121 14641 202 40804 212 44944 264 69696           思路   其实这个题目很简单，可是为毛我做了好久呢？其实，主要是我一贯试用cpp的string，这会想练练纯c，突然发现这玩意好繁琐。。又加上边聊边写，于是乎一道水题搞了一个多小时。      学习：     malloc(sizeof(char)*100);   // 不清零     calloc(100,sizeof(char));   // 清零   然后，没了。   代码   #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; const int dr[22]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K'}; const int N=300; int n; char * mir(char *a){ int l=strlen(a); char *b=(char*)calloc(22,sizeof(char)); for (int i(0);i\u0026lt;l;i++) b[i]=a[l-i-1]; b[l]='\\0'; return b; } char * base(int k,int n){ char *s=(char*)calloc(22,sizeof(char)); while (k){ int l=strlen(s); s[l]=dr[k%n]; s[l+1]='\\0'; k/=n; } return mir(s); } int main(){ freopen(\"palsquare.in\",\"r\",stdin); freopen(\"palsquare.out\",\"w\",stdout); scanf(\"%d\",\u0026amp;n); for (int i(1);i\u0026lt;=N;i++){ char *b1=base(i,n); char *b2=base(i*i,n); if (!strcmp(b2,mir(b2))){ printf(\"%s %s\\n\",b1,b2); } } return 0; }     ","date":1362996941,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1362996941,"objectID":"5c909cf7d41d0a756324fb807e759ba6","permalink":"/post/csdn/usaco-section-1.2.5-palindromic-squares/","publishdate":"2013-03-11T18:15:41+08:00","relpermalink":"/post/csdn/usaco-section-1.2.5-palindromic-squares/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目 Palindromic Squares Rob Kolstad Palindromes are numbers that read the same forwards as backwards. The number 12321 is a typical palindrome. Given a number base B (2 \u0026lt;= B \u0026lt;= 20 base 10), print all the integers N (1 \u0026lt;= N \u0026lt;= 300 base 10) such that the","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.2.5 Palindromic Squares","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目       Transformations     A square pattern of size N x N (1 \u0026lt;= N \u0026lt;= 10) black and white square tiles is transformed into another square pattern. Write a program that will recognize the minimum transformation that has been applied to the original pattern given the following list of possible transformations:  #1: 90 Degree Rotation: The pattern was rotated clockwise 90 degrees.   #2: 180 Degree Rotation: The pattern was rotated clockwise 180 degrees.   #3: 270 Degree Rotation: The pattern was rotated clockwise 270 degrees.   #4: Reflection: The pattern was reflected horizontally (turned into a mirror image of itself by reflecting around a vertical line in the middle of the image).   #5: Combination: The pattern was reflected horizontally and then subjected to one of the rotations (#1-#3).   #6: No Change: The original pattern was not changed.   #7: Invalid Transformation: The new pattern was not obtained by any of the above methods.   In the case that more than one transform could have been used, choose the one with the minimum number above.  PROGRAM NAME: transform   INPUT FORMAT     Line 1:   A single integer, N     Line 2..N+1:   N lines of N characters (each either `@' or `-'); this is the square before transformation     Line N+2..2*N+1:   N lines of N characters (each either `@' or `-'); this is the square after transformation      SAMPLE INPUT (file transform.in)  3 @-@ --- @@- @-@ @-- --@   OUTPUT FORMAT  A single line containing the the number from 1 through 7 (described above) that categorizes the transformation required to change from the `before' representation to the `after' representation.   SAMPLE OUTPUT (file transform.out)  1            思路   思路很简单，就是枚举各种转换方法，然后与莫状态进行比较。   繁琐即需要注意的是，对于每种转换方式 i和j的关系，稍有疏忽就会全军覆没   另外注意的就是：如果初末状态相同，不能直接输出6，要先看看之前的5种方法能不能得到。因为题目要求从小号优先。我就被坑了一次。   代码   /* ID:zhrln1 PROG:transform LANG:C++ */ #include \u0026lt;cstdio\u0026gt; int n; typedef struct board{ char v[11][11]; } Board; Board a,b; Board rdboard(int n){ Board c; for (int i(1);i\u0026lt;=n;i++){ for (int j(1);j\u0026lt;=n;j++){ scanf(\"%c\",\u0026amp;c.v[i][j]); } scanf(\"\\n\"); } return c; } Board change(Board a,int k,int n){ Board c; for (int i(1);i\u0026lt;=n;i++){ for (int j(1);j\u0026lt;=n;j++){ switch(k){ case 1: c.v[i][j]=a.v[n-j+1][i];break; case 2: c.v[i][j]=a.v[n+1-i][n+1-j];break; case 3: c.v[i][j]=a.v[j][n+1-i];break; case 4: c.v[i][j]=a.v[i][n+1-j];break; } } } return c; } int isequel(Board a,Board b,int n){ for (int i(1);i\u0026lt;=n;i++){ for (int j(1);j\u0026lt;=n;j++){ if (a.v[i][j]!=b.v[i][j]) return 0; } } return 1; } int main(){ freopen(\"transform.in\",\"r\",stdin); freopen(\"transform.out\",\"w\",stdout); scanf(\"%d\\n\",\u0026amp;n); a=rdboard(n); b=rdboard(n); for (int i(1);i\u0026lt;=4;i++){ Board t=change(a,i,n); if (isequel(t,b,n)){ printf(\"%d\\n\",i); return 0; } if (i==4){ for (int j(1);j\u0026lt;=3;j++){ if (isequel(change(t,j,n),b,n)){ printf(\"5\\n\"); return 0; } } } } if (isequel(a,b,n)){ printf(\"6\\n\"); return 0; } printf(\"7\\n\"); return 0; }      ","date":1362989087,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1362989087,"objectID":"458634bae348378718c3d59760ace021","permalink":"/post/csdn/usaco-section-1.2.3-transformations/","publishdate":"2013-03-11T16:04:47+08:00","relpermalink":"/post/csdn/usaco-section-1.2.3-transformations/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目 Transformations A square pattern of size N x N (1 \u0026lt;= N \u0026lt;= 10) black and white square tiles is transformed into another square pattern. Write a program that will recognize the minimum transformation that has been applied to the original pattern given the following list of possible","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.2.3 Transformations","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目       Name That Number     Among the large Wisconsin cattle ranchers, it is customary to brand cows with serial numbers to please the Accounting Department. The cow hands don't appreciate the advantage of this filing system, though, and wish to call the members of their herd by a pleasing name rather than saying, \"C'mon, #4734, get along.\" Help the poor cowhands out by writing a program that will translate the brand serial number of a cow into possible names uniquely associated with that serial number. Since the cow hands all have cellular saddle phones these days, use the standard Touch-Tone(R) telephone keypad mapping to get from numbers to letters (except for \"Q\" and \"Z\"): 2: A,B,C 5: J,K,L 8: T,U,V 3: D,E,F 6: M,N,O 9: W,X,Y 4: G,H,I 7: P,R,S  Acceptable names for cattle are provided to you in a file named \"dict.txt\", which contains a list of fewer than 5,000 acceptable cattle names (all letters capitalized). Take a cow's brand number and report which of all the possible words to which that number maps are in the given dictionary  which is supplied as dict.txt in the grading environment (and is sorted into ascending order). For instance, the brand number 4734 produces all the following names: GPDG GPDH GPDI GPEG GPEH GPEI GPFG GPFH GPFI GRDG GRDH GRDI GREG GREH GREI GRFG GRFH GRFI GSDG GSDH GSDI GSEG GSEH GSEI GSFG GSFH GSFI HPDG HPDH HPDI HPEG HPEH HPEI HPFG HPFH HPFI HRDG HRDH HRDI HREG HREH HREI HRFG HRFH HRFI HSDG HSDH HSDI HSEG HSEH HSEI HSFG HSFH HSFI IPDG IPDH IPDI IPEG IPEH IPEI IPFG IPFH IPFI IRDG IRDH IRDI IREG IREH IREI IRFG IRFH IRFI ISDG ISDH ISDI ISEG ISEH ISEI ISFG ISFH ISFI  As it happens, the only one of these 81 names that is in the list of valid names is \"GREG\". Write a program that is given the brand number of a cow and prints all the valid names that can be generated from that brand number or ``NONE'' if there are no valid names. Serial numbers can be as many as a dozen digits long.  PROGRAM NAME: namenum   INPUT FORMAT  A single line with a number from 1 through 12 digits in length.   SAMPLE INPUT (file namenum.in)  4734   OUTPUT FORMAT  A list of valid names that can be generated from the input, one per line, in ascending alphabetical order.   SAMPLE OUTPUT (file namenum.out)  GREG       思路   思路一：   读入num，生成所有的名字，然后对比字典，听起来很简单的样子。 问题是   1）首先你需要构建一张数字字母映射表，对每个数字开一个数组或者一个字符串，写起来比较麻烦。   2）对于每个生成的字符串要对比字典，为了不超时（N_dict=5000），只能是O(n)的算法也就是一边生成一边对比同时记录对比的位置然后下次继续从此处开始对比。写的时候细节要很小心，比较费神。    思路二：   与思路一相反，从字典入手，把每一个名字转换成数字看是不是num，是的话输出（注意不能终止程序因为可能有多个匹配）。扫描一遍字典5000次运算而已。   PS：由于最长的名字有12位，int无力需要开 long long，再就是USACO服务器是linux，所以需要 %lld 。   代码   #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; int hash[26]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9}; long long num; char a[13]; int main(){ freopen(\"namenum.in\",\"r\",stdin); freopen(\"namenum.out\",\"w\",stdout); scanf(\"%lld\",\u0026amp;num); freopen(\"dict.txt\",\"r\",stdin); int yes=0; while (scanf(\"%s\",a) != EOF){ int l=strlen(a); long long s=0; for (int i(0);i\u0026lt;l;i++){ s=s*10+hash[a[i]-'A']; } if (s==num) { printf(\"%s\\n\",a); yes=1; } } if (!yes) printf(\"NONE\\n\"); return 0; }      ","date":1362460817,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1362460817,"objectID":"a348e3debf76fdd1feab6ce91fbe3a91","permalink":"/post/csdn/usaco-section-1.2.4-name-that-number/","publishdate":"2013-03-05T13:20:17+08:00","relpermalink":"/post/csdn/usaco-section-1.2.4-name-that-number/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目 Name That Number Among the large Wisconsin cattle ranchers, it is customary to brand cows with serial numbers to please the Accounting Department. The cow hands don't appreciate the advantage of this filing system, though, and wish to call the members of their herd by a pleasing name","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.2.4 Name That Number","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目       Milking Cows     Three farmers rise at 5 am each morning and head for the barn to milk three cows. The first farmer begins milking his cow at time 300 (measured in seconds after 5 am) and ends at time 1000. The second farmer begins at time 700 and ends at time 1200. The third farmer begins at time 1500 and ends at time 2100. The longest continuous time during which at least one farmer was milking a cow was 900 seconds (from 300 to 1200). The longest time no milking was done, between the beginning and the ending of all milking, was 300 seconds (1500 minus 1200). Your job is to write a program that will examine a list of beginning and ending times for N (1 \u0026lt;= N \u0026lt;= 5000) farmers milking N cows and compute (in seconds):  The longest time interval at least one cow was milked.   The longest time interval (after milking starts) during which no cows were being milked.    PROGRAM NAME: milk2   INPUT FORMAT     Line 1:   The single integer     Lines 2..N+1:   Two non-negative integers less than 1000000, the starting and ending time in seconds after 0500      SAMPLE INPUT (file milk2.in)  3 300 1000 700 1200 1500 2100   OUTPUT FORMAT  A single line with two integers that represent the longest continuous time of milking and the longest idle time.   SAMPLE OUTPUT (file milk2.out)  900 300   \n     思路   典型的离散化问题，其实也也说不清楚到底什么算是离散化。一般都是长度或者面积上给个区间让你去处理，把复杂的数字映射成自然数，通过 扫描（废话）、合并、裁剪 这么几种来处理“图形”。   所以，这个题，自然而然想到的就是合并线段，把这些线段合起来，看看最长能合出多长，合好之后再看看两两之间的空隙找个最长的然后print出来就OK。   如何合并？一般都是把一段对齐，然后按照另一端的某种顺序排列起来，然后一个一个拾取处理。（突然觉得 Kruskal的本质不也是去合并线段么，只不过合的不是一条线上而是一张图上的，以后研究研究~  ）。   对于这个题目，我的处理法子是，把所有的线段按端点位置排序，左端点优先，然后考虑右端点。一个sort而已嘛~ 然后一个一个拾取处理，记录已合成的大线段的起止坐标（l,r表示）。   对于每条线段，有一下三种情况：         ————   （已合成的线段）  ——   （ case 1.1 ）    ————   （ case 1.2 ）  ————   （ case 2 ）        即：   1. a[i].l \u0026lt;= r   1) a[i].r \u0026lt;= r   扔掉不用管了。   2) a[i].r \u0026gt; r 续上呗~    2. a[i].l \u0026gt; r   更新answer，另起炉灶。   代码   #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n; struct link{ int l,r; } a[111111]; int cmp(link a,link b){ return (a.l==b.l)?(a.r\u0026lt;=b.r):(a.l\u0026lt;b.l); } int main(){ freopen(\"milk2.in\",\"r\",stdin); freopen(\"milk2.out\",\"w\",stdout); scanf(\"%d\",\u0026amp;n); for (int i(1);i\u0026lt;=n;i++){ scanf(\"%d%d\",\u0026amp;a[i].l,\u0026amp;a[i].r); } sort(a+1,a+n+1,cmp); int l=a[1].l,r=a[1].r,max=a[1].r-a[1].l,nom=0; for (int i(2);i\u0026lt;=n;i++){ if (a[i].r\u0026lt;=r) continue; if (a[i].l\u0026lt;=r) { r=a[i].r; } else { if (r-l\u0026gt;max) max=r-l; if (a[i].l-r\u0026gt;nom) nom=a[i].l-r; l=a[i].l; r=a[i].r; } } printf(\"%d %d\\n\",max,nom); return 0;\t}      ","date":1362407001,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1362407001,"objectID":"096acb3e2b2b0f1b32c31d98f137e055","permalink":"/post/csdn/usaco-section-1.2.2-milking-cows/","publishdate":"2013-03-04T22:23:21+08:00","relpermalink":"/post/csdn/usaco-section-1.2.2-milking-cows/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目 Milking Cows Three farmers rise at 5 am each morning and head for the barn to milk three cows. The first farmer begins milking his cow at time 300 (measured in seconds after 5 am) and ends at time 1000. The second farmer begins at time 700 and","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.2.2 Milking Cows","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目   （由于USACO在外部无法直接访问题库，所以把题目贴上，可以通过上面的目录跳过）          Broken Necklace   You have a necklace of N red, white, or blue beads (3\u0026lt;=N\u0026lt;=350) some of which are red, others blue, and others white, arranged at random. Here are two examples for n=29: 1 2 1 2 r b b r b r r b r b b b r r b r r r w r b r w w b b r r b b b b b b r b r r b r b r r r b r r r r r r b r b r r r w Figure A Figure B r red bead b blue bead w white bead  The beads considered first and second in the text that follows have been marked in the picture. The configuration in Figure A may be represented as a string of b's and r's, where b represents a blue bead and r represents a red one, as follows: brbrrrbbbrrrrrbrrbbrbbbbrrrrb . Suppose you are to break the necklace at some point, lay it out straight, and then collect beads of the same color from one end until you reach a bead of a different color, and do the same for the other end (which might not be of the same color as the beads collected before this). Determine the point where the necklace should be broken so that the most number of beads can be collected.  Example  For example, for the necklace in Figure A, 8 beads can be collected, with the breaking point either between bead 9 and bead 10 or else between bead 24 and bead 25. In some necklaces, white beads had been included as shown in Figure B above. When collecting beads,  a white bead that is encountered may be treated as either red or blue and then painted with the desired color  . The string that represents this configuration will include the three symbols r, b and w. Write a program to determine the largest number of beads that can be collected from a supplied necklace.  PROGRAM NAME: beads   INPUT FORMAT      Line 1:   N, the number of beads     Line 2:   a string of N characters, each of which is r, b, or w      SAMPLE INPUT (file beads.in)  29 wwwbbrwrbrbrrbrbrwrwwrbwrwrrb   OUTPUT FORMAT  A single line containing the maximum of number of beads that can be collected from the supplied necklace.   SAMPLE OUTPUT (file beads.out)  11   OUTPUT EXPLANATION  Consider two copies of the beads (kind of like being able to runaround the ends). The string of 11 is marked.  original 'split' v wwwbbrwrbrbrrbrbrwrwwrbwrwrrb|wwwbbrwrbrbrrbrbrwrwwrbwrwrrb ******|***** rrrrrb|bbbbb \u0026lt;-- assignments 5 x r 6 x b \u0026lt;-- 11 total          思路   枚举   先看数据规模，n=350，O(n2）无压力。所以可以枚举每个断点，然后算出能拾几个珠子。貌似不是O(n2)，只是最坏的情况而已。应该也没问题吧，没试SORRY~  换个神似靠谱的法子吧   其实最开始，把题目错搞成找一串颜色相同的最长子串。想的是扫描一遍，对于每个点只需要判断前后能不能接上然后找出最长的就行了。后来发现其实要从一个断点向两头去寻找，但是全局代码懒得改了，就这样继续了。  还是从头到尾扫描找出每个断点向左能挂几个，从后往前扫描统计每个断点能向右挂几个。对于每一个珠子有三种情况：  1.跟前面一样或者自己是白色的，直接挂上；  2.剩下的就是另一种颜色了（既跟前面不一样又还不是白的）。这样的话首先要判断前面是不是白色的   1）如果是白色的还得把前面的颜色一样的也挂。    2）如果还不是白色的话只能另起炉灶。当然此时要先看一下挂了多长要不要替换answer。    PK  改完之后发现代码好长好长，而且核心代码重复性很大，第一种方法其实会更好的，但是要注意第一种方法还是要从每个点去向两头搜，往两头搜还是会有很多重复代码。感觉这两种法子没有什么大区别？   代码   #include \u0026lt;cstdio\u0026gt; char a[777]; int l[777],r[777],n; int main(){ freopen(\"beads.in\",\"r\",stdin); freopen(\"beads.out\",\"w\",stdout); scanf(\"%d%s\",\u0026amp;n,a); for (int i(0);i\u0026lt;n;i++){ a[n+i]=a[i]; } int i=0,j=a[0]; while (++i\u0026lt;2*n){ if ( a[i]==j || a[i]=='w' ){ l[i]=l[i-1]+1; } else { if (a[i-1]=='w'){ int k=i-1; while (k\u0026gt;=0 \u0026amp;\u0026amp; a[k]=='w'){k--;} l[i]=i-k-1; } j=a[i]; } } i=2*n-1; j=a[2*n-1]; while (--i\u0026gt;=0){ if ( a[i]==j || a[i]=='w'){ r[i]=r[i+1]+1; } else { if (a[i+1]=='w'){ int k=i+1; while (k\u0026lt;2*n \u0026amp;\u0026amp; a[k]=='w'){k++;} r[i]=k-i-1; } j=a[i]; } } for (int i(0);i\u0026lt;n;i++) l[i]=l[i+n]; int ans=0; for (int i(0);i\u0026lt;n-1;i++){ if (l[i]+r[i+1]\u0026gt;ans) ans=l[i]+r[i+1]; } if (ans\u0026gt;n){ printf(\"%d\\n\",n); } else { printf(\"%d\\n\",ans+2); } return 0; }        ","date":1362405498,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1362405498,"objectID":"0b917104ce3374d29a513c26dd345222","permalink":"/post/csdn/usaco-section-1.1.7-broken-necklace/","publishdate":"2013-03-04T21:58:18+08:00","relpermalink":"/post/csdn/usaco-section-1.1.7-broken-necklace/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目 （由于USACO在外部无法直接访问题库，所以把题目贴上，可以通过上面的目录跳过） Broken Necklace You have a necklace of N","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.1.7 Broken Necklace","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n 感谢你使用Gor编写博客 本文位于 posts/first-blog.md , 你可以任意删掉,修改这个文件  文件开头是当前文章的元数据\n date为自动生成, 当然,你可以修改,这是你的自由 permalink 可以是固定地址,也可以由gor为你自动生成 categories 就是分类, 可以多个 tags 同理,多个标签也是很常见的  请确保文件使用UTF8 without BOM编码\n你可以通过执行下面的语句来新建一篇博客: gor post 文章标题 编译你的博客,并预览之 gor compile #编译 gor http 然后打开你的浏览器,访问 http://127.0.0.1:8080 来预览\n你将使用Markdown来编写博客 Markdown 语法中文版 能让你快速入门其语法\n相信MarkdownPad或liteide会是你的编写博客的好帮手\n如果你打算部署到github的pages上  申请github帐户 新建一个库 username.github.com 即你的用户名命名的地址 将compiled目录,作为根路径,提交上去github.com上 稍等几分钟, 你即可通过 http://username.github.com 访问到  附上git教程 GitBook中文版 一般来说,你只需要几个简单的git命令就足以应付大部分需求(仅示例)\ngit clone git://github.com/wendal/wendal.net.git git add -A git commit -m \u0026quot;...\u0026quot; git pull git push 用gor编写博客将会是一件很开心的事,如果有任何意见或建议,欢迎到 gor的官网 提交issue 祝你使用愉快 ","date":1360296000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1360296000,"objectID":"5bb46bf92c767ce1d98a9e96fa60006f","permalink":"/post/dashayu/1360296000-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","publishdate":"2013-02-08T12:00:00+08:00","relpermalink":"/post/dashayu/1360296000-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 感谢你使用Gor编写博客 本文位于 posts/first-blog.md , 你可以任意删掉,修改这个文件 文件开头是当前文","tags":null,"title":"你的第一篇博客","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n    计算机语言的实质其实是为了让人类能够更好与计算机打交道，最终结果都是通过编译成二进制代码或通过解释器转译成二进制代码的形式，由计算机来 执行。而二进制就是 0 和1，假设 1 代表男人，0 代表女人，那么瞬间就可以发现世界就变成了一台大“计算机”。而爱情和情爱也可以看成是 1 和 0 组成的二进制机器码。   假如女人是一种编程语言，也许每个男人心中都有自己最喜欢的那一个吧？  我认为女人可分两类，“面向过程”和“面向对象”。“面向对象”的女人以寻找终身伴侣为目标，而“面向过程”的，则以经历难以忘怀的爱情时光为己任。各位程序猿当然也要按需选择最适合自己的“编程语言”，不要因为时髦而盲目追求“面向对象“，有时候过程可能比结果更重要。  当然了，“编程”还有多种“范式”（Fashion）可以遵循。各种语言也都有自己独特的“范式”。女人无数种，这里按流行的占星学星座（即不包括蛇夫座）分类，浅表一二。  特别声明：一家之言，仅供娱乐。莫对号入座。   白羊女——Basic 语言   这是一种很简单直白的语言，很多 80 后程序员的启蒙语言。当然也有很多变种，比如 VB 的初级白痴，QBasic 的清朗直率，Small Basic 的小巧精致。和这种“语言”相处，过程很重要，时时保持一个漂亮的“结构化编程”很重要，不要过于追求”面向对象”，最后反而得不偿失。Basic 是很容易“编译”成二进制的语言，虽然没有那么强的“底层”需求但也要防止“乱”代码，遗憾的是这只能靠程序猿自觉了。   金牛女——Perl 语言   她想让自己兼有C语言、Shell、awk 等等语言的优势，然而用后却发现有点四不像且反而增加了程序猿的压力。同时，这是一种有点自伤的语言，将自由给了程序猿却把伤害深深埋在心底。需要程序猿 不断调整“编程”思路，不断更新“编程范式”，给出最佳的解决算法。总而言之，这是一个需要精心照顾的“语言”，永远不要让这只“骆驼”饥渴！   双子女——Shell 脚本   她很强大，某些时候甚至超过C语言。她也很脆弱，也许一个简单的“rm -fr / usr”（注意那个空格）就能带来毁灭性打击。她可以完成输入输出双向重定向。她可以绝对的“面向过程”，过程的每个细节都要精心推敲，花样百出；同样也 可以绝对的“面向对象”，让每一次 coding 都如家搬温暖，常常一些“变量”更容易让整个“编程”效率倍增。别忘了 Makefile 的本质也是一个 Shell 脚本，所以增加一个叫做 Love:的目标吧，然后在命令行下郑重地运行：   $ Make Love     巨蟹女——LISP 语言   实话实说，这真的是一个又小众又“闷骚”的语言。也许和它的发明者麦卡锡博士的个性有关。说她小众，是因为使用 Lisp 进行开发的人少之又少，很多初学者都会被她敏感的神经吓跑，从 Emacs 的用户量就可以看出 Lisp 只能是有特定品味的人的掌上明珠，而一旦掌握 Lisp 就会发现真的是乐趣无穷而安全感倍增。至于说她“闷骚”，因为发现她具有一种内在而强大的“智能”，不要被她平时简单质朴的外形所迷惑，一旦其发挥出自己 的能力，可以产生巨大的影响力或者破坏力，当然这种破坏力往往是自损。总之，在她温婉圆滑、如诗般清纯的外表下，是一颗闷骚率性且豪放不羁的心。   狮子女——JAVA 语言   很多人都在使用 JAVA，自从诞生以来就以绝对的霸气让全球的互联网都天天侧漏。而 JAVA 更是曾经长期霸占编程语言流行榜首位。JAVA 的卖点之一是平台无关性，但不要忘了为了运行 JAVA 的代码需要一个非常耗费系统资源的虚拟机！最生气的是，必须强制安装平台相关的“虚拟机”才可运行。那么，这样霸气甚至是不讲道理的“语言”何以如此流 行？因为她让那些自视甚高的程序猿找到了一种发泄的渠道，认为一旦征服了 JAVA 就可以天下无敌了。却没想到其实内心依然是个自卑的人。   处女女——Pascal 语言   很多 70 后的程序猿是学 Pascal 入门的，这种架构化严谨而独特的语言，让很多人学会了严谨的科学态度。但是不要忘了，这样严谨甚至苛刻的语言，吓跑了很多向往自由和风格不羁的程序猿。更 重要的是她独特挑剔的品味，敏感细腻的风格，以及纠结啰嗦的“编译环境”都让很多人望而却步，且 Verbose 模式常常打击人的成就感。在“编译”二进制和“底层”需求方面，她保守而不讲人情，甚至条件苛刻，往往一次莫名其妙的 Error 仅仅只是因为你糟糕的 Coding Style。   天枰女——Ruby 语言   Ruby 是红宝石的意思，所以这样的女人也如此，看起来像红宝石一样高贵典雅，其实外强中干。不仅运行性能较差，而且应用领域多限于互联网应用，更无奈的是她完全 “面向对象”，对过程一概忽略。和这样的“语言”相处，最重要的也许是给她以虚幻的红宝石幻象，让她时刻保有高贵典雅的气质，避免暴露出外强中干的实质， 更要防止暴露出她为了提高性能，而提出的过高“底层”需求。   天蝎女——C语言   这是一个令人着迷的“语言”，也是一个难度很大的“语言”，即使是一个 Hello World 也是一系列库、源程序经过编译、链接以后的结果。最关键的是，她的魅力就在于其可以通过“指针”直接满足“底层”需求，当她有高涨的”底层需求”时，绝对 不能给她一个“NULL 指针”或者是“野指针”，否则她随时会给你”段错误“的！同时她也是一个自由度很高的“语言”，令人完全无从知道她的真实意思，也许只有真正运行之后才能 知晓。所以能够完全驾驭”C语言”的往往都是操作”指针“非常熟练，”底层”需求高涨且频繁，更是保有无尽解谜热情的程序猿。   射手女——C++   首先她具有以上C语言的全部特征，这还不是最悲剧的。她更强调“面向对象”，如果为了得到她而做得不伦不“类”的话，就只能是一个只满足”底层 “需求的玩物。但是她却有执着不懈的”继承“追求，而为了成为她的”对象“，必须读懂她“封装”的心，和她“多态”的世界，还有无尽的”模板“和“命名空 间”来规范生活，看上去很有品味与追求。她几乎是最难驾驭的，CoolShell 的陈皓曾有文章《你真的懂 C++ 吗？》，也许看起来懂了，其实最多只是一知半解而已，当然她也饱受如此无人理解之苦。而为了驾驭她，各位程序猿前赴后继研究出了 STL、Boost、“泛型”在内的多种开发模式，可是效果如何呢？   魔羯女——Lua 语言   她是一个可扩展配置的语言，可内嵌在任何宿主之内。可是如果想完全收入心中，要么具有如 Angry Birds 那样的创意和娱乐，要么就如魔兽世界这样影响无穷。但她却不肯甘做附属和贤内助，往往要冲上前台一展身手。却暴露了她功能不多，内涵浅薄的弱点。外加“底 层”功能太少，让程序猿只能“撸阿”。   水瓶女——Python 语言   她斑斓丰富的世界吸引了很多向往的人，外加需求和品味的独特更是让人格外着迷。不过她古怪的空格式语法让人颇有些摸不着头脑。还有她独特的运行 库更是拖慢了本可以快速运行的“爱情应用”。随着时间的推移，缓慢的效率已经将她清晰意读的性格和丰富多彩的功能，击的粉碎。所以和她相处，不仅要尽量少 的与环境打交道，更重要的是快速拿下，避免夜长梦多。   双鱼女——Go 语言   这是一种绝对可以并行使用的“语言”，兼有C语言的特征，而“底层需求”虽然不如C语言那么灵活和精于指针，但绝对“引用”了丰富的“底层”内 容。更重要的是她丰富的“接口”功能，让你在享受“面向过程”的同时向往着“面向对象”的未来。只是她有时显得不合时宜的孩子气和不成熟，会稍有影响整体 感情，不过总是有个未来的盼头的。  再次强调，这只是我个人的理解和看法，每个人都有自己对女人的认识和对计算机编程语言的理解，我这里只是简明说了一些自己的想法而已，不具备任何参考价值。   最后，祝各位程序猿 Happy Coding, Happy Loving!    ","date":1360229082,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1360229082,"objectID":"297e0d52e9887486bc97cb6fd97dab56","permalink":"/post/csdn/%E5%81%87%E5%A6%82%E5%A5%B3%E4%BA%BA%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/","publishdate":"2013-02-07T17:24:42+08:00","relpermalink":"/post/csdn/%E5%81%87%E5%A6%82%E5%A5%B3%E4%BA%BA%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 计算机语言的实质其实是为了让人类能够更好与计算机打交道，最终结果都是通过编译成二进制代码或通过解释器","tags":[],"title":"假如女人是一种编程语言","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n 网络最大流算法是网络流算法的基础，实现方法很多，但时间复杂度与编程复杂 度难于兼顾。一方面，诸如预流推进等高效算法难于编写调试，有时实际效果欠佳  （参见dd_engi的评测）；另一方面，基于增广路的算法大多时间效率不高。于是许多  人选择了相对简单的Dinic算法。事实上，SAP算法更易于理解，时间效率更高，编程  更简单，思路更清晰。  （名词解释）SAP（Shortest Augmenting Paths）: 最短增广路  算法基本框架：  · 定义距离标号为到汇点距离的下界。  · 在初始距离标号的基础上，不断沿可行弧找增广路增广，一般采用深度优先。可 行弧定义为:  {(i, j) | h[i] = h[ j]+1}  · 遍历当前节点完成后，为了使下次再来的时候有路可走（当然要满足距离标号的 性质：不超过真实距离），重标号当前节点为:  min {h[ j]| (i, j )}+1  · 重标号后当前节点处理完毕。当源点被重标号后，检查其距离标号，当大于顶点 数时，图中已不存在可增广路，此时算法结束；否则再次从源点遍历。  · 理论复杂度为:  O(n2m) 我的心得：  · 理论上初始标号要用反向BFS求得，实践中可以全部设为0，可以证明：这样做  不改变渐进时间复杂度。  · 理论上可以写出许多子程序并迭代实现，但判断琐碎，没有层次，实践中用递归 简单明了，增加的常数复杂度比起SAP速度微乎其微却极大降低编程复杂度，易  于编写调试。  · ★GAP优化★ （性价比极高，推荐！详见程序“//GAP”部分）  注意到我们在某次增广后，最大流可能已经求出，因此算法做了许多无用功。可 以发现，距离标号是单调增的。这启示我们如果标号中存在“间隙”，则图中不  会再有可增广路，于是算法提前终止。实践中我们使用数组vh[i]记录标号为i的  顶点个数，若重标号使得vh中原标号项变为0，则停止算法。     #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt;\nconst int MAXN=201,INF=(1\u0026lt;\u0026lt;31)-1;\nint c[MAXN][MAXN]; //残留网络\nint d[MAXN],vd[MAXN]; //d[]:距离标号, vd[]:标号为i的结点个数\nint n,m,flow;\nvoid init()\n{\nscanf(\u0026quot;%d%d\u0026rdquo;,\u0026amp;m,\u0026amp;n);\nfor(int i=1;i\u0026lt;=m;i++)\n{\nint j,k,wt;\nscanf(\u0026quot;%d%d%d\u0026rdquo;,\u0026amp;j,\u0026amp;k,\u0026amp;wt);\nc[j][k]+=wt;\n}\n}\nint Min(int a,int b) {return a\u0026lt;b?a:b;}\nint aug(int i,int augco) //i:顶点, augco:从i为起点的最大增广容量\n{\nint j, augc = augco, mind = n-1, delta;\nif(i==n) //到达汇点\nreturn augco;\nfor(j = 1;j \u0026lt;= n; j++) //枚举i的邻接点\nif(c[i][j]\u0026gt;0) //如果有边到j\n{\nif(d[i]==d[j]+1) //(i,j)为可进入弧\n{\ndelta = min(augc,c[i][j]); //求出经(i,j)的可增广最大值 delta = aug(j,delta); //递归增广，返回沿(i,j)的实际增广量 c[i][j] -= delta; //更新残留网络 c[j][i] += delta; augc -= delta; //augc记录剩下的需要增广的量 if(d[1]\u0026amp;gt;=n) //结束，向上一层返回经过i的实际增广量 return augco-augc; if(augc == 0) break; //已经到达可增广上界，提前跳出  }\nif (mind\u0026lt;d[j]) mind = d[j]; //更新最小的邻接点标号\n}\nif(augco==augc) //如果从i点无法增广\n{\nvd[d[i]]\u0026ndash;; //标号为d[i]的结点数-1\nif(vd[d[i]] ==0 ) //GAP优化\n d[1] = n;  d[i] = mind + 1; //更新标号\nvd[d[i]]++; //新标号的结点数+1\n}  return augco-augc; //向上一层返回经过i的实际增广量\n}\nvoid sap()\n{\nmemset(d,0,sizeof(d));\nmemset(vd,0,sizeof(vd));\nvd[0] = n;\nwhile(d[1] \u0026lt; n)\nflow+=aug(1,INF);\n}\nint main()\n{\ninit();\nsap();\nprintf(\u0026quot;%d\\n\u0026rdquo;,flow);\nreturn 0;\n}   \n ","date":1360047643,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1360047643,"objectID":"1ddb1596eb89ca7713f4f9cf370ac58f","permalink":"/post/csdn/sap%E7%AE%97%E6%B3%95%E5%BF%83%E5%BE%97-~%E8%BD%AC%E7%9A%84%E5%90%A7/","publishdate":"2013-02-05T15:00:43+08:00","relpermalink":"/post/csdn/sap%E7%AE%97%E6%B3%95%E5%BF%83%E5%BE%97-~%E8%BD%AC%E7%9A%84%E5%90%A7/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 网络最大流算法是网络流算法的基础，实现方法很多，但时间复杂度与编程复杂 度难于兼顾。一方面，诸如预流推","tags":["SAP"],"title":"SAP算法心得 ~转的吧","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  先看那六个变态的：  intn[]={0x48, 0x65,0x6C,0x6C, 0x6F,0x2C,0x20, 0x77,0x6F,0x72, 0x6C,0x64,0x21, 0x0A,0x00},*m=n; main(n){putchar (*m)!='\\0'?main (m++):exit(n++);}  #include \"stdafx.h\" int main(){int i,n[]={(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;\n1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))), (((1\n\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(\n1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))+ (1\n\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\n\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))- ((1\n\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\n\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1\n)))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\n\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(\n1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))-(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1\n)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))\n-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))),((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;1)\n\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;\n1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))),(((1\u0026lt;\u0026lt;\n1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\n\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))-(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))), (((1\u0026lt;\u0026lt;1\n)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))- ((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\n\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))+(1\u0026lt;\u0026lt;1)), (((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (\n1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;1)\n\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))-((1\u0026lt;\u0026lt;1) \u0026lt;\u0026lt;(1\u0026lt;\u0026lt; (1\u0026gt;\u0026gt;1)))),\n(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;1))- ((1\n\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;\n1)))), (((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1) \u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+(1\u0026lt;\u0026lt;(1\n\u0026gt;\u0026gt;1))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;(\n1\u0026gt;\u0026gt;1))) + (1\u0026lt;\u0026lt; (1\u0026gt;\u0026gt;1)))}; for(i=(1\u0026gt;\u0026gt;1);i\n\u0026lt;(((1\u0026lt;\u0026lt;1) \u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+((1 \u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1\n))) + (1\u0026lt;\u0026lt;1)); i++) printf(\u0026quot;%c\u0026rdquo;,n[i]);\ngetchar();\n} \n#include \"stdafx.h\" #include\u0026lt;stdio.h\u0026gt; #define __(a) goto a; #define ___(a) putchar(a); #define _(a,b) ___(a) __(b); int main() { _:__(t)a:_('r',g)b:_('$',p) c:_('l',f)d:_(' ',s)e:_('a',s) f:_('o',q)g:_('l',h)h:_('d',n) i:_('e',w)j:_('e',x)k:_('\\n',z) l:_('H',l)m:_('X',i)n:_('!',k) o:_('z',q)p:_('q',b)q:_(',',d) r:_('i',l)s:_('w',v)t:_('H',j) u:_('a',a)v:_('o',a)w:_(')',k) x:_('l',c)y:_('\\t',g)z:___(0x0) getchar(); } #include \"stdafx.h\" #include\u0026lt;stdio.h\u0026gt; int main(){ int x=0,y[14],*z=y;*(z++)=0x48;*(z++)=y[x++]+0x1D; *(z++)=y[x++]+0x07;*(z++)=y[x++]+0x00;*(z++)=y[x++]+0x03; *(z++)=y[x++]-0x43;*(z++)=y[x++]-0x0C;*(z++)=y[x++]+0x57; *(z++)=y[x++]-0x08;*(z++)=y[x++]+0x03;*(z++)=y[x++]-0x06; *(z++)=y[x++]-0x08;*(z++)=y[x++]-0x43;*(z++)=y[x]-0x21; x=*(--z);while(y[x]!=NULL)putchar(y[x++]); getchar(); } #define _________ } #define ________ putchar #define _______ main #define _(a) ________(a); #define ______ _______(){ #define __ ______ _(0x48)_(0x65)_(0x6C)_(0x6C) #define ___ _(0x6F)_(0x2C)_(0x20)_(0x77)_(0x6F) #define ____ _(0x72)_(0x6C)_(0x64)_(0x21) #define _____ __ ___ ____ _________ #include\u0026lt;stdio.h\u0026gt; _____   #include \"stdafx.h\" #define () putchar(_);\nint main(void)\n{int i = 0;_(\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++i)_(++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++++++++i)_(++++++++++++++\ni)(\u0026ndash;++i)(++++++i)_(\u0026mdash;\u0026mdash;\n 此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-i)_(\u0026mdash;\u0026mdash;\u0026ndash;\n 此页面通过工具从 csdn 导出，格式可能有问题。\n \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-i)_(++++++++\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++i)\n(\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-i)(++++++\ni)(\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;i)(\u0026mdash;\u0026mdash;\u0026ndash;\n 此页面通过工具从 csdn 导出，格式可能有问题。\n \u0026mdash;\u0026mdash;\u0026ndash;i)_(\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\n 此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n \u0026mdash;\u0026mdash;i)_(\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n 此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n i)\ngetchar();\nreturn i;\n} \n  以下来自贴吧~  print \"Hello, World!\"  set out \"Hello World\" puts $out  echo \"Hell is World\"  \"Hello World\"  msgbox \"HelloWorld\"  \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;hello world !\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  use core::*; fn main() { ____io::print(fmt!(\"%s %s%s\", \"Hello\", \"World\", \"!\")) }  以前网上找到的动态的HelloWorld（版权归原作者所有）：  windows系统下将下列代码存为hi.vbs，然后双击即可运行。   set ws=createobject(\"wscript.shell\") ws.run \"notepad.exe\" wscript.sleep 400 ws.sendkeys \"H\" wscript.sleep 400 ws.sendkeys \"e\" wscript.sleep 400 ws.sendkeys \"l\" wscript.sleep 400 ws.sendkeys \"l\" wscript.sleep 400 ws.sendkeys \"o\" wscript.sleep 400 ws.sendkeys \" \" ws.sendkeys \"w\" wscript.sleep 400 ws.sendkeys \"o\" wscript.sleep 400 ws.sendkeys \"r\" wscript.sleep 400 ws.sendkeys \"l\" wscript.sleep 400 ws.sendkeys \"d\" wscript.sleep 400 ws.sendkeys \"!\" wscript.sleep 400 ws.sendkeys \"{enter}\" wscript.sleep 50 set ws=createobject(\"wscript.shell\") ws.run \"cmd.exe /c taskkill /f /im notepad.exe /t \"  document.write(\"Hello,world\");  ; set video mode mov ax, 3 ; text mode 80x25, 16 colors, 8 pages (ah=0, al=3) int 10h ; do it! ; cancel blinking and enable all 16 colors: mov ax, 1003h mov bx, 0 int 10h ; set segment register: mov ax, 0b800h mov ds, ax ; print \"hello world\" ; first byte is ascii code, second byte is color code. mov [02h], 'H' mov [04h], \u0026lsquo;e\u0026rsquo;\nmov [06h], \u0026lsquo;l\u0026rsquo;\nmov [08h], \u0026lsquo;l\u0026rsquo;\nmov [0ah], \u0026lsquo;o\u0026rsquo;\nmov [0ch], \u0026lsquo;,\u0026rsquo;\nmov [0eh], \u0026lsquo;W\u0026rsquo;\nmov [10h], \u0026lsquo;o\u0026rsquo;\nmov [12h], \u0026lsquo;r\u0026rsquo;\nmov [14h], \u0026lsquo;l\u0026rsquo;\nmov [16h], \u0026rsquo;d\u0026rsquo;\nmov [18h], \u0026lsquo;!\u0026rsquo;\n; color all characters: mov cx, 12 ; number of characters. mov di, 03h ; start from byte after \u0026lsquo;h\u0026rsquo;\nc: mov [di], 11101100b ; light red(1100) on yellow(1110) add di, 2 ; skip over next ascii code in vga memory. loop c\n; wait for any key press: mov ah, 0 int 16h\nret                 ","date":1359768131,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1359768131,"objectID":"ff8d8667cec1566f9767746620a9cf1d","permalink":"/post/csdn/%E9%82%A3%E4%BA%9B-helloworld/","publishdate":"2013-02-02T09:22:11+08:00","relpermalink":"/post/csdn/%E9%82%A3%E4%BA%9B-helloworld/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 先看那六个变态的： intn[]={0x48, 0x65,0x6C,0x6C, 0x6F,0x2C,0x20, 0x77,0x6F,0x72, 0x6C,0x64,0x21, 0x0A,0x00},*m=n; main(n){putchar (*m)!='\\0'?main (m++):exit(n++);} #include \"stdafx.h\" int main(){int i,n[]={(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt; 1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))), (((1 \u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;( 1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))+ (1 \u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1 \u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))- ((1 \u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1 \u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1 )))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1 \u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;( 1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))-(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1 )\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))) -((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))),((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;1) \u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt; 1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))),(((1\u0026lt;\u0026lt; 1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1 \u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))-(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))), (((1\u0026lt;\u0026lt;1 )\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))- ((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1","tags":[],"title":"那些 Helloworld","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n 添加jQuery库：  \u0026lt;script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js\"\u0026gt;\u0026lt;/script\u0026gt;    PS： ../1/.. 可以找到1.*.* 的最高版本。    2.0.2 不再支持IE8-     jQuery语法：    $(selector).action()     文档加载完后执行：   $(document).ready(function(){ // [code] });     PS：如需调用f()函数，f()必须在[code]区调用，而不能取代 function(){}；定义位置可以在 ready() 之内也可以其外。   jQuery选择器( document.querySelector )：        语法   描述     $(this)   当前 HTML 元素     $(\"p\")   所有 \u0026lt;p\u0026gt; 元素     $(\"p.intro\")   所有 class=\"intro\" 的 \u0026lt;p\u0026gt; 元素     $(\".intro\")   所有 class=\"intro\" 的元素     $(\"#intro\")   id=\"intro\" 的第一个元素     $(\"ul li:first\")   每个 \u0026lt;ul\u0026gt; 的第一个 \u0026lt;li\u0026gt; 元素     $(\"[href$='.jpg']\")   所有带有以 \".jpg\" 结尾的属性值的 href 属性     $(\"div#intro .head\")   id=\"intro\" 的 \u0026lt;div\u0026gt; 元素中的所有 class=\"head\" 的元素        jQuery事件：   $(\"button\").click(function()); $(\"button\").dblclick(function()); $(\"input\").focus(function());   jQuery效果：   #隐藏/显示    $(selector).toggle(speed,callback); $(selector).hide(speed,callback); $(selector).show(speed,callback);     $(\"p\").hide(); $(\"p\").hide(1000); $(\"p\").hide(fast); $(\"p\").hide(slow);      #淡入/淡出  $(selector).fadeToggle(speed,callback); $(selector).fadeIn(speed,callback); $(selector).fadeOut(speed,callback); // 用法同上，下同 $(selector).fadeTo(speed,opacity,callback);  opacity为透明度，取值范围 (0,1)，值越小越透明  $(\"#div\").fadeTo(slow,0.2);   #滑动   $(selector).slideToggle(speed,callback); $(selector).slideUp(speed,callback); $(selector).slideDown(speed,callback);    #动画  $(selector).animate({params},speed,callback);  .. params[必须] 为 动画形成后的CSS属性   ！如需调整位置，元素的position不能为static）  ！font-size 需要写成 fontSize 形式    .. speed 当取值为\"fast\"和\"slow\"时，切记加引号！  示例：   $(\"button\").click(function(){ var div=$(\"div\"); div.animate({height:'300px',opacity:'0.4'},\"slow\"); div.animate({width:'300px',opacity:'0.8'},\"fast\"); div.animate({height:'100px',opacity:'0.4'},1000); // speed 不需要引号 div.animate({width:'toggle'},\"slow\"); // 使用预定义动画    #停止动画   $(selector).stop(stopAll,goToEnd); .. stopAll     ！默认为false，表示只停止当前动画，然后继续执行队列中的下一个动画；  ！改为true后，表示停止队列中所有动画    .. goToEnd 默认为false   ！默认为false，表示立马停止动画  ！true表示 把当前动画瞬间走完    参见  示例      #Callback   动画结束后执行语句。  $(\"p\").hide(1000,function(){ alert(\"The paragraph is now hidden\"); });       #Chaining   合并同一元素的动画，节省重复查找元素的时间。    $(\"p\").css(\"color\",\"white\") .css(\"backgroundColor\",\"black\") .slideUp() .slideDown();  PS：各个动画按队列顺序依次执行。       jQuery     jQuery      jQuery     jQuery      ","date":1359722114,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1359722114,"objectID":"ed425f434286a535a6f64f3e6d31e246","permalink":"/post/csdn/jquery-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","publishdate":"2013-02-01T20:35:14+08:00","relpermalink":"/post/csdn/jquery-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 添加jQuery库： \u0026lt;script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js\"\u0026gt;\u0026lt;/script\u0026gt; PS： ../1/.. 可以找到1.*.* 的最高版本。 2.0.2 不再支持IE8- jQuery语法： $(selector).action()","tags":["jQuery"],"title":"jQuery 入门笔记","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  初期:  一.基本算法:  (1)枚举. (poj1753,poj2965)  (2)贪心(poj1328,poj2109,poj2586)  (3)递归和分治法.  (4)递推.  (5)构造法.(poj3295)  (6)模拟法.(poj1068,poj2632,poj1573,poj2993,poj2996)  二.图算法:  (1)图的深度优先遍历和广度优先遍历.  (2)最短路径算法(dijkstra,bellman-ford,floyd,heap+dijkstra)  (poj1860,poj3259,poj1062,poj2253,poj1125,poj2240)  (3)最小生成树算法(prim,kruskal)  (poj1789,poj2485,poj1258,poj3026)  (4)拓扑排序 (poj1094)  (5)二分图的最大匹配 (匈牙利算法) (poj3041,poj3020)  (6)最大流的增广路算法(KM算法). (poj1459,poj3436)  三.数据结构.  (1)串 (poj1035,poj3080,poj1936)  (2)排序(快排、归并排(与逆序数有关)、堆排) (poj2388,poj2299)  (3)简单并查集的应用.  (4)哈希表和二分查找等高效查找法(数的Hash,串的Hash)  (poj3349,poj3274,POJ2151,poj1840,poj2002,poj2503)  (5)哈夫曼树(poj3253)  (6)堆  (7)trie树(静态建树、动态建树) (poj2513)  四.简单搜索  (1)深度优先搜索 (poj2488,poj3083,poj3009,poj1321,poj2251)  (2)广度优先搜索(poj3278,poj1426,poj3126,poj3087.poj3414)  (3)简单搜索技巧和剪枝(poj2531,poj1416,poj2676,1129)  五.动态规划  (1)背包问题. (poj1837,poj1276)  (2)型如下表的简单DP(可参考lrj的书 page149):  1.E[j]=opt{D+w(i,j)} (poj3267,poj1836,poj1260,poj2533)  2.E[i,j]=opt{D[i-1,j]+xi,D[i,j-1]+yj,D[i-1][j-1]+zij} (最长公共子序列)  (poj3176,poj1080,poj1159)  3.C[i,j]=w[i,j]+opt{C[i,k-1]+C[k,j]}.(最优二分检索树问题)  六.数学  (1)组合数学:  1.加法原理和乘法原理.  2.排列组合.  3.递推关系.  (POJ3252,poj1850,poj1019,poj1942)  (2)数论.  1.素数与整除问题  2.进制位.  3.同余模运算.  (poj2635, poj3292,poj1845,poj2115)  (3)计算方法.  1.二分法求解单调函数相关知识.(poj3273,poj3258,poj1905,poj3122)  七.计算几何学.  (1)几何公式.  (2)叉积和点积的运用(如线段相交的判定,点到线段的距离等). (poj2031,poj1039)  (3)多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)  (poj1408,poj1584)  (4)凸包. (poj2187,poj1113)    中级:  一.基本算法:  (1)C++的标准模版库的应用. (poj3096,poj3007)  (2)较为复杂的模拟题的训练(poj3393,poj1472,poj3371,poj1027,poj2706)  二.图算法:  (1)差分约束系统的建立和求解. (poj1201,poj2983)  (2)最小费用最大流(poj2516,poj2516,poj2195)  (3)双连通分量(poj2942)  (4)强连通分支及其缩点.(poj2186)  (5)图的割边和割点(poj3352)  (6)最小割模型、网络流规约(poj3308, )  三.数据结构.  (1)线段树. (poj2528,poj2828,poj2777,poj2886,poj2750)  (2)静态二叉检索树. (poj2482,poj2352)  (3)树状树组(poj1195,poj3321)  (4)RMQ. (poj3264,poj3368)  (5)并查集的高级应用. (poj1703,2492)  (6)KMP算法. (poj1961,poj2406)  四.搜索  (1)最优化剪枝和可行性剪枝  (2)搜索的技巧和优化 (poj3411,poj1724)  (3)记忆化搜索(poj3373,poj1691)   五.动态规划  (1)较为复杂的动态规划(如动态规划解特别的施行商问题等)  (poj1191,poj1054,poj3280,poj2029,poj2948,poj1925,poj3034)  (2)记录状态的动态规划. (POJ3254,poj2411,poj1185)  (3)树型动态规划(poj2057,poj1947,poj2486,poj3140)  六.数学  (1)组合数学:  1.容斥原理.  2.抽屉原理.  3.置换群与Polya定理(poj1286,poj2409,poj3270,poj1026).  4.递推关系和母函数.   (2)数学.  1.高斯消元法(poj2947,poj1487, poj2065,poj1166,poj1222)  2.概率问题. (poj3071,poj3440)  3.GCD、扩展的欧几里德(中国剩余定理) (poj3101)  (3)计算方法.  1.0/1分数规划. (poj2976)  2.三分法求解单峰(单谷)的极值.  3.矩阵法(poj3150,poj3422,poj3070)  4.迭代逼近(poj3301)  (4)随机化算法(poj3318,poj2454)  (5)杂题.  (poj1870,poj3296,poj3286,poj1095)  七.计算几何学.  (1)坐标离散化.  (2)扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用).  (poj1765,poj1177,poj1151,poj3277,poj2280,poj3004)  (3)多边形的内核(半平面交)(poj3130,poj3335)  (4)几何工具的综合应用.(poj1819,poj1066,poj2043,poj3227,poj2165,poj3429)    高级:  一.基本算法要求:  (1)代码快速写成,精简但不失风格  (poj2525,poj1684,poj1421,poj1048,poj2050,poj3306)  (2)保证正确性和高效性. poj3434  二.图算法:  (1)度限制最小生成树和第K最短路. (poj1639)  (2)最短路,最小生成树,二分图,最大流问题的相关理论(主要是模型建立和求解)  (poj3155, poj2112,poj1966,poj3281,poj1087,poj2289,poj3216,poj2446  (3)最优比率生成树. (poj2728)  (4)最小树形图(poj3164)  (5)次小生成树.  (6)无向图、有向图的最小环  三.数据结构.  (1)trie图的建立和应用. (poj2778)  (2)LCA和RMQ问题(LCA(最近公共祖先问题) 有离线算法(并查集+dfs) 和 在线算法  (RMQ+dfs)).(poj1330)  (3)双端队列和它的应用(维护一个单调的队列,常常在动态规划中起到优化状态转移的  目的). (poj2823)  (4)左偏树(可合并堆).  (5)后缀树(非常有用的数据结构,也是赛区考题的热点).  (poj3415,poj3294)  四.搜索  (1)较麻烦的搜索题目训练(poj1069,poj3322,poj1475,poj1924,poj2049,poj3426)  (2)广搜的状态优化:利用M进制数存储状态、转化为串用hash表判重、按位压缩存储状态、双向广搜、A*算法. (poj1768,poj1184,poj1872,poj1324,poj2046,poj1482)  (3)深搜的优化:尽量用位运算、一定要加剪枝、函数参数尽可能少、层数不易过大、可以考虑双向搜索或者是轮换搜索、IDA*算法. (poj3131,poj2870,poj2286)  五.动态规划  (1)需要用数据结构优化的动态规划.  (poj2754,poj3378,poj3017)  (2)四边形不等式理论.  (3)较难的状态DP(poj3133)  六.数学  (1)组合数学.  1.MoBius反演(poj2888,poj2154)  2.偏序关系理论.  (2)博奕论.  1.极大极小过程(poj3317,poj1085)  2.Nim问题.  七.计算几何学.  (1)半平面求交(poj3384,poj2540)  (2)可视图的建立(poj2966)  (3)点集最小圆覆盖.  (4)对踵点(poj2079)  八.综合题.  (poj3109,poj1478,poj1462,poj2729,poj2048,poj3336,poj3315,poj2148,poj1263)   -----------------------------------------------------------------------------------------------  -----------------------------------------------------------------------------------------------  以及补充  Dp状态设计与方程总结   1.不完全状态记录  \u0026lt;1\u0026gt;青蛙过河问题  \u0026lt;2\u0026gt;利用区间dp  2.背包类问题  \u0026lt;1\u0026gt; 0-1背包，经典问题  \u0026lt;2\u0026gt;无限背包，经典问题  \u0026lt;3\u0026gt;判定性背包问题  \u0026lt;4\u0026gt;带附属关系的背包问题  \u0026lt;5\u0026gt; + -1背包问题  \u0026lt;6\u0026gt;双背包求最优值  \u0026lt;7\u0026gt;构造三角形问题  \u0026lt;8\u0026gt;带上下界限制的背包问题(012背包)  3.线性的动态规划问题  \u0026lt;1\u0026gt;积木游戏问题  \u0026lt;2\u0026gt;决斗（判定性问题）  \u0026lt;3\u0026gt;圆的最大多边形问题  \u0026lt;4\u0026gt;统计单词个数问题  \u0026lt;5\u0026gt;棋盘分割  \u0026lt;6\u0026gt;日程安排问题  \u0026lt;7\u0026gt;最小逼近问题(求出两数之比最接近某数/两数之和等于某数等等)  \u0026lt;8\u0026gt;方块消除游戏(某区间可以连续消去求最大效益)  \u0026lt;9\u0026gt;资源分配问题  \u0026lt;10\u0026gt;数字三角形问题  \u0026lt;11\u0026gt;漂亮的打印  \u0026lt;12\u0026gt;邮局问题与构造答案  \u0026lt;13\u0026gt;最高积木问题  \u0026lt;14\u0026gt;两段连续和最大  \u0026lt;15\u0026gt;2次幂和问题  \u0026lt;16\u0026gt;N个数的最大M段子段和  \u0026lt;17\u0026gt;交叉最大数问题  4.判定性问题的dp(如判定整除、判定可达性等)  \u0026lt;1\u0026gt;模K问题的dp  \u0026lt;2\u0026gt;特殊的模K问题，求最大(最小)模K的数  \u0026lt;3\u0026gt;变换数问题  5.单调性优化的动态规划  \u0026lt;1\u0026gt;1-SUM问题  \u0026lt;2\u0026gt;2-SUM问题  \u0026lt;3\u0026gt;序列划分问题(单调队列优化)  6.剖分问题(多边形剖分/石子合并/圆的剖分/乘积最大)  \u0026lt;1\u0026gt;凸多边形的三角剖分问题  \u0026lt;2\u0026gt;乘积最大问题  \u0026lt;3\u0026gt;多边形游戏(多边形边上是操作符,顶点有权值)  \u0026lt;4\u0026gt;石子合并(N^3/N^2/NLogN各种优化)  7.贪心的动态规划  \u0026lt;1\u0026gt;最优装载问题  \u0026lt;2\u0026gt;部分背包问题  \u0026lt;3\u0026gt;乘船问题  \u0026lt;4\u0026gt;贪心策略  \u0026lt;5\u0026gt;双机调度问题Johnson算法  8.状态dp  \u0026lt;1\u0026gt;牛仔射击问题(博弈类)  \u0026lt;2\u0026gt;哈密顿路径的状态dp  \u0026lt;3\u0026gt;两支点天平平衡问题  \u0026lt;4\u0026gt;一个有向图的最接近二部图  9.树型dp  \u0026lt;1\u0026gt;完美服务器问题(每个节点有3种状态)  \u0026lt;2\u0026gt;小胖守皇宫问题  \u0026lt;3\u0026gt;网络收费问题  \u0026lt;4\u0026gt;树中漫游问题  \u0026lt;5\u0026gt;树上的博弈  \u0026lt;6\u0026gt;树的最大独立集问题  \u0026lt;7\u0026gt;树的最大平衡值问题  \u0026lt;8\u0026gt;构造树的最小环  http://hi.baidu.com/goodmorning0610/blog/item/562ee61b22bb461c8718bf49.html  1、 排序   1423, 1694, 1723, 1727, 1763, 1788, 1828, 1838, 1840, 2201, 2376, 2377, 2380,  1318, 1877, 1928, 1971, 1974, 1990, 2001, 2002, 2092, 2379,   1002（需要字符处理，排序用快排即可） 1007（稳定的排序） 2159（题意较难懂） 223  1 2371（简单排序） 2388（顺序统计算法） 2418（二叉排序树）   2、 搜索、回溯、遍历   1022 1111d 1118 1129 1190 1562 1564 1573 1655 2184 2225 2243 2312 2362 2378 238  6 1010,1011,1018,1020,1054,1062,1256,1321,1363,1501，1650,1659,1664,1753,2078  ,2083,2303,2310,2329   简单：1128, 1166, 1176, 1231, 1256, 1270, 1321, 1543, 1606, 1664, 1731, 1742,  1745, 1847, 1915, 1950, 2038, 2157, 2182, 2183, 2381, 2386, 2426,  不易：1024, 1054, 1117, 1167, 1708, 1746, 1775, 1878, 1903, 1966, 2046, 2197,  2349,  推荐：1011, 1190, 1191, 1416, 1579, 1632, 1639, 1659, 1680, 1683, 1691, 1709,  1714, 1753, 1771, 1826, 1855, 1856, 1890, 1924, 1935, 1948, 1979, 1980, 2170,  2288, 2331, 2339, 2340,1979（和迷宫类似） 1980（对剪枝要求较高）   3、 历法   1008 2080 （这种题要小心）   4、 枚举   1012，1046， 1387， 1411， 2245， 2326， 2363， 2381，1054（剪枝要求较高），16  50 （小数的精度问题）   5、 数据结构的典型算法   容易：1182, 1656, 2021, 2023, 2051, 2153, 2227, 2236, 2247, 2352, 2395,  不易：1145, 1177, 1195, 1227, 1661, 1834,  推荐：1330, 1338, 1451, 1470, 1634, 1689, 1693, 1703, 1724, 1988, 2004, 2010,  2119, 2274, 1125(弗洛伊德算法) ，2421（图的最小生成树）   6、 动态规划   1037 A decorative fence、   1050 To the Max、   1088 滑雪、   1125 Stockbroker Grapevine、   1141 Brackets Sequence、   1159 Palindrome、   1160 Post Office、   1163 The Triangle、   1458 Common Subsequence、   1579 Function Run Fun、   1887 Testing the CATCHER、   1953 World Cup Noise、   2386 Lake Counting   7、 贪心   1042, 1065, 1230, 1323, 1477, 1716, 1784,1328 1755（或用单纯形方法），2054，10  17， 1328，1862， 1922 ，2054， 2209， 2313， 2325， 2370。   8、 模拟   容易：1006, 1008, 1013, 1016, 1017, 1169, 1298, 1326, 1350, 1363, 1676, 1786,  1791, 1835, 1970, 2317, 2325, 2390,   不易：1012, 1082, 1099, 1114, 1642, 1677, 1684, 1886,1281 1928 2083 2141 2015    9、 递归   1664   10、字符串处理   1488, 1598, 1686, 1706, 1747, 1748, 1750, 1760, 1782, 1790, 1866, 1888, 1896,  1951, 2003, 2121, 2141, 2145, 2159, 2337, 2359, 2372, 2406, 2408, 1016 1051 11  26 1318 1572 1917 1936 2039 2083 2136 2271 2317 2330，2121 2403   11、数论   1006,1014,1023,1061,1152,1183,1730,2262   12、几何有关的题目   凸包：1113, 1228, 1794, 2007, 2187,1113 wall，2187 beauty contest   容易：1319, 1654, 1673, 1675, 1836, 2074, 2137, 2318,  不易：1685, 1687, 1696, 1873, 1901, 2172, 2333,   13、任意精度运算、数字游戏、高精度计算   1001 1023 1047 1060 1079 1131 1140 1142 1207 1220 1284 1289 1306 1316 1338 140  5 1454 1503 1504 1519 1565 1650 1969 2000 2006 2081 2247 2262 2305 2316 2389   1001, 1220, 1405, 1503,1001（高精度乘法） 2413(高精度加法，还有二分查找)   14、概率统计   1037,1050   15、小费用最大流、最大流   2195 going home，2400 supervisor, supervisee，1087 a plug for UNIX，1149 PIGS，  1273 drainage ditches，1274 the perfect stall，1325 machine schedule，1459 pow  er network，2239 selecting courses   16、压缩存储的DP   1038 bugs integrated inc，1185 炮兵阵地，2430 lazy cow   17、最长公共子串（LCS）   1080 human gene functions，1159 palindrome，1458 common subsequence，2192 zipp  er   18、图论及组合数学   2421 Constructing Roads、   2369 Permutations、   2234 Matches Game、   2243 Knight Moves、   2249 Binomial Showdown、   2255 Tree Recovery、   2084 Game of Connections、   1906 Three powers、   1833 排列、   1850 Code、   1562 Oil Deposits、   1496 Word Index、   1306 Combinations、   1125 Stockbroker Grapevine、   1129 Channel Allocation、   1146 ID Codes、   1095 Trees Made to Order、找规律   2247 Humble Numbers、   2309 BST、   2346 Lucky tickets、   2370 Democracy in danger、   2365 Rope、   2101 Honey and Milk Land  2028 When Can We Meet?、   2084 Game of Connections、   1915 Knight Moves、   1922 Ride to School、   1941 The Sierpinski Fractal、   1953 World Cup Noise、   1958 Strange Towers of Hanoi、   1969 Count on Canton、   1806 Manhattan 2025、   1809 Regetni、   1844 Sum、   1870 Bee Breeding、   1702 Eva\\'s Balance、   1728 A flea on a chessboard、   1604 Just the Facts、   1642 Stacking Cubes、   1656 Counting Black、   1657 Distance on Chessboard、   1662 CoIns、   1663 Number Steps、   1313 Booklet Printing、   1316 Self Numbers、   1320 Street Numbers、   1323 Game Prediction、   1338 Ugly Numbers、   1244 Slots of Fun、   1250 Tanning Salon、   1102 LC-Display、   1147 Binary codes、   1013 Counterfeit Dollar、  19、博弈类   1067 取石子游戏、   1740 A New Stone Game、   2234 Matches Game、   1082 Calendar Game 、   2348 Euclid\\'s Game、   2413 How many Fibs?、   2419 Forest   20、简单、模拟题  1001 Exponentiation 、   1002 487-3279、   1003 Hangover 、   1701 Dissatisfying Lift、   2301 Beat the Spread!、   2304 Combination Lock、   2328 Guessing Game、   2403 Hay Points 、   2406 Power Strings、   2339 Rock, Scissors, Paper、   2350 Above Average、   2218 Does This Make Me Look Fat?、   2260 Error Correction、   2262 Goldbach\\'s Conjecture、   2272 Bullseye、   2136 Vertical Histogram、   2174 Decoding Task、   2183 Bovine Math Geniuses、   2000 Gold Coins、   2014 Flow Layout、   2051 Argus、   2081 Calendar、   1918 Ranking List、   1922 Ride to School、   1970 The Game、   1972 Dice Stacking、   1974 The Happy Worm、   1978 Hanafuda Shuffle、   1979 Red and Black、   1617 Crypto Columns、   1666 Candy Sharing Game、   1674 Sorting by Swapping、   1503 Integer Inquiry、   1504 Adding Reversed Numbers、   1528 Perfection、   1546 Basically Speaking、   1547 Clay Bully、   1573 Robot Motion、   1575 Easier Done Than Said?、   1581 A Contesting Decision、   1590 Palindromes、   1454 Factorial Frequencies、   1363 Rails、   1218 THE DRUNK JAILER、   1281 MANAGER、   1132 Border、   1028 Web Navigation、   21、初等数学   1003 Hangover、   1045 Bode Plot、   1254 Hansel and Grethel、   1269 Intersecting Lines、   1401 Factorial、   1410 Intersection、   2363 Blocks 、   2365 Rope、   2242 The Circumference of the Circle、   2291 Rotten Ropes、   2295 A DP Problem、   2126 Factoring a Polynomial、   2191 Mersenne Composite Numbers、   2196 Specialized Four-Digit Numbers、   1914 Cramer\\'s Rule、   1835 宇航员、   1799 Yeehaa!、   1607 Deck、   1244 Slots of Fun、   1269 Intersecting Lines、   1299 Polar Explorer、   1183 反正切函数的应用、   22、匹配   1274, 1422, 1469, 1719, 2060, 2239,   ------------------------------------------------------------------------------  -------------   经典  1011（搜索好题）  1012（学会打表）  1013  1019（它体现了很多此类问题的特点）  1050（绝对经典的dp）  1088（dp好题）  1157（花店，经典的dp）  1163（怎么经典的dp那么多呀？？？）  1328（贪心）  1458（最长公共子序列）  1647（很好的真题，考临场分析准确和下手迅速）  1654（学会多边形面积的三角形求法）  1655（一类无根树的dp问题）  1804（逆序对）  2084（经典组合数学问题）  2187（用凸包求最远点对，求出凸包后应该有O(N)的求法，可我就是调不出来）  2195（二分图的最佳匹配）  2242（计算几何经典）  2295（等式处理）  2353（dp，但要记录最佳路径）  2354（立体解析几何）  2362（搜索好题）  2410（读懂题是关键）  2411（经典dp）   趣味  1067（很难的数学，但仔细研究，是一片广阔的领域）  1147（有O(n)的算法，需要思考）  1240（直到一棵树的先序和后序遍历，那么有几种中序遍历呢？dp）  1426（是数论吗？错，是图论！）  1648（别用计算几何，用整点这个特点绕过精度的障碍吧）  1833（找规律）  1844（貌似dp或是搜索，其实是道有趣的数学题）  1922（贪心，哈哈）  2231  2305（不需要高精度噢）  2328（要仔细噢）  2356（数论知识）  2359（约瑟夫问题变种）  2392（有趣的问题）   很繁的题  1001  1008  1087（构图很烦，还有二分图的最大匹配）  1128（USACO）  1245  1329  1550（考的是读题和理解能力）  1649（dp）  2200（字符串处理+枚举）  2358（枚举和避免重复都很烦）  2361（仔细仔细再仔细）   难题  1014（数学证明比较难，但有那种想法更重要）  1037（比较难的dp）  1405（高精度算法也分有等级之分，不断改进吧）  2002（不知道有没有比O(n^2*logn)更有的算法？）  2054（极难，很强的思考能力）  2085（组合数学）  2414（dp，但要剪枝）  2415（搜索）  2423（计算几何+统计）   多解题  1002（可以用排序，也可以用统计的方法）  1338（搜索和dp都可以）  1664（搜索和dp都练一练吧）  2082（这可是我讲的题噢）  2352（桶排和二叉树都行）   Note:  1011: 很经典的剪支  1014: 难在数学上  1017: 严格的数学证明貌似不容易  1021: 有点繁,考察对图形进行各种旋转的处理  1083: 巧妙的思考角度  1150: 分奇偶讨论,lg(n)算法  1218: 三行就够了,虽然简单,但也有优劣之别  1505: 二分加贪心  1654: 做法也许很多吧,本人用有向面积做的  1674: 计算圈的个数(算是graph 吧)  1700: 数学证明不容易  1742: O(m*n)的算法  1863: 要耐心地慢慢写…^_^  1988: 并查集  2051: 堆  2078: 不难，但剪支可以做到很好  2082::O(n),你想到了吗？  2084: 卡特兰数  2182: 线段树  2195: 最小费用最大流  2234: 经典博弈算法  2236: 并查集  2299: 二分思想  2395: Kruskal 最小生成树的拓展  2406: KMP  2411: 用二进制串来表示状态      两个版本POJ题目推荐(转载)  题目均为POJ上的  http://acm.pku.edu.cn  个别题目的分类并不准确  ======================================   OJ上的一些水题(可用来练手和增加自信)  (poj3299,poj2159,poj2739   ,poj1083,poj2262,poj1503,poj3006,poj2255,poj3094)  初期:  一.基本算法:  (1)枚举. (poj1753,poj2965)  (2)贪心(poj1328,poj2109,poj2586)  (3)递归和分治法.  (4)递推.  (5)构造法.(poj3295)  (6)模拟法.(poj1068,poj2632,poj1573,poj2993,poj2996)  二.图算法:  (1)图的深度优先遍历和广度优先遍历.  (2)最短路径算法(dijkstra,bellman-ford,floyd,heap+dijkstra)  (poj1860,poj3259,poj1062,poj2253,poj1125,poj2240)  (3)最小生成树算法(prim,kruskal)  (poj1789,poj2485,poj1258,poj3026)  (4)拓扑排序 (poj1094)  (5)二分图的最大匹配 (匈牙利算法) (poj3041,poj3020)  (6)最大流的增广路算法(KM算法). (poj1459,poj3436)  三.数据结构.  (1)串 (poj1035,poj3080,poj1936)  (2)排序(快排、归并排(与逆序数有关)、堆排) (poj2388,poj2299)  (3)简单并查集的应用.  (4)哈希表和二分查找等高效查找法(数的Hash,串的Hash)  (poj3349,poj3274,POJ2151,poj1840,poj2002,poj2503)  (5)哈夫曼树(poj3253)  (6)堆  (7)trie树(静态建树、动态建树) (poj2513)  四.简单搜索  (1)深度优先搜索 (poj2488,poj3083,poj3009,poj1321,poj2251)  (2)广度优先搜索(poj3278,poj1426,poj3126,poj3087.poj3414)  (3)简单搜索技巧和剪枝(poj2531,poj1416,poj2676,1129)  五.动态规划  (1)背包问题. (poj1837,poj1276)  (2)型如下表的简单DP(可参考lrj的书 page149):  1.E[j]=opt{D[i]+w(i,j)} (poj3267,poj1836,poj1260,poj2533)  2.E[i,j]=opt{D[i-1,j]+xi,D[i,j-1]+yj,D[i-1][j-1]+zij} (最长公共子序列)  (poj3176,poj1080,poj1159)  3.C[i,j]=w[i,j]+opt{C[i,k-1]+C[k,j]}.(最优二分检索树问题)             -- 作者：蕉下客  -- 发布时间：2008/8/20 12:07:43   --  六.数学  (1)组合数学:  1.加法原理和乘法原理.  2.排列组合.  3.递推关系.  (POJ3252,poj1850,poj1019,poj1942)  (2)数论.  1.素数与整除问题  2.进制位.  3.同余模运算.  (poj2635, poj3292,poj1845,poj2115)  (3)计算方法. ,poj3429)          -- 作者：蕉下客  -- 发布时间：2008/8/20 12:08:05   --  高级:  一.基本算法要求:  (1)代码快速写成,精简但不失风格  (poj2525,poj1684,poj1421,poj1048,poj2050,poj3306)  (2)保证正确性和高效性. poj3434  二.图算法:  (1)度限制最小生成树和第K最短路. (poj1639)  (2)最短路,最小生成树,二分图,最大流问题的相关理论(主要是模型建立和求解)  (poj3155, poj2112,poj1966,poj3281,poj1087,poj2289,poj3216,poj2446  (3)最优比率生成树. (poj2728)  (4)最小树形图(poj3164)  (5)次小生成树.  (6)无向图、有向图的最小环  三.数据结构.  (1)trie图的建立和应用. (poj2778)  (2)LCA和RMQ问题(LCA(最近公共祖先问题) 有离线算法(并查集+dfs) 和 在线算法  (RMQ+dfs)).(poj1330)  (3)双端队列和它的应用(维护一个单调的队列,常常在动态规划中起到优化状态转移的  目的). (poj2823)  (4)左偏树(可合并堆).  (5)后缀树(非常有用的数据结构,也是赛区考题的热点).  (poj3415,poj3294)  四.搜索  (1)较麻烦的搜索题目训练(poj1069,poj3322,poj1475,poj1924,poj2049,poj3426)  (2)广搜的状态优化:利用M进制数存储状态、转化为串用hash表判重、按位压缩存储状态、双向广搜、A*算法. (poj1768,poj1184,poj1872,poj1324,poj2046,poj1482)  (3)深搜的优化:尽量用位运算、一定要加剪枝、函数参数尽可能少、层数不易过大、可以考虑双向搜索或者是轮换搜索、IDA*算法. (poj3131,poj2870,poj2286)  五.动态规划  (1)需要用数据结构优化的动态规划.  (poj2754,poj3378,poj3017)  (2)四边形不等式理论.  (3)较难的状态DP(poj3133)  六.数学  (1)组合数学.  1.MoBius反演(poj2888,poj2154)  2.偏序关系理论.  (2)博奕论.  1.极大极小过程(poj3317,poj1085)  2.Nim问题.  七.计算几何学.  (1)半平面求交(poj3384,poj2540)  (2)可视图的建立(poj2966)  (3)点集最小圆覆盖.  (4)对踵点(poj2079)  八.综合题.  (poj3109,poj1478,poj1462,poj2729,poj2048,poj3336,poj3315,poj2148,poj1263)           -- 作者：蕉下客  -- 发布时间：2008/8/20 12:08:25   --  下面是另一版本POJ推荐，基本都比较难，很多题目与黑书配套  =================================  推荐一些题目，希望对参与ICPC竞赛的同学有所帮助。   POJ上一些题目在  http://162.105.81.202/course/problemSolving/  可以找到解题报告。  《算法艺术与信息学竞赛》的习题提示在网上可搜到   一.动态规划  参考资料：  刘汝佳《算法艺术与信息学竞赛》  《算法导论》   推荐题目：  http://acm.pku.edu.cn/JudgeOnline/problem?id=1141  简单   http://acm.pku.edu.cn/JudgeOnline/problem?id=2288  中等，经典TSP问题   http://acm.pku.edu.cn/JudgeOnline/problem?id=2411  中等，状态压缩DP   http://acm.pku.edu.cn/JudgeOnline/problem?id=1112  中等   http://acm.pku.edu.cn/JudgeOnline/problem?id=1848  中等，树形DP。  可参考《算法艺术与信息学竞赛》动态规划一节的树状模型   http://acm.zju.edu.cn/show_problem.php?pid=1234  中等，《算法艺术与信息学竞赛》中的习题   http://acm.pku.edu.cn/JudgeOnline/problem?id=1947  中等，《算法艺术与信息学竞赛》中的习题   http://acm.pku.edu.cn/JudgeOnline/problem?id=1946  中等，《算法艺术与信息学竞赛》中的习题   http://acm.pku.edu.cn/JudgeOnline/problem?id=1737  中等，递推   http://acm.pku.edu.cn/JudgeOnline/problem?id=1821  中等，需要减少冗余计算   http://acm.zju.edu.cn/show_problem.php?pid=2561  中等，四边形不等式的简单应用   http://acm.pku.edu.cn/JudgeOnline/problem?id=1038  较难，状态压缩DP，《算法艺术与信息学竞赛》中有解答   http://acm.pku.edu.cn/JudgeOnline/problem?id=1390  较难，《算法艺术与信息学竞赛》中有解答   http://acm.pku.edu.cn/JudgeOnline/problem?id=3017  较难，需要配合数据结构优化（我的题目^_^）   http://acm.pku.edu.cn/JudgeOnline/problem?id=1682  较难，写起来比较麻烦    http://acm.pku.edu.cn/JudgeOnline/problem?id=2047  较难   http://acm.pku.edu.cn/JudgeOnline/problem?id=2152  难，树形DP   http://acm.pku.edu.cn/JudgeOnline/problem?id=3028  难，状态压缩DP，题目很有意思   http://acm.pku.edu.cn/JudgeOnline/problem?id=3124  难   http://acm.pku.edu.cn/JudgeOnline/problem?id=2915  非常难    二.搜索  参考资料：  刘汝佳《算法艺术与信息学竞赛》  推荐题目：  http://acm.pku.edu.cn/JudgeOnline/problem?id=1011  简单，深搜入门题   http://acm.pku.edu.cn/JudgeOnline/problem?id=1324  中等，广搜   http://acm.pku.edu.cn/JudgeOnline/problem?id=2044  中等，广搜   http://acm.pku.edu.cn/JudgeOnline/problem?id=2286  较难，广搜   http://acm.pku.edu.cn/JudgeOnline/problem?id=1945  难，IDA*，迭代加深搜索，需要较好的启发函数   http://acm.pku.edu.cn/JudgeOnline/problem?id=2449  难，可重复K最短路，A*。  可参考解题报告:  http://acm.pku.edu.cn/JudgeOnline/showcontest?contest_id=1144   http://acm.pku.edu.cn/JudgeOnline/problem?id=1190  难，深搜剪枝，《算法艺术与信息学竞赛》中有解答   http://acm.pku.edu.cn/JudgeOnline/problem?id=1084  难，《算法艺术与信息学竞赛》习题   http://acm.pku.edu.cn/JudgeOnline/problem?id=2989  难，深搜   http://acm.pku.edu.cn/JudgeOnline/problem?id=1167  较难，《算法艺术与信息学竞赛》中有解答   http://acm.pku.edu.cn/JudgeOnline/problem?id=1069  很难           -- 作者：蕉下客  -- 发布时间：2008/8/20 12:08:48   --  三. 常用数据结构  参考资料：  刘汝佳《算法艺术与信息学竞赛》  《算法导论》  线段树资料：  http://home.ustc.edu.cn/~zhuhcheng/ACM/segment_tree.pdf  树状数组资料  http://home.ustc.edu.cn/~zhuhcheng/ACM/tree.ppt  关于线段树和树状数组更多相关内容可在网上搜到  后缀数组资料  http://home.ustc.edu.cn/~zhuhcheng/ACM/suffix_array.pdf  http://home.ustc.edu.cn/~zhuhcheng/ACM/linear_suffix.pdf   推荐题目   http://acm.pku.edu.cn/JudgeOnline/problem?id=2482  较难，线段树应用，《算法艺术与信息学竞赛》中有解答   http://acm.pku.edu.cn/JudgeOnline/problem?id=1151  简单，线段树应用矩形面积并，《算法艺术与信息学竞赛》中有解答   http://acm.pku.edu.cn/JudgeOnline/problem?id=3225  较难，线段树应用，可参考解题报告  http://acm.pku.edu.cn/JudgeOnline/showcontest?contest_id=1233   http://acm.pku.edu.cn/JudgeOnline/problem?id=2155  难，二维树状数组。   http://acm.pku.edu.cn/JudgeOnline/problem?id=2777  中等，线段树应用。   http://acm.pku.edu.cn/JudgeOnline/problem?id=2274  难，堆的应用，《算法艺术与信息学竞赛》中有解答   http://acm.zju.edu.cn/show_problem.php?pid=2334  中等，左偏树，二项式堆或其他可合并堆的应用。  左偏树参考http://www.nist.gov/dads/HTML/leftisttree.html  二项式堆参见《算法导论》相关章节   http://acm.pku.edu.cn/JudgeOnline/problem?id=1182  中等，并查集   http://acm.pku.edu.cn/JudgeOnline/problem?id=1816  中等，字典树   http://acm.pku.edu.cn/JudgeOnline/problem?id=2778  较难，多串匹配树  参考：http://home.ustc.edu.cn/~zhuhcheng/ACM/zzy2004.pdf   http://acm.pku.edu.cn/JudgeOnline/problem?id=1743  难，后缀数组   http://acm.pku.edu.cn/JudgeOnline/problem?id=2774   较难，最长公共子串，经典问题，后缀数组   http://acm.pku.edu.cn/JudgeOnline/problem?id=2758  很难，后缀数组  可参考解题报告  http://acm.pku.edu.cn/JudgeOnline/showcontest?contest_id=1178   http://acm.pku.edu.cn/JudgeOnline/problem?id=2448  很难，数据结构综合运用   四.图论基础  参考资料：  刘汝佳《算法艺术与信息学竞赛》  《算法导论》  《网络算法与复杂性理论》谢政   推荐题目:   http://acm.pku.edu.cn/JudgeOnline/problem?id=2337  简单，欧拉路   http://acm.pku.edu.cn/JudgeOnline/problem?id=3177  中等，无向图割边    http://acm.pku.edu.cn/JudgeOnline/problem?id=2942  较难，无向图双连通分支   http://acm.pku.edu.cn/JudgeOnline/problem?id=1639  中等，最小度限制生成树，《算法艺术与信息学竞赛》中有解答   http://acm.pku.edu.cn/JudgeOnline/problem?id=2728  中等，最小比率生成树，《算法艺术与信息学竞赛》中有解答   http://acm.pku.edu.cn/JudgeOnline/problem?id=3013  简单，最短路问题   http://acm.pku.edu.cn/JudgeOnline/problem?id=1275  中等，差分约束系统，Bellman-Ford求解，《算法艺术与信息学竞赛》中有解答   http://acm.pku.edu.cn/JudgeOnline/problem?id=1252  简单，Bellman-Ford   http://acm.pku.edu.cn/JudgeOnline/problem?id=1459  中等，网络流   http://acm.pku.edu.cn/JudgeOnline/problem?id=2391  较难，网络流   http://acm.pku.edu.cn/JudgeOnline/problem?id=1325  中等，二部图最大匹配   http://acm.pku.edu.cn/JudgeOnline/problem?id=2226  较难，二部图最大匹配   http://acm.pku.edu.cn/JudgeOnline/problem?id=2195  中等，二部图最大权匹配  KM算法参考《网络算法与复杂性理论》   http://acm.pku.edu.cn/JudgeOnline/problem?id=2516  较难，二部图最大权匹配   http://acm.pku.edu.cn/JudgeOnline/problem?id=1986  中等，LCA（最近公共祖先）问题  参考Tarjan\\'s LCA algorithm 《算法导论》第21章习题   http://acm.pku.edu.cn/JudgeOnline/problem?id=2723  较难，2-SAT问题  参考：http://home.ustc.edu.cn/~zhuhcheng/ACM/2-SAT.PPT   http://acm.pku.edu.cn/JudgeOnline/problem?id=2749  较难，2-SAT问题   http://acm.pku.edu.cn/JudgeOnline/problem?id=3164  较难，最小树形图  参考《网络算法与复杂性理论》中朱-刘算法   五.数论及组合计数基础   http://acm.pku.edu.cn/JudgeOnline/problem?id=1811  简单，素数判定，大数分解  参考算法导论相关章节   http://acm.pku.edu.cn/JudgeOnline/problem?id=2888  较难，Burnside引理   http://acm.pku.edu.cn/JudgeOnline/problem?id=2891  中等，解模方程组   http://acm.pku.edu.cn/JudgeOnline/problem?id=2154  中等，经典问题，波利亚定理   http://cs.scu.edu.cn/soj/problem.action?id=2703  难，极好的题目，Burnside引理+模线性方程组    http://acm.pku.edu.cn/JudgeOnline/problem?id=2764  较难，需要数学方法，该方法在《具体数学》第七章有讲   http://acm.pku.edu.cn/JudgeOnline/problem?id=1977  简单，矩阵快速乘法       ","date":1359614513,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1359614513,"objectID":"85bc68537f200b9b82821ab51b8856f0","permalink":"/post/csdn/poj-%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E4%B8%8E%E8%AE%A1%E5%88%92/","publishdate":"2013-01-31T14:41:53+08:00","relpermalink":"/post/csdn/poj-%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E4%B8%8E%E8%AE%A1%E5%88%92/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 初期: 一.基本算法: (1)枚举. (poj1753,poj2965) (2)贪心(poj1328,poj2109,poj2586) (3)","tags":["POJ","Algorithm","ACM"],"title":"POJ 题目分类与计划","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目： http://acm.hdu.edu.cn/showproblem.php?pid=1318     一般的字符串处理问题，一个共性：思路简单，代码繁琐。  譬如此题，首先会有一个问题要考虑：如何去建立   镜像字母表   。这里我采用的是两个常量字符串作为一一对应。  至于回文判断应该就不用说了吧。    代码如下：  #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; const char ch1[]=\"AEHIJLMOSTUVWXYZ123580\"; const char ch2[]=\"A3HILJMO2TUVWXY51SEZ80\"; char s[22]; int mir[130]; int pal(char *s){ int n=strlen(s)-1; for (int i(0);i\u0026lt;=n/2;i++) if (s[i]!=s[n-i]) return 0; return 1; } int mirr(char* s){ int n=strlen(s)-1; for (int i(0);i\u0026lt;=n/2;i++) if (mir[s[i]]\u0026lt;0 || mir[s[i]]!=s[n-i]) return 0; return 1; } int main(){ freopen(\"in.txt\",\"r\",stdin); for (int i('A');i\u0026lt;='Z';i++) mir[i]=-1; for (int i(0);i\u0026lt;22;i++) mir[ch1[i]]=ch2[i]; while (scanf(\"%s\",s)!=EOF){ int a=pal(s),b=mirr(s); if (!(a+b)) printf(\"%s -- is not a palindrome.\\n\",s); else { if (a\u0026gt;b) printf(\"%s -- is a regular palindrome.\\n\",s); else { if (a\u0026lt;b) printf(\"%s -- is a mirrored string.\\n\",s); else { printf(\"%s -- is a mirrored palindrome.\\n\",s); } } } printf(\"\\n\"); } return 0; }     Accepted    0MS   220K   876 B           ","date":1358401007,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1358401007,"objectID":"6603d19b55082a3dc1e7879c0fd8200a","permalink":"/post/csdn/hdoj-1318-palindromes/","publishdate":"2013-01-17T13:36:47+08:00","relpermalink":"/post/csdn/hdoj-1318-palindromes/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目： http://acm.hdu.edu.cn/showproblem.php?pid=1318 一般的字符串处理问题，一个共性：思路简单，代码繁琐。 譬如此题，首先会有一个问题要考虑：如何去","tags":["HDOJ","Algorithm","ACM"],"title":"HDOJ - 1318 Palindromes","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  字体：  http://url.cn/CtKsBe  linux默认字体  http://url.cn/ClMeMA  苹果系统默认编程字体 http://url.cn/DNLRS8  一种不错的汉英搭配个人感觉   http://url.cn/A4NRay  这个，是我以前的编程字体  模版：  Sublime 默认：       桌面：     ","date":1357731421,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1357731421,"objectID":"053b6a01673ff2d2cd9302185f8031ab","permalink":"/post/csdn/%E4%B8%80%E4%BA%9B%E9%9A%8F%E4%BE%BF-%E6%9B%B4%E6%96%B0%E4%B8%AD/","publishdate":"2013-01-09T19:37:01+08:00","relpermalink":"/post/csdn/%E4%B8%80%E4%BA%9B%E9%9A%8F%E4%BE%BF-%E6%9B%B4%E6%96%B0%E4%B8%AD/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 字体： http://url.cn/CtKsBe linux默认字体 http://url.cn/ClMeMA 苹果系统默认编程字体 http://url.cn/DNLRS8 一种不错的汉英搭配个人感觉 http://url.cn/A4NRay 这个，是我以前的编程字","tags":[],"title":"一些随便 更新中。。","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  写在篇头：   在不同的编译器下结果不同，本例测试的环境为 devcpp5.3.0.1 。   ——————————————————————————————————————————————————————————————————————  先看一段代码，猜猜会是什么输出：  x=1; printf(\"%d %d\\n\",x,x++); x=1; printf(\"%d %d\\n\",x++,x); x=1; printf(\"%d %d %d\\n\",x,x++,x); x=1; printf(\"%d %d %d %d\\n\",x,++x,x++,x); 如是~： 2 1 1 2 2 1 2 3 3 1 3   看到这里，你会发现，有时看起来是从左往右算，有时候是从右往左算，有时候还是从乱序算。。是不是有些郁闷呢。  其实，在处理printf时，压栈顺序为从右往左，也就是说从右往左的计算（“计算”不等于“输出”）。  在计算时，遇到x++会记录此时的x的值作为最后的输出结果。遇到x和++x的时候则不会将此时的计算结果作为最终的输出，只会修改x的值，在最终输出的时候都输出x的值（所以++x和x的结果总是一样的）。  为什么会是这个样子呢？参见某高手解释吧：  对于a++的结果，是有ebp寻址函数栈空间来记录中间结果的，在最后给printf压栈的时候，再从栈中把中间结果取出来；而对于++a的结果，则直接压寄存器变量，寄存器经过了所有的自增操作。 （来源：http://www.zzzj.com/html/20090609/71613.html）      [小试身手]  a=1; printf(\"%d %d %d %d %d %d\\n\",a++, ++a, a++, ++a, a++, ++a );  答案：[ 6 7 4 7 2 7  ]  （选中答案框看结果，你懂的~）   ","date":1357646024,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1357646024,"objectID":"9543dd2b994ba2c025821a9ecbddb8d0","permalink":"/post/csdn/c%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2-%E4%B9%8B-printf%E5%8E%8B%E6%A0%88%E9%A1%BA%E5%BA%8F/","publishdate":"2013-01-08T19:53:44+08:00","relpermalink":"/post/csdn/c%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2-%E4%B9%8B-printf%E5%8E%8B%E6%A0%88%E9%A1%BA%E5%BA%8F/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 写在篇头： 在不同的编译器下结果不同，本例测试的环境为 devcpp5.3.0.1 。 ——————————————————————","tags":["C"],"title":"C语言初探 之 printf压栈顺序","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  先看代码：  int a=16,b=17,c=18; int *p,*q,*g; p=\u0026amp;a;q=\u0026amp;b;g=\u0026amp;c; printf(\"%p %p %p\\n\",a,b,c); printf(\"%p %p %p\\n\",\u0026amp;a,\u0026amp;b,\u0026amp;c); printf(\"%8x %8x %8x\\n\",\u0026amp;a,\u0026amp;b,\u0026amp;c); printf(\"%8x %8x %8x\\n\",p,q,g);      %x 只是把同样的数值以不同的形式输出而已，因此如果要寻址，必须加\u0026amp;。  再比如：  for (int i(1);i\u0026lt;=4;i++){ printf(\"%10d %p %p %x %d\\n\",t[i],t[i],\u0026amp;t[i],(t+i),(t+i)); }       老感觉有问题啊，怎么回事。。          ","date":1357277822,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1357277822,"objectID":"17812dbbba3e7a2bc01f48137adc48b7","permalink":"/post/csdn/c%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2-%E4%B9%8B-p/","publishdate":"2013-01-04T13:37:02+08:00","relpermalink":"/post/csdn/c%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2-%E4%B9%8B-p/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 先看代码： int a=16,b=17,c=18; int *p,*q,*g; p=\u0026amp;a;q=\u0026amp;b;g=\u0026amp;c; printf(\"%p %p %p\\n\",a,b,c); printf(\"%p %p %p\\n\",\u0026amp;a,\u0026amp;b,\u0026amp;c); printf(\"%8x %8x %8x\\n\",\u0026amp;a,\u0026amp;b,\u0026amp;c); printf(\"%8x %8x %8x\\n\",p,q,g); %x 只是把同样的数值以不同的形式输出而已，因此如果要寻址，","tags":["C"],"title":"C语言初探 之 %p","type":"post"},{"authors":null,"categories":["typecho"],"content":"不是所有的记忆都美好，不是所有的人都值得记忆，岁月的河流太漫长，大部分的人与事都会被无情地冲走，但是，与青春有关的一切，总会沉淀到河底，成为不可磨灭的美好回忆。令我们念念不忘的，也许并不是那些事和人，而是我们逝去的梦想和激情。\n","date":1356920280,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1356920280,"objectID":"d954fe8e9e410c2897cc1ca9e05976cd","permalink":"/post/typecho/%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E7%9A%84%E8%AE%B0%E5%BF%86%E9%83%BD%E7%BE%8E%E5%A5%BD/","publishdate":"2012-12-31T10:18:00+08:00","relpermalink":"/post/typecho/%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E7%9A%84%E8%AE%B0%E5%BF%86%E9%83%BD%E7%BE%8E%E5%A5%BD/","section":"post","summary":"不是所有的记忆都美好，不是所有的人都值得记忆，岁月的河流太漫长，大部分的人与事都会被无情地冲走，但是，与青春有关的一切，总会沉淀到河底，成为","tags":["鸡汤","我的微博","tweet"],"title":"不是所有的记忆都美好","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n     数字根    参考链接：  http://blog.renren.com/share/334504317/8581660295#nogo   定义   数字根（ Digital Root  ）就是把一个数的各位数字相加，再将所得数的各位数字相加，直到所得数为一位数字为止。而这个一位数便是原来数字的数字根。适用范围为正整数和零。例如  :  1 的数字根为  1  10 的数字根为  1  （  1+0=1  ）  21 的数字根为  3  （  2+1=3  ）  48 的数字根为  3  （  4+8=12,1+2=3  ）  198 的数字根为  9  （  1+9+8=18  ，  1+8=9  ）   性质说明    1.任何数加9的数字根还是它本身。     小学学加法的时候我们都明白，一个数字加9，就是把十位加1，各位减1。因此十位加个位的和是不变的；如果有进位，即十位上是9，那么进位之后十位会变成0，百位会加1，道理和一个一位数加9是一样的。   2.9乘任何数字的数字根都是9。     同样是小学时学乘法时，我们在计算一位数乘九的时候，把十只手指头排开，乘几便弯下第几只手指头，前后的手指个数便是那个结果。它的数字根永远是10-1=9。多位数的化，拆分每一位数字即可。   3.数字根的三则运算   1.两数之和的数字根等于这两个数的数字根的和数字根   对于两个一位数来说，很容易理解。因为一位数的数字根就是它本身。   对于多位数来说，由性质1，把每个数字mod 9，就又变成了两个一位数。   2. 两数之积的数字根等于这两个数的数字根的积  的和数字根    可以把每个数字拆成许多9相加的形式，最后各剩余一个 (a mod 9)， 由    (a1+a2+...)*(b1+b2+...)=a1*(b1+b2+...)+a2*(b1+b2+...)+...+an*bm    从a1到a[n-1]都是9，由性质2，原来两式的数字根就是（an*bm）的数字根。而由性质1，可知an,bm又是两数本身的数字根。    3.一个数字的n次幂的数字根等于这个数字的数字根的n次幂  的和数字根           生日中的数字根       ","date":1353979596,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1353979596,"objectID":"d484dee048e9892ee2f088dcdfc13296","permalink":"/post/csdn/%E6%95%B0%E5%AD%97%E6%A0%B9%E4%BB%8B%E7%BB%8D/","publishdate":"2012-11-27T09:26:36+08:00","relpermalink":"/post/csdn/%E6%95%B0%E5%AD%97%E6%A0%B9%E4%BB%8B%E7%BB%8D/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 数字根 参考链接： http://blog.renren.com/share/334504317/8581660295#nogo 定义 数字根（ Digital Root ）就是把一个数的各位数字相加，再将所得数的各位数字相加，直到所得数","tags":[],"title":"数字根介绍","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  题目地址： http://acm.hdu.edu.cn/showproblem.php?pid=2045   算法思想：   1）有三种颜色，在涂某一块区域时，由于它的前一块区域已经确定，且相邻区域不能重复，所以在这一块区域上有两种涂法，因此，大体意识为 a[i]=a[i-1]*2  2）（为了方便描述，我们用1，2，3分别代表R，P，G）假设第一块涂色为1，则当以第n块结尾的时候，第n块区域就不能再为1。那么，在第n块区域中一共a[n]中涂法中，有多少涂法是1呢？用递推的思想，显然，如果第n-1块涂的不是1，那么第n块区域就可以涂成1。我们用b[i]表示a[i]种涂法里被涂成1的数量，可得b[i]=a[i-1]-b[i-1]。  3）综合以上两点，我们可以得出，方格总是为n时，可以涂的方法数就是第一步计算出来的理想值减去第二步中那些和第一块相冲突的个数，即：(a[i]-b[i])*3。当然不要忘了最后的乘以3哦！  代码如下：  a[1]=1; for (int i(2);i\u0026lt;=50;i++) a[i]=a[i-1]*2; b[3]=2; for (int i(4);i\u0026lt;=50;i++) b[i]=a[i-1]-b[i-1]; for (int i(1);i\u0026lt;=50;i++) c[i]-=a[i]-b[i];        考虑代码优化：    仔细观察上面的方法，可以发现，其实b数组本身就是用a数组产生的，并且只是用作临时存贮。那么能不能只用一个数组来节省空间呢？   1\t2\t3\t4\t5\t6\t7\t8 a\t1\t2\t4\t8\t16\t32\t64\t... b\t0\t0\t2\t2\t6\t10\t22\t42 c\t1\t2\t2\t6\t10\t22\t42\t...     通过观察，我们可以发现：  c[i]=a[i]-c[i-1]  =\u0026gt;   a[i]=c[i]+c[i-1]    =\u0026gt;   a[i-1]=c[i-1]+c[i-2]  又   a[i]=a[i-1]*2  整理得：c[i]=(c[i-1]+c[i-2])*2-c[i-1]  即： c[i]=c[i-1]+c[i-2]*2     代码如下：  a[1]=1; a[2]=2; a[3]=2; for (int i(4);i\u0026lt;=50;i++) a[i]=a[i-1]+a[i-2]*2;    我的博客          ","date":1353589287,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1353589287,"objectID":"46c31a2a3f158d7a1e5f48f6e28d67cd","permalink":"/post/csdn/hdoj-2045-rpg%E9%9A%BE%E9%A2%98/","publishdate":"2012-11-22T21:01:27+08:00","relpermalink":"/post/csdn/hdoj-2045-rpg%E9%9A%BE%E9%A2%98/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目地址： http://acm.hdu.edu.cn/showproblem.php?pid=2045 算法思想： 1）有三种颜色，在涂某一块区域时，由于它的前一块区域已经确定，且相邻区域不能重","tags":["HDOJ","Algorithm","ACM"],"title":"HDOJ - 2045 RPG难题","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n 题目地址：  http://acm.hdu.edu.cn/showproblem.php?pid=2043  最基础的模拟题目，只要按照题目给出的要求进行判断即可。 代码如下： #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; const string s=\"~!@#$%^\"; string ss; int n; int yes(string a){ if (a.size()\u0026lt;8 || a.size()\u0026gt;16) return 0; int t1,t2,t3,t4; t1=t2=t3=t4=0; for (string::size_type i(0);i\u0026lt;a.size();i++){ if (a[i]\u0026gt;='A'\u0026amp;\u0026amp;a[i]\u0026lt;='Z'){ t1=1; break; } } for (string::size_type i(0);i\u0026lt;a.size();i++){ if ((a[i]\u0026gt;='a')\u0026amp;\u0026amp;(a[i]\u0026lt;='z')){ t2=1; break; } } for (string::size_type i(0);i\u0026lt;a.size();i++){ if (a[i]\u0026gt;='0'\u0026amp;\u0026amp;a[i]\u0026lt;='9'){ t3=1; break; } } for (string::size_type i(0);i\u0026lt;a.size();i++){ if (s.find(a[i],0)!=string::npos){ t4=1; break; } } if (t1+t2+t3+t4\u0026gt;2) return 1; return 0; } int main(){ scanf(\u0026quot;%d\\n\u0026quot;,\u0026amp;amp;n); while (n--){ getline(cin,ss); if (yes(ss)) printf(\u0026quot;YES\\n\u0026quot;); else printf(\u0026quot;NO\\n\u0026quot;); } return 0;  }   我的博客   \n  ","date":1353583062,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1353583062,"objectID":"cd57f72cc66ca463fc1a489116699f41","permalink":"/post/csdn/hdoj-2043-%E5%AF%86%E7%A0%81/","publishdate":"2012-11-22T19:17:42+08:00","relpermalink":"/post/csdn/hdoj-2043-%E5%AF%86%E7%A0%81/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 题目地址： http://acm.hdu.edu.cn/showproblem.php?pid=2043 最基础的模拟题目，只要按照题目给出的要求进行判断即可。 代码如下： #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; const string s=\"~!@#$%^\"; string ss; int n;","tags":["HDOJ","Algorithm","ACM"],"title":"HDOJ – 2043 密码","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  testing...  #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int maxn=10010; const int maxm=maxn*2; const int maxu=maxn*4; const int maxt=maxn*10; const int oo=1993101215; int test,n,e,indexs,dep,tot,lca,debug; int id; //重链编号 int node; //线段树节点 int pre[maxm],other[maxm],last[maxm],w[maxm]; //建树 int dfsq[maxu],f[maxu][20],g[maxu][20],depq[maxu],pos[maxn]; //LCA相关 int que[maxn],father[maxn],s[maxn],next[maxn],maxs[maxn],dis[maxn],a[maxn],fatherp[maxn]; //重链相关 int left[maxt],right[maxt],leftnode[maxt],rightnode[maxt],root[maxn],data[maxt]; //线段树 int pid[maxn]; //每个点所在的重链编号 int order[maxn]; //每个点所在线段树的位置 int ed[maxn]; //重链的结束节点 int link[maxn]; //节点上方的边是读入的第几条 bool vis[maxn]; inline int MAX(int a,int b) { if (a\u0026gt;b)return a; else return b;\n}\ninline void add(int u,int v,int cost) { e++; pre[e]=last[u]; last[u]=e; other[e]=v; w[e]=cost;\n}\ninline void init() { int i,u,v,cost; memset(last,0,sizeof(last)); e=0; scanf(\u0026quot;%d\\n\u0026rdquo;,\u0026amp;n); for (i=1;i\u0026lt;n;i++) { scanf(\u0026quot;%d%d%d\\n\u0026rdquo;,\u0026amp;u,\u0026amp;v,\u0026amp;cost); add(u,v,cost); add(v,u,cost); } }\ninline void dfs(int u) { dfsq[++indexs]=u; depq[indexs]=dep; if (pos[u]==0) pos[u]=indexs; //记录首次出现的位置 vis[u]=true; for (int p=last[u];p;p=pre[p]) if (vis[other[p]]==false) { dep++; dfs(other[p]); dep\u0026ndash;; dfsq[++indexs]=u;\ndepq[indexs]=dep; } }\ninline void st() { //f[i][j]表示深搜序列i到j中最小的深度值 //g[i][j]表示深度值最小的节点编号 int i,j; for (i=1;i\u0026lt;=indexs;i++) { f[i][0]=depq[i]; g[i][0]=dfsq[i]; } for (j=1;j\u0026lt;=int(log(indexs)/log(2));j++) for (i=1;i\u0026lt;=indexs-(1\u0026lt;\u0026lt;j)+1;i++) if (f[i][j-1]\u0026gt;f[i+(1\u0026lt;\u0026lt;(j-1))][j-1]) { f[i][j]=f[i+(1\u0026lt;\u0026lt;(j-1))][j-1]; g[i][j]=g[i+(1\u0026lt;\u0026lt;(j-1))][j-1]; } else { f[i][j]=f[i][j-1]; g[i][j]=g[i][j-1]; } }\ninline void getlca() { indexs=0; dep=1; memset(vis,0,sizeof(vis)); memset(pos,0,sizeof(pos)); dfs(1); st(); }\ninline int rmq(int x0,int y0) { int l,r,t,k; l=pos[x0]; r=pos[y0]; if (l\u0026gt;r) {t=l;l=r;r=t;} k=int(log(r-l+1)/log(2)); if (f[l][k]\u0026lt;f[r-(1\u0026lt;\u0026lt;k)+1][k]) return g[l][k]; else return g[r-(1\u0026lt;\u0026lt;k)+1][k]; }\ninline void build(int l,int r,int \u0026amp;t) { if (t==0) t=++node; int mid=(l+r)/2; left[t]=l; right[t]=r; if (l==r) { data[t]=w[fatherp[a[l]]]; return; } build(l,mid,leftnode[t]); build(mid+1,r,rightnode[t]); data[t]=MAX(data[leftnode[t]],data[rightnode[t]]); }\ninline int find(int l,int r,int t) { if ((l==left[t])\u0026amp;\u0026amp;(r==right[t])) return data[t]; int mid=(left[t]+right[t])/2; if (r\u0026lt;=mid) return find(l,r,leftnode[t]); if (l\u0026gt;=mid+1) return find(l,r,rightnode[t]); return MAX(find(l,mid,leftnode[t]),find(mid+1,r,rightnode[t])); }\ninline void change(int x,int v,int t) { if (left[t]==right[t]) { data[t]=v; return ; } int mid=(left[t]+right[t])/2; if (x\u0026lt;=mid) change(x,v,leftnode[t]); if (x\u0026gt;=mid+1) change(x,v,rightnode[t]); data[t]=MAX(data[leftnode[t]],data[rightnode[t]]); }\ninline void bfs() //求重链 { int i,j,l,r,q,p; memset(vis,0,sizeof(vis)); memset(maxs,0,sizeof(maxs)); memset(link,0,sizeof(link)); memset(next,0,sizeof(next)); node=0; id=0; memset(root,0,sizeof(root)); memset(leftnode,0,sizeof(leftnode)); memset(rightnode,0,sizeof(rightnode));\nmemset(dis,0,sizeof(dis)); memset(order,0,sizeof(order)); memset(pid,0,sizeof(pid)); memset(ed,0,sizeof(ed)); memset(father,0,sizeof(father)); memset(left,0,sizeof(left)); memset(right,0,sizeof(right)); memset(data,0,sizeof(data)); l=0; r=1; que[r]=1; vis[1]=true; dis[1]=1; //维护深度 while (l\u0026amp;lt;r) { q=que[++l]; for (p=last[q];p;p=pre[p]) if (vis[other[p]]==false) { vis[other[p]]=true; que[++r]=other[p]; father[other[p]]=q; //求得他的父亲节点编号 fatherp[other[p]]=p; //当前节点到父亲的边 dis[other[p]]=dis[q]+1; link[(p+1)/2]=other[p]; } } for (i=1;i\u0026amp;lt;=n;i++) s[i]=1; for (i=n;i;i--) s[father[que[i]]]+=s[que[i]]; for (i=1;i\u0026amp;lt;=n;i++) { q=que[i]; for (p=last[q];p;p=pre[p]) if (dis[q]\u0026amp;lt;dis[other[p]]) if (s[other[p]]\u0026amp;gt;maxs[q]) { maxs[q]=s[other[p]]; next[q]=other[p]; } } memset(vis,0,sizeof(vis)); for (i=1;i\u0026amp;lt;=n;i++) { q=que[i]; if (vis[q]==true) continue; id++; tot=0; ed[id]=q; do { a[++tot]=q; vis[q]=true; pid[q]=id; order[q]=tot; q=next[q]; } while (q!=0); build(1,tot,root[id]); } /*if (debug==2) for (i=1;i\u0026amp;lt;=n;i++) if (dis[i]\u0026amp;lt;dis[ed[pid[i]]]) printf(\u0026quot;?\u0026quot;);*/  }\ninline int ask(int x,int y) //从x节点一直到祖先y { int ans=-oo; //if (dt==1) printf(\u0026quot;%d %d\\n\u0026rdquo;,x,y); while (x!=y) { //if (dt==1) printf(\u0026ldquo;x : %d %d %d %d\\n\u0026rdquo;,x,y,dis[x],dis[y]); if (dis[ed[pid[x]]]\u0026lt;=dis[y]) //如果在一条链上 { ans=MAX(ans,find(order[y]+1,order[x],root[pid[x]])); break; } if (dis[ed[pid[x]]]\u0026gt;dis[y]) //如果不在一条链上 { ans=MAX(ans,find(1,order[x],root[pid[x]])); // if (dt==1) printf(\u0026ldquo;wo cao: %d %d\\n\u0026rdquo;,dis[x],dis[father[ed[pid[x]]]]); x=father[ed[pid[x]]]; continue; } } return ans; }\ninline void work() { char s[30]; int x,y;\nwhile (1) { scanf(\u0026quot;%s\u0026quot;,s); if (s[0]=='D') break; if (s[0]=='C') { scanf(\u0026quot;%d%d\\n\u0026quot;,\u0026amp;amp;x,\u0026amp;amp;y); change(order[link[x]],y,root[pid[link[x]]]); } if (s[0]=='Q') { scanf(\u0026quot;%d%d\\n\u0026quot;,\u0026amp;amp;x,\u0026amp;amp;y); lca=rmq(x,y); printf(\u0026quot;%d\\n\u0026quot;,MAX(ask(x,lca),ask(y,lca))); } }  }\nint main() { scanf(\u0026quot;%d\\n\u0026rdquo;,\u0026amp;test); while (test\u0026ndash;) { debug++; init(); getlca(); bfs(); work(); } //system(\u0026ldquo;pause\u0026rdquo;); return 0; }\n\n  testing...    ","date":1353388493,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1353388493,"objectID":"9bc091c0ad81ee7ee2a0ccedf59b43f7","permalink":"/post/csdn/qtree_testing/","publishdate":"2012-11-20T13:14:53+08:00","relpermalink":"/post/csdn/qtree_testing/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 testing... #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int maxn=10010; const int maxm=maxn*2; const int maxu=maxn*4; const int maxt=maxn*10; const int oo=1993101215; int test,n,e,indexs,dep,tot,lca,debug; int id; //重链编号 int node; //线段树节点 int pre[maxm],other[maxm],last[maxm],w[maxm]; //","tags":["Qtree_testing"],"title":"Qtree_testing","type":"post"},{"authors":null,"categories":["typecho"],"content":"我是否也要像其他人一样写下：不知不觉来大学已经两个月了，咦！竟然恰好是两个月！满心是莫名的欢喜。\n两个月做了什么呢？\n学习依然同高中一样一塌糊涂。数学课仍然是听不进去，虽然在课下也能自己去搞，但是效果并不是很好。仍然是那么喜欢听历史课，如果有哲学课，我估计会更用心~或许，注定我不能去干技术了。\n课外活动据说是大学生活最重要的部分了。实际上所谓的课外生活，并没有想象中的那么精彩。很多同学们都进了社团或者部门，但是你却很少能听到哪个同学表示对哪个组织非常痴迷。\n我参加了院辩论队和学校ACM，辩论的话感觉力不从心，能说的人太多了，自己不过一坨屎。ACM的话，我在考虑是否要把四年的时间花在研究算法上呢。自己的数学能力事情是清楚的。\n网络技术，或许要学一点PHP和JSP，在互联网物联网时代，我不知道一个不懂网络的程序员的下场。\n","date":1352457000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1352457000,"objectID":"0acfa1a1a22b0a62e24d4bdcaf775319","permalink":"/post/typecho/47-%E5%BC%80%E5%AD%A660%E5%A4%A9%E5%B0%8F%E8%AE%B0/","publishdate":"2012-11-09T18:30:00+08:00","relpermalink":"/post/typecho/47-%E5%BC%80%E5%AD%A660%E5%A4%A9%E5%B0%8F%E8%AE%B0/","section":"post","summary":"我是否也要像其他人一样写下：不知不觉来大学已经两个月了，咦！竟然恰好是两个月！满心是莫名的欢喜。\n","tags":["记事"],"title":"开学60天小记","type":"post"},{"authors":null,"categories":["typecho"],"content":"又是一次Wordpress，希望这次可以好好的走下去，不要再只是闹着玩玩。\n大学了，或许会成为一个新的起点，希望在这里能够记下重生后的点点滴滴。当然，不可能每件事情都在这里留下，还有我的轻博客和微博以及人人，各种工具一起用，效果或许会更好点，信息更全面一点吧。至于各个博客地址，个人资料里会有更新。\n先来说一些废话吧，其实也不算废话，就是搭建博客的背景吧。\n简而言之，就是感觉混不不是很差劲，搭个博客自我安慰一下而已。具体一点的话，具体的其实就没了。其实还是很虚无的，不会因为搭个博客就会怎么怎么样的。有的还是有的，没有的还是不会蹦达出来。\n进大学这么久了，感觉还好的就是进入辩论队，而且成为ACM准队员了。辩论队么，或许只是一个玩玩的心态，不过玩了一次后，竟然玩出感情了，那份友谊，好像就是那么一瞬间给建立起来的。一起付出、一起流汗后的感情真不是大家在一起笑一笑就能出来的。以后大家在一起相处时间越来越长，希望大家的感情地久天长吧。\n关于ACM，我只能说准队员吧，因为一切未知。前天学长们做了一些介绍，果然被大家的激情感染了（或许是会想到了高中时一起在机房奋战（不光是OI，过来人都懂得），一起在车上聊天和三国杀，一起在宾馆里嬉戏。一起比赛之后那似笑非笑的表情和成绩下来后一张张哭丧的小脸）。而且学校实力不算差，除了激情，这应该算第二个激动人心的事情了，大家在努力，大家在进步，这远远比把你放在一个所谓的强队里让你去苦逼更加愉快。既然还是有底子的，还是要好好努力，给自己加油。或许是为了那份感动，或许是为了看些个美女，或许是为了那挺起看很诱人的奖金，或许是为了那个80道题就能拿到的百度包。不论动机如何，我都会努力。\n其他的杂事。。暂且就不说了吧。。因为那些并不是搭博的主要因素，以后整理整理再做专题慢慢介绍吧。好久不写，突然发现写的好虚，好空。唉。郁闷。先就这吧\n","date":1351420080,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1351420080,"objectID":"ee402e83a623ec0653637b4e6d96647c","permalink":"/post/typecho/45-hello-world/","publishdate":"2012-10-28T18:28:00+08:00","relpermalink":"/post/typecho/45-hello-world/","section":"post","summary":"又是一次Wordpress，希望这次可以好好的走下去，不要再只是闹着玩玩。\n大学了，或许会成为一个新的起点，希望在这里能够记下重生后的点点滴滴。当然，不可能每件事情都在这里留下，还有我的轻博客和微博以及人人，各种工具一起用，效果或许会更好点，信息更全面一点吧。至于各个博客地址，个人资料里会有更新。\n","tags":["记事"],"title":"Hello World","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n   背景   我们在以前的数学题中一定遇到过这样的问题：  A说xxxx  B说xxx  C说xxx  然后给一些条件，让你判断每个人说话的真假  这个题目是这样的：   计算机学院准备组织院篮球赛，某班有ABCDE五个同学商量组队参加，他们在讨论谁来打前锋的时候发生了争执，于是他们请了另一个班的同学J当评委，五个人PK百米速度，谁的速度最快就由谁来当前锋，其实五个同学速度相当，比赛结束时，J让他们猜猜排名情况   A说：“E一定是第一名”   B说：“我可能是第二名”   C说：“A最慢”   D说：“C不是最快的”   E说：“D应该是第一名”    J最后说：“E肯定不是第二名或者第三名，你们几个只有获得第一名和第二名的人猜对了，你们应该知道谁最快了吧？”  编程给出五个同学的排名。  算法   习惯了通过表达式去计算一个结果的人，很难去用枚举的思维方式来处理问题。尤其对于枚举的模型很难把握。  枚举算法求解这类问题其实很简单，我尝试用以下三句话来说明：   把每个人说的话用一个逻辑表达式表示出来   枚举解空间内所有可能出现的情况   按照题中条件，筛选合法解   建立说话内容（断言）的模型   可以很容易想到，上述问题中A的内容“E是第一名”可以写成： Score['E'] == 1;   关键在于，如何描述“A说”的这个过程。很容易想到，这个过程实际上是一个从字符到表达式的映射。表达式在C语言中如何作为一个变量来使用？当然是函数指针，于是可以写出下面的代码： int guessA(){ return Score['E'] == 1; } int guessB(){ return Score['B'] == 2; } ... int (*guess[256])(); // 定义一个函数指针的数组 guess['A'] = guessA; guess['B'] = guessB; ...  这样的话，就可以用  guess['A']()  来表示A猜得正确与否 枚举解空间   这个题目较为简单，5个人的排名当然有5!种情况，可以用C++提供的全排列的库实现，也可以用深搜自己实现。这里使用 康托展开逆运算  得到（每次计算的时间复杂度为O(1)） // 生成1~n的全排列中得第k项，返回值在ret中 int fac[]={1,1,2,6,24,120,720,5040,40320,362880}; void invKT(int n, int k, int ret[]){ k--; int vst[8]={0}, j; for ( int i=0; i\u0026lt;n; i++){ int t = k/fac[n-i-1]; for (j=1; j\u0026lt;=n; j++){ if (!vst[j]){ if (t==0) break; t--; } } ret[i] = j; vst[j] = 1; k %= fac[n-i-1]; } }  我们可以枚举得到每次的结果： int score[N]; // score[i]表示('A'+i)排第几名 int rank[N]; // rank[i]表示第i名是谁 for ( int i=1; i\u0026lt;=fac[n]; i++) { invKT(n, i, score); for ( int j=0; j\u0026lt;n; j++) rank[score[i]] = 'A'+i; } 筛选   有了以上的准备工作，筛选就非常容易了。  只有第一名和第二名说的正确： if ( guess[ rank[1] ]() == 1 \u0026amp;\u0026amp; guess[ rank[2] ]() == 1 \u0026amp;\u0026amp; guess[ rank[3] ]() == 0 \u0026amp;\u0026amp; guess[ rank[4] ]() == 0 \u0026amp;\u0026amp; guess[ rank[5] ]() == 0 )  E不是第二和第三： if ( score['E'-'A'] != 2 \u0026amp;\u0026amp; score['E'-'A'] != 3 )  总代码   实际的代码为了偷懒，在一些细节上跟上面的分析不太一样，仅供参考。 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; int score[6]; // i排第几 int rank[6]; // 第i名是谁\nvoid invKT(int n, int k, int ret[]); int guess(int i);\nint main(){\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; ( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;i\u0026amp;lt;=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;120\u0026lt;/span\u0026gt;;i++){ invKT(n, i, score+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; ( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;j\u0026amp;lt;=n;j++) rank[score[j]] = j; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (guess(rank[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]) \u0026amp;amp;\u0026amp;amp; guess(rank[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]) \u0026amp;amp;\u0026amp;amp; guess(rank[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;])==\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; guess(rank[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;])==\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; guess(rank[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;])==\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; score[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]!=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; score[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]!=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; ( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;j\u0026amp;lt;=n;j++){ \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%c：第%d名\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;'A'\u0026lt;/span\u0026gt;+j-\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, score[j]); } } } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;  }\nint guess(int i){ return (i==1)(score[5]==1) || (i==2)(score[2]==2) || (i==3)(score[1]==5) || (i==4)(score[3]!=1) || (i==5)*(score[4]==1); }\nint fac[]={1,1,2,6,24,120,720,5040,40320,362880}; void invKT(int n, int k, int ret[]){ k\u0026ndash;; int vst[8]={0}, j; for ( int i=0; i\u0026lt;n; i++){ int t = k/fac[n-i-1]; for (j=1; j\u0026lt;=n; j++){ if (!vst[j]){ if (t==0) break; t\u0026ndash;; } } ret[i] = j; vst[j] = 1; k %= fac[n-i-1]; } }\n ","date":1350097751,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1350097751,"objectID":"210ab1a5037973aafe310021c5e024b0","permalink":"/post/csdn/%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8E%BB%E5%88%A4%E6%96%AD%E6%AF%8F%E4%B8%AA%E4%BA%BA%E8%AF%B4%E8%AF%9D%E7%9A%84%E7%9C%9F%E5%81%87-%E5%86%99%E7%BB%99%E6%96%B0%E6%89%8B%E7%9A%84%E6%9E%9A%E4%B8%BE%E4%BB%8B%E7%BB%8D/","publishdate":"2012-10-13T11:09:11+08:00","relpermalink":"/post/csdn/%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8E%BB%E5%88%A4%E6%96%AD%E6%AF%8F%E4%B8%AA%E4%BA%BA%E8%AF%B4%E8%AF%9D%E7%9A%84%E7%9C%9F%E5%81%87-%E5%86%99%E7%BB%99%E6%96%B0%E6%89%8B%E7%9A%84%E6%9E%9A%E4%B8%BE%E4%BB%8B%E7%BB%8D/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 背景 我们在以前的数学题中一定遇到过这样的问题： A说xxxx B说xxx C说xxx 然后给一些条件，让你判","tags":[],"title":"用程序去判断每个人说话的真假 - 写给新手的枚举介绍","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n    var tt = [\"\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\", \"七\", \"八\", \"九\", \"十\"]; var tq = [\"\", \"①\", \"②\", \"③\", \"④\", \"⑤\", \"⑥\", \"⑦\", \"⑧\", \"⑨\", \"⑩\"];  window.onload = function(){ return; h1 = document.querySelectorAll(\u0026quot;h1\u0026quot;); h2 = document.querySelectorAll(\u0026quot;h2\u0026quot;); h3 = document.querySelectorAll(\u0026quot;h3\u0026quot;); h4 = document.querySelectorAll(\u0026quot;h4\u0026quot;); var txt = \u0026quot;\u0026lt;h2\u0026gt; Directory \u0026quot;; txt += \u0026quot;\u0026lt;pre\u0026gt;\u0026quot; for ( t1=0; t1\u0026lt;h1.length; t1++ ){ txt += \u0026quot;\u0026lt;h3\u0026gt;\u0026quot; + (tt[t1+1]) + \u0026quot;.\u0026quot; + h1[t1].innerHTML + \u0026quot;\u0026quot;; for ( t2=0; t2\u0026lt;h2.length; t2++ ) if (h2[t2].offsetTop \u0026gt; h1[t1].offsetTop \u0026amp;\u0026amp; ( t1==h1.length-1 || h2[t2].offsetTop \u0026lt; h1[t1+1].offsetTop )) { txt += \u0026quot;\u0026lt;h4\u0026gt; \u0026quot; + (t2+1) + \u0026quot;. \u0026quot; + h2[t2].innerHTML + \u0026quot;\u0026quot;; for (t3=0; t3\u0026lt;h3.length; t3++ ) if (h3[t3].offsetTop \u0026gt; h2[t2].offsetTop \u0026amp;\u0026amp; ( t2==h2.length-1 || h3[t3].offsetTop \u0026lt; h2[t2+1].offsetTop )) { txt += \u0026quot;\u0026lt;h5\u0026gt; \u0026quot; + (t3+1) + \u0026quot;) \u0026quot; + h3[t3].innerHTML + \u0026quot;\u0026quot;; for ( t4=0; t4\u0026lt;h4.length; t4++ ) if (h4[t4].offsetTop \u0026gt; h3[t3].offsetTop \u0026amp;\u0026amp; ( t3==h3.length-1 || h4[t4].offsetTop \u0026lt; h3[t3+1].offsetTop )) { txt += \u0026quot; | \u0026quot; + h4[t4].innerHTML + \u0026quot;\\n\u0026quot;; } } } } txt += \u0026quot;\u0026quot;; document.getElementById(\u0026quot;Directory\u0026quot;).innerHTML = txt; }  \n ACM语法基础 C/CPP不常用的知识点 字符串拆分 char ss[] = \u0026quot;(1,2,3,4)\u0026quot;; char *p = strtok(ss, \u0026quot;(,)\u0026quot;); for (int i(1); i\u0026lt;=n; i++) { sscanf(p, \u0026quot;%d\u0026quot;, \u0026amp;k); p = strtok(NULL, \u0026quot;,)\u0026quot;); } gets 、fgets 、getline  gets 会过滤行首空格（不含\\n） fgets 完全读入，把\\n吃进字符串末位，与scanf混用时容易出错 getline 自动跳转下一行，不会过滤行首空格  Java快速读写 例题 @ hdoj 5047 Sawtooth 读入一个大数，按照特定公式计算结果。\nimport java.math.*; import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws Exception { BufferedReader cin = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter cout = new BufferedWriter(new OutputStreamWriter(System.out)); BigInteger n, ans, a1, a2, a7, a8; a1 = BigInteger.valueOf(1); a2 = BigInteger.valueOf(2); a7 = BigInteger.valueOf(7); a8 = BigInteger.valueOf(8); String ss = cin.readLine(); int T = Integer.parseInt(ss); for(int i=1; i\u0026lt;=T; i++){ ss = cin.readLine(); n = new BigInteger( ss ); cout.write( \u0026quot;Case #\u0026quot;+i+\u0026quot;: \u0026quot; ); ans = n.multiply(n).multiply(a8); ans = ans.subtract(a7.multiply(n)); ans = ans.add(a1); cout.write( ans.toString() ); cout.newLine(); cout.flush(); } } } 模拟易错点 a b @ POJ 1017 Packets | 装完大包装小包 /* 6种物品，体积分别为1*1 2*2 ... 6*6 。每种数量有20000 包裹体积为6*6，问装满所有的物品至少需要多少个包裹。 solution： 从大到小装，有缝隙了依次选小的。 */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int n=6,t; int a[8]; int push(int t,int i, int num){ // 把num个a[i]放进容量为t的箱子里，返回箱子容量 if ( num \u0026gt; a[i]) num = a[i]; t -= i*i * num; a[i] -= num; return t; } int main(){ for(;;){ int ts = 0; for ( int i(1);i\u0026lt;=n;i++){ cin \u0026gt;\u0026gt; a[i]; ts+=a[i]; } if (!ts) break; int s =a[6]+a[5]+a[4]; // a5 if (a[5]*11 \u0026gt;= a[1]) a[1] = 0; else a[1] -= a[5]*11; // a4 for ( int i(1);i\u0026lt;=a[4];i++){ t = push(20,2,5); if (t) t = push(t,1,t); } // a3 s += a[3] / 4; // 整装3 a[3] %= 4; if (a[3]){ // 剩下的空间分情况装2 t = 36 - a[3]*9; if ( a[3] == 1 ) t = push(t,2,5); if ( a[3] == 2 ) t = push(t,2,3); if ( a[3] == 3 ) t = push(t,2,1); if (t) t = push(t,1,t); // 剩下的空间都装1 s++; } // a2 s += a[2] / 9; a[2] %= 9; if (a[2]){ t = 36 - a[2] * 4; t = push(t,1,t); s++; } // a1 s += a[1] / 36; a[1] %= 36; if (a[1]) s++; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } return 0; } @ USACO 1.4.3 The Clocks /* 根据九个表和九个操作的关系，得出下列关系表： 先列一下钟表与矩阵的关系图： Ci = C[i] / 3; clocks operates 1 1 2 4 ( C1 + p1 + p2 + p4 ) % 4 == 0 2 1 2 3 5 ( C2 + p1 + p2 + p3 + p5 ) % 4 == 0 3 2 3 6 ... 4 1 4 5 7 ... 5 1 3 5 7 9 ... 6 3 5 6 9 7 4 7 8 8 5 7 8 9 9 6 8 9 把上面的关系式反过来，就能在已知 c[i] 通过枚举部分 pi 求出其它 pi 我枚举的是123三个操作，然后剩下6个操作就可以就确定了。 */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int c[11]; int cal(int a, int b, int c){ int t = - a - b - c; while ( t \u0026lt; 0 ) t += 4; return t; } int cal(int a, int b, int c, int d){ int t = - a - b - c - d; while ( t \u0026lt; 0 ) t += 4; return t; } int main(){ freopen(\u0026quot;clocks.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;clocks.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); for (int i(1);i\u0026lt;=9;i++) { cin \u0026gt;\u0026gt; c[i]; c[i] /= 3; } int p[11]; bool found = false; for ( p[1] = 0; p[1] \u0026lt; 4; p[1]++ ){ for ( p[2] = 0; p[2] \u0026lt; 4; p[2]++ ){ for ( p[3] = 0; p[3] \u0026lt; 4; p[3]++ ){ p[4] = cal(c[1], p[1], p[2]); p[5] = cal(c[2], p[1], p[2], p[3]); p[6] = cal(c[3], p[2], p[3]); p[7] = cal(c[4], p[1], p[4], p[5]); p[8] = cal(c[7], p[4], p[7]); p[9] = cal(c[9], p[6], p[8]); if (((c[5] + p[1] + p[3] + p[5] + p[7] + p[9]) % 4 == 0) \u0026amp;\u0026amp; ((c[8] + p[5] + p[7] + p[8] + p[9] ) % 4 == 0) \u0026amp;\u0026amp; ((c[6] + p[3] + p[5] + p[6] + p[9] ) % 4 == 0 )){ found = 1; break; } if ( found ) break; } if ( found ) break; } if ( found ) break; } int i = 1; while ( p[i] == 0 ) i++; printf(\u0026quot;%d\u0026quot;,i); p[i--]--; while ( ++i \u0026lt;= 9 ) while ( p[i]-- ) printf(\u0026quot; %d\u0026quot;,i); printf(\u0026quot;\\n\u0026quot;); return 0; } 搜索 多状态标记 @ HDU 5024 Wang Xifeng’s Little Plot 广州区域赛 /* 题意：找到一个最长的L型 思路：把L拆成两个直线，枚举所有的情况，记忆化搜索 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int maxn = 110; int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}; int dy[8] = {1, -1, 0, 0, 1, -1, 1, -1}; int n, f[maxn][maxn][8]; char g[maxn][maxn]; int dfs(int x, int y, int dir) { if (f[x][y][dir] != -1) return f[x][y][dir]; if (g[x+dx[dir]][y+dy[dir]] == '.') return f[x][y][dir] = 1 + dfs(x+dx[dir], y+dy[dir], dir); else return f[x][y][dir] = 1; } int main() { while (scanf(\u0026quot;%d\u0026quot;, \u0026amp;n) != EOF \u0026amp;\u0026amp; n) { memset(f, -1, sizeof(f)); memset(g, 0, sizeof(g)); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026quot;%s\u0026quot;, g[i]+1); int ans = -1; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) if (g[i][j] == '.') { ans = max(ans, dfs(i, j, 0) + dfs(i, j, 2) - 1); ans = max(ans, dfs(i, j, 1) + dfs(i, j, 2) - 1); ans = max(ans, dfs(i, j, 1) + dfs(i, j, 3) - 1); ans = max(ans, dfs(i, j, 0) + dfs(i, j, 3) - 1); ans = max(ans, dfs(i, j, 4) + dfs(i, j, 5) - 1); ans = max(ans, dfs(i, j, 4) + dfs(i, j, 6) - 1); ans = max(ans, dfs(i, j, 7) + dfs(i, j, 5) - 1); ans = max(ans, dfs(i, j, 7) + dfs(i, j, 6) - 1); } printf(\u0026quot;%d\\n\u0026quot;, ans); } return 0; } @ HDU 5025 Saving Tang Monk 题意：给一个地图，孙悟空(K)救唐僧(T)，地图中’S’表示蛇，第一次到这要杀死蛇（蛇最多5条），多花费一分钟，’1’~’m’表示m个钥匙(m\u0026lt;=9)，孙悟空要依次拿到这m个钥匙，然后才能去救唐僧，集齐m个钥匙之前可以经过唐僧，集齐x个钥匙以前可以经过x+1,x+2..个钥匙，问最少多少步救到唐僧。\n/* 本题主要是每一条蛇状态的记录，使用状态压缩，将每一条蛇的状态用二进制位记录下来，1代表活，0代表死。 使用vis四维数组记录每一点走过的状态，x,y分别表示位置，k 钥匙，s 表示蛇的状态，b 表示步数。 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;map\u0026gt; const int inf=0xfffffff; typedef long long ll; using namespace std; char m[105][105]; int vis[105][105][15][40]; int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0}; int sx, sy, sn, N, M; struct node { int x, y, k, s, b; }; queue\u0026lt;node\u0026gt; q; int ans; void bfs() { node now; q.push((node){sx, sy, 0, 0, 0}); while(!q.empty()){ now = q.front(); q.pop(); int x = now.x, y = now.y, k = now.k, s = now.s, b = now.b; if(k == M \u0026amp;\u0026amp; m[x][y] == 'T'){ ans = min(ans, b); } if(vis[x][y][k][s] != 0) continue; vis[x][y][k][s] = 1; for(int i = 0; i \u0026lt; 4; i ++){ int nx = x + dx[i], ny = y + dy[i]; int snn = m[nx][ny] - 'A'; if(snn \u0026gt;= 0 \u0026amp;\u0026amp; snn \u0026lt; sn){ if((1\u0026lt;\u0026lt;snn) \u0026amp; s) q.push((node) {nx, ny, k, s, b + 1}); else q.push((node) {nx, ny, k, (1\u0026lt;\u0026lt;snn) | s, b + 2}); } else{ if(m[nx][ny] == k + '1'){ q.push((node) {nx, ny, k + 1, s, b + 1}); } else if(nx \u0026gt; 0 \u0026amp;\u0026amp; nx \u0026lt;= N \u0026amp;\u0026amp; ny \u0026gt; 0 \u0026amp;\u0026amp; ny \u0026lt;= N \u0026amp;\u0026amp; m[nx][ny] != '#') q.push((node) {nx, ny, k, s, b + 1}); } } } } int main() { //freopen(\u0026quot;in\u0026quot;, \u0026quot;r\u0026quot;, stdin); while(~scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;N, \u0026amp;M)){ if(N == 0 \u0026amp;\u0026amp; M == 0) break; memset(m, 0, sizeof(m)); memset(vis, 0, sizeof(vis)); sn = 0; for(int i = 1; i \u0026lt;= N; i ++){ scanf(\u0026quot;%s\u0026quot;, m[i] + 1); for(int j = 1; j \u0026lt;= N; j ++){ if(m[i][j] == 'K'){ sx = i; sy = j; } if(m[i][j] == 'S'){ m[i][j] = 'A' + sn; sn ++; } } } ans = inf; bfs(); if(ans == inf) printf(\u0026quot;impossible\\n\u0026quot;); else printf(\u0026quot;%d\\n\u0026quot;, ans); } return 0; } /* 解法：BFS，每个节点维护四个值： x,y ： 当前坐标 key ：已经集齐了key个钥匙 step：已经走了多少步 S ： 蛇的访问状态 (2^5的数表示，某位为1表示已经杀过了) 然后把唐僧看做钥匙m+1，再加点优化： 为了避免超时，用一个全局的dis[x][y][key][S] 表示到(x,y),已经集齐到key个钥匙，蛇的访问状态为S时的最小步数，如果BFS扩展的时候，当前状态的步数\u0026gt;=dis[当前状态]，那么就不再扩展下去了。 BFS中的逻辑就很简单了，看代码吧。 最后，枚举蛇的状态S，取dis[x][y][m+1][S]的最小值即为最小步数。 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;map\u0026gt; #define INF 0x3f3f3f3f using namespace std; #define N 1000007 int dis[104][104][12][33],Stot,M; struct node { int x,y,key,step,S; }; int dx[4] = {0,0,1,-1}; int dy[4] = {1,-1,0,0}; map\u0026lt;pair\u0026lt;int,int\u0026gt;,int\u0026gt; snake; char ss[105][105]; int n,m; bool OK(int nx,int ny) { if(nx \u0026lt; n \u0026amp;\u0026amp; nx \u0026gt;= 0 \u0026amp;\u0026amp; ny \u0026lt; n \u0026amp;\u0026amp; ny \u0026gt;= 0 \u0026amp;\u0026amp; ss[nx][ny] != '#') return true; return false; } void bfs(node s) { queue\u0026lt;node\u0026gt; que; que.push(s); while(!que.empty()) { node now = que.front(); que.pop(); int nx = now.x, ny = now.y; int key = now.key, step = now.step; int S = now.S; node tmp; for(int k=0;k\u0026lt;4;k++) { int kx = nx + dx[k]; int ky = ny + dy[k]; if(!OK(kx,ky)) continue; tmp.x = kx,tmp.y = ky; if(ss[kx][ky] == 'S') //蛇 { int ind = snake[make_pair(kx,ky)]; //是第几条蛇 tmp.key = key; if(S \u0026amp; (1\u0026lt;\u0026lt;(ind-1))) //如果已经杀死 { tmp.S = S; tmp.step = step+1; } else //否则要杀 { tmp.S = S|(1\u0026lt;\u0026lt;(ind-1)); tmp.step = step+2; } if(tmp.step \u0026lt; dis[kx][ky][tmp.key][tmp.S]) { dis[kx][ky][tmp.key][tmp.S] = tmp.step; que.push(tmp); } } else if(ss[kx][ky] \u0026gt;= '1' \u0026amp;\u0026amp; ss[kx][ky] \u0026lt;= '9') //钥匙点 { int num = ss[kx][ky] - '0'; tmp.step = step+1; tmp.S = S; if(num == key+1) //正好是要拿的那个 tmp.key = key+1; else tmp.key = key; if(tmp.step \u0026lt; dis[kx][ky][tmp.key][tmp.S]) { dis[kx][ky][tmp.key][tmp.S] = tmp.step; que.push(tmp); } } else if(ss[kx][ky] == '$') //唐僧这个点 { tmp.key = key; tmp.S = S; tmp.step = step+1; if(M == key+1) //已经集齐了所有钥匙，不再扩展，更新dis即可 dis[kx][ky][M][S] = min(dis[kx][ky][M][S],step+1); else //没有集齐，继续走 que.push(tmp); } else if(ss[kx][ky] == '.') { tmp.key = key; tmp.S = S; tmp.step = step+1; if(tmp.step \u0026lt; dis[kx][ky][tmp.key][tmp.S]) { dis[kx][ky][tmp.key][tmp.S] = tmp.step; que.push(tmp); } } } } } int main() { int Sx,Ex,Sy,Ey; int i,j; while(scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m)!=EOF \u0026amp;\u0026amp; n+m) { if(n == 1) { puts(\u0026quot;impossible\u0026quot;); continue; } snake.clear(); Stot = 0; M = m+1; for(i=0;i\u0026lt;n;i++) { scanf(\u0026quot;%s\u0026quot;,ss[i]); for(j=0;j\u0026lt;n;j++) { if(ss[i][j] == 'K') Sx = i,Sy = j, ss[i][j] = '.'; else if(ss[i][j] == 'T') Ex = i,Ey = j, ss[i][j] = '$'; else if(ss[i][j] == 'S') snake[make_pair(i,j)] = ++Stot; } } node tmp; tmp.x = Sx,tmp.y = Sy,tmp.key = 0,tmp.step = 0,tmp.S = 0; memset(dis,INF,sizeof(dis)); dis[Sx][Sy][0][0] = 0; bfs(tmp); int mini = INF; for(i=0;i\u0026lt;(1\u0026lt;\u0026lt;Stot);i++) mini = min(mini,dis[Ex][Ey][M][i]); if(mini == INF) puts(\u0026quot;impossible\u0026quot;); else printf(\u0026quot;%d\\n\u0026quot;,mini); } return 0; } 图论 欧拉回路 哈密顿回路 判断存在 判断欧拉通路：\n  一个有向图存在欧拉回路必定也存在欧拉通路…因为通路的定义包括了回路 不考虑为欧拉回路的情况..一个有向图是欧拉通路就必须有一个点出度-入度=1,一个点入度-出度=1..这两点就是欧拉通路的起点和终点..并且该图连通 我自己加一条，其实是对2的理解：入读-出度\u0026gt;1 时直接return false ，排除 a-\u0026gt;b a-\u0026gt;c 这种情况   判断欧拉回路：\n 无向图是欧拉图的充要条件是所有点的度为偶数并且所有点联通\n有向图是欧拉图的充要条件是所有点的入度=出度..并且联通…\n 判断连通:\n  dfs遍历，这里有一份参考代码不过我一直怀疑其正确性。因为你无法确定有向图的起点，比如 a-\u0026gt;b-\u0026gt;c 如果你从b点开始搜的话就会悲催，但是你不知道b点上面还有没有点。 并查集，并查集的方便之处不用废话。但是在图论中两点之间有多条边时需要注意一些细节的处理。   关于判断入读出度:\n 一种办法是分别记录 in[] out[] 我用的办法是一个数组：sz[x]++ 表示拉出一条边，sz[x]–表示走来一条边，sz[x]==1 sz[x]==-1 就是上面的两种情况\n @ UVa 10129 Play on Words /* 题意就是给你一堆单词，按首位顺序排列起来，问你有没有解。 第一眼看上去是个哈密顿通路，单词当做节点，首尾关系作边，听上去妥妥的不过N有100000 复杂度太恐怖。 其实是从刘汝佳的小白书第二版（其实该叫小紫红书了）上欧拉回路那节看到的，所以得考虑考虑转换 把单词当边，首尾字符当做点 题目就转变为 欧拉通路 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #define N 101010 using namespace std; int sz[333]; int fa[333]; bool ok[333]; // 数据中使用到的单词 int n, T; int getfa(int v) { if ( fa[v] == v ) return v; return fa[v] = getfa(fa[v]); } void init() { memset(ok, 0, sizeof(ok)); memset(sz, 0, sizeof(sz)); cin \u0026gt;\u0026gt; n; string a; for ( int i('a'); i \u0026lt;= 'z'; i++) fa[i] = i; for ( int i(1); i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a; int x = a[0], y = a[a.size() - 1]; fa[getfa(x)] = getfa(y); ok[x] = ok[y] = true; sz[x]++; sz[y]--; } } bool check() { int tf = 0 , i; for ( i = 'a'; i \u0026lt;= 'z'; i++) { if (ok[i]) { if ( !tf ) tf = getfa(i); else if ( getfa(i) != tf ) return false; // 不连通 } } int c1 = 0, c2 = 0; for ( int i('a'); i \u0026lt;= 'z'; i++) { if (!ok[i]) continue; if ( sz[i] == 0 ) continue; else if ( sz[i] == 1 ) c1++; else if ( sz[i] == -1) c2++; else return false; // 其它乱七八糟的情况 比如 ab ab out[a]=2 in[b]=2 } if ( (c1 == 1 \u0026amp;\u0026amp; c2 == 1) || (c1 == 0 \u0026amp;\u0026amp; c2 == 0) ) // 单向路径 or 回路 return true; else return false; } int main() { freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin); for ( cin \u0026gt;\u0026gt; T; T--; ) { init(); if (check()) cout \u0026lt;\u0026lt; \u0026quot;Ordering is possible.\u0026quot; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026quot;The door cannot be opened.\u0026quot; \u0026lt;\u0026lt; endl; } } 二分图最大匹配 @ POJ 3041 Asteroids 匈牙利算法 /* 看起来像个 DP 神马的。竟然是二分图匹配。。 看着啊，行与行之间相互独立，一个行可以就炸掉很多列。（列的道理一样），如果替换一些字。 点与点之间相互独立，一个点就可以炸掉很多边。 so，可以把行列看成一个点，把一个炸弹看成一条边，然后题目就转换城了最小点击覆盖（即最大匹配）。 这个题的思路就是上面说的，每一个炸弹（x，y）看做一条边，两个端点就是它的行列x 和 y。任意炸掉x y期中一个点都可以把可以把这条边炸掉。跟题目一样了。 就这么神奇。。 */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; const int N = 555; int n, m, g[N][N], chk[N], match[N]; int dfs(int v){ int t; for ( int i = 1; i \u0026lt;= n; i++){ if ( g[i][v] \u0026amp;\u0026amp; !chk[i] ){ chk[i] = 1; t = match[i]; match[i] = v; if ( t == -1 || dfs(t) ) return 1; match[i] = t; } } return 0; } int main(){ while ( ~scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n ,\u0026amp;m) ){ memset(g, 0, sizeof(g)); while ( m-- ){ int a, b; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;a, \u0026amp;b); g[a][b] = 1; } int ans = 0; memset(match, 255, sizeof(match)); for ( int i = 1; i \u0026lt;= n; i++){ memset( chk, 0, sizeof(chk)); ans += dfs(i); } printf(\u0026quot;%d\\n\u0026quot;, ans); } return 0; } ","date":1349668800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1349668800,"objectID":"c7788e5c30981a4bc38973c105b5915a","permalink":"/post/dashayu/1349668800-acmtips/","publishdate":"2012-10-08T12:00:00+08:00","relpermalink":"/post/dashayu/1349668800-acmtips/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 var tt = [\"\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\", \"七\", \"八\", \"九\",","tags":null,"title":"acmtips","type":"post"},{"authors":null,"categories":["typecho"],"content":"每个人心中都有一个理想的博客，这些并不是那些通用博客服务商能提供的，于是我选择自己动手搭建，用心逐雕。\n本文通篇按时间逆序记录\n转移 Typecho   [Todo] 图片全屏查看\n  [ToDo] 列表块跳转页面\n  [ToDo] 文章列表显示第一张图片\n  [2015-9-11] 迁移到阿里云，学生优惠，且虚拟主机太难管理\n  [2015-1-26] 迁移到阿里虚拟主机，送两年。速度快\n  [2014-11-27] 第一次正式购买服务器 BudgetVM\n  [2014-6-5] 使用多说评论框\n  [2014-6-4] 区别微博和文章\n  [2014-6-3] 文章页面添加目录功能\n  Aliyun抽奖到￥350，于是乎迁到此并换到 Typecho。同时开始重新设计前端\n  正式使用   [201305] 完成自己的第一套主题\n  [201210] 大一开学，换到欧洲的 hostyd，延迟从360ms降低到320ms\n  高考结束后，用美国的 000webhost + .tk + wordpress 搭建\n  第一次   2012元旦，在560教室拿zblog搭好第一个博客，国内某免费空间和域名\n ","date":1275539220,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1275539220,"objectID":"f64ca7e858de992f4ceb3873be56d67c","permalink":"/post/typecho/85-%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE%E6%97%A5%E5%BF%97/","publishdate":"2010-06-03T12:27:00+08:00","relpermalink":"/post/typecho/85-%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE%E6%97%A5%E5%BF%97/","section":"post","summary":"每个人心中都有一个理想的博客，这些并不是那些通用博客服务商能提供的，于是我选择自己动手搭建，用心逐雕。\n","tags":["记事","IT技术堆"],"title":"博客建设日志","type":"post"}]